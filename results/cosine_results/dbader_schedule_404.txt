{ "issues": [ { "file": "schedule/init.py", "line": 343, "description": "AttributeError risk: In Job.str, accessing self.job_func.args and self.job_func.keywords assumes self.job_func is a functools.partial. If job_func is not set, or is not a partial, this will raise AttributeError." }, { "file": "schedule/init.py", "line": 428, "description": "TypeError risk: In Job.at(), time_str is split and unpacked assuming certain lengths. For invalid strings that pass previous regex (e.g., '12:34' for unit 'hours'), unpacking hour, minute = time_values can raise ValueError." }, { "file": "schedule/init.py", "line": 517, "description": "Logic error: In Job._schedule_next_run(), the check 'if not (self.latest >= self.interval): raise ScheduleError('latest is greater than interval')' has the error message backwards; it should be 'interval is greater than latest'." }, { "file": "schedule/init.py", "line": 521, "description": "ValueError risk: In Job._schedule_next_run(), datetime.timedelta(**{self.unit: interval}) will raise a TypeError if self.unit is not a valid timedelta argument (e.g. typo leads to 'minute' instead of 'minutes')." }, { "file": "schedule/init.py", "line": 90, "description": "ValueError risk: In Scheduler.idle_seconds, if there are no jobs scheduled, self.next_run is None, so 'self.next_run - datetime.datetime.now()' raises TypeError." }, { "file": "schedule/init.py", "line": 81, "description": "Sort instability: In Scheduler.run_pending, jobs are sorted but Job.lt does not handle next_run=None, which can cause TypeError if next_run is None for any job." } ] }