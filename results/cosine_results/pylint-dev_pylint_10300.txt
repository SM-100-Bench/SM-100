{ "issues": [ { "file": "pylint/checkers/utils.py", "line": 320, "description": "The function safe_infer can silently swallow all exceptions raised from inference, potentially hiding critical bugs in inference logic or masking real user code issues. Catching Exception broadly is dangerous, and should at least log or re-raise non-inference errors." }, { "file": "pylint/checkers/imports.py", "line": 173, "description": "In ImportsChecker.visit_importfrom, there is a direct use of os.path.dirname, os.path.abspath, and os.path.join without normalization or path traversal checks. If the filename comes from an untrusted source, this could allow for directory traversal vulnerabilities." }, { "file": "pylint/checkers/format.py", "line": 281, "description": "In _check_line_too_long, the code does not protect against UnicodeDecodeError when reading files with unexpected encodings. This could cause a crash on non-UTF-8 source files." }, { "file": "pylint/checkers/logging.py", "line": 200, "description": "The checker uses astroid inference on logging format strings, but does not guard against exceptions if the format string is not a string or if inference fails catastrophically, which can crash the checker." }, { "file": "pylint/extensions/bad_builtin.py", "line": 34, "description": "The extension blacklists dangerous builtins like eval and exec, but does not check aliases or shadowing, so malicious code can bypass these checks by aliasing. Not a crash, but a security blind spot." }, { "file": "pylint/checkers/dunder_methods.py", "line": 68, "description": "Calls to getattr on AST nodes are not guarded, which could raise AttributeError and crash the checker if an unexpected node type is encountered." }, { "file": "pylint/checkers/exceptions.py", "line": 110, "description": "Catches Exception broadly when checking exception handlers; this can hide real bugs in the checker or in astroid. At least log or restrict to known safe exceptions." }, { "file": "pylint/checkers/threading_checker.py", "line": 62, "description": "Uses AST inference to find threading/thread calls without guarding against inference errors. Malformed code or unexpected AST could cause unhandled exceptions." }, { "file": "pylint/checkers/classes/class_checker.py", "line": 512, "description": "Possible infinite recursion or stack overflow if classes are deeply nested or circular; code does not protect against recursion depth exceeded errors." }, { "file": "pylint/checkers/typecheck.py", "line": 1187, "description": "TypeChecker attempts to infer types with no fallback or timeout/recursion limit, which could hang or crash on pathological user code." }, { "file": "pylint/testutils/_primer/primer.py", "line": 49, "description": "Direct use of subprocess.run with user-supplied command lines in primer logic. If input is not sanitized, this could allow arbitrary code execution in some testing scenarios." }, { "file": "pylint/testutils/tokenize_str.py", "line": 18, "description": "Tokenization does not guard against TokenError or malformed input, which could crash test utilities if given malformed code." }, { "file": "pylint/checkers/ellipsis_checker.py", "line": 30, "description": "Does not check that the node is actually an ellipsis before analyzing; could raise exceptions on malformed AST." }, { "file": "pylint/extensions/no_self_use.py", "line": 76, "description": "Uses AST traversal that assumes certain attributes exist; could crash if astroid parses future/novel Python constructs." } ] }