{ "issues": [ { "file": "peewee.py", "line": 1570, "description": "Potential SQL injection in execute_sql(), as the SQL and params are logged with logger.debug((sql, params)). If the logger is misconfigured to output to an insecure location, this could leak sensitive data. SQL itself is parameterized, so the risk is limited, but logging raw queries and parameters is a common source of accidental data leaks." }, { "file": "peewee.py", "line": 1687, "description": "In SqliteDatabase._set_pragmas(), PRAGMA statements are constructed using string interpolation (cursor.execute('PRAGMA %s = %s;' % (pragma, value))). If an attacker can control 'pragma' or 'value', this is a SQL injection vector. In practice, PRAGMAs are set by trusted code, but this code does not sanitize or parameterize these values." }, { "file": "peewee.py", "line": 1696, "description": "In SqliteDatabase._attach_databases(), the method uses string interpolation to build SQL (cursor.execute('ATTACH DATABASE \"%s\" AS \"%s\"' % (db, name))). As above, if 'db' or 'name' is attacker-controlled, this is a SQL injection vulnerability." }, { "file": "peewee.py", "line": 1743, "description": "In SqliteDatabase.pragma(), the SQL is constructed as sql = 'PRAGMA %s' % key, and later sql += ' = %s' % (value or 0). This is not parameterized, so carefully crafted 'key' or 'value' could result in arbitrary SQL execution if attacker-controlled." }, { "file": "peewee.py", "line": 2081, "description": "MySQLDatabase._connect() passes self.connect_params directly to mysql.connect() with autocommit=True. If the connect_params dict is attacker-controlled, this may allow for privilege escalation or unsafe connection settings. This is mitigated if connect_params is always set by trusted config." }, { "file": "peewee.py", "line": 2299, "description": "In MySQLDatabase.get_indexes(), the code accesses row elements by index (e.g. row[1], row[2], row[4]) without checking the returned tuple length, which could result in IndexError if the underlying MySQL server or driver changes the output format or returns nulls." }, { "file": "peewee.py", "line": 812, "description": "In the 'Value' class, the constructor sets self.multi = unpack and isinstance(self.value, multi_types), and constructs self.values via for item in self.value. If self.value is not a sequence but is iterable, this could raise a TypeError. This could cause exceptions in edge cases." }, { "file": "pwiz.py", "line": 220, "description": "The password is read via getpass() if --password is set, but the handling of connect_kwargs does not sanitize or escape values before passing to the database driver. If passed to e.g., MySQL or Postgres, and the password or username contains special characters, this could cause a failed connection or, in rare cases, command injection if further processed." }, { "file": "pwiz.py", "line": 78, "description": "DATABASE_MAP is generated by flattening DATABASE_ALIASES. If a new backend is added without an alias, it won't be available via the CLI, which could lead to confusion or inability to use new DBs via pwiz." }, { "file": "peewee.py", "line": 4176, "description": "In Model.eq(), the code checks self._pk is not None and then compares self._pk == other._pk. If _pk is not set for either instance, this will raise an AttributeError or give incorrect results. Should be more defensive for uninitialized or unsaved models." } ] }