{ "issues": [ { "file": "pypdf/_merger.py", "line": 120, "description": "File objects created in _create_stream are never closed if they are of type FileIO and not managed by the context manager. This can lead to file descriptor leaks, especially if many merges are done in a long-running process." }, { "file": "pypdf/_merger.py", "line": 356, "description": "In close(), if self.pages contains PageObjects that hold references to other resources (e.g., memory buffers), clearing self.pages before closing input file objects (self.inputs) could potentially lead to resource leaks if page objects maintain a reference to those files." }, { "file": "pypdf/_merger.py", "line": 136, "description": "In the merge() method, if a provided fileobj is not a valid input (e.g., not a Path, string, PdfReader, or stream-like object), _create_stream will raise NotImplementedError, which is not caught by merge(). This can result in abrupt crashes instead of a graceful error message." }, { "file": "pypdf/_writer.py", "line": 1240, "description": "In _create_stream, file objects are opened using a with statement, but the BytesIO stream is returned after the with block, meaning the underlying file is closed before the BytesIO is used (for 'fileobj' as a path or string). This can cause issues if the file is large or if the BytesIO is not fully read into memory before the file is closed." }, { "file": "pypdf/_writer.py", "line": 1518, "description": "In merge(), srcpages[pg.indirect_reference.idnum] is assigned to the return value of add_page or insert_page, which may receive a list with extra elements ([1, '/B', 1, '/Annots']) as excluded_keys. This seems unintended, as excluded_keys should be a list of keys to exclude, not containing integers. If add_page or insert_page does not handle these gracefully, it could result in logic errors or exceptions." }, { "file": "pypdf/_writer.py", "line": 1754, "description": "In _insert_filtered_annotations, for some types of annotation destination (e.g., named destinations as strings), the code checks for existence in get_named_dest_root(), but get_named_dest_root() returns an ArrayObject with a flat structure. This lookup may fail or be inefficient for large numbers of named destinations, and the code may add duplicate or incorrect references." }, { "file": "pypdf/_writer.py", "line": 735, "description": "In write(), if the provided stream is a string or Path, the file is opened and stream.close() is called only if self.with_as_usage is True. If the caller does not use a context manager and does not expect the file to be closed, this can lead to confusing resource management and potential file descriptor leaks." }, { "file": "pypdf/_writer.py", "line": 1442, "description": "In _get_filtered_outline, node.get_object() is called recursively and may return NullObject or DictionaryObject. If the structure is corrupted, this could lead to infinite recursion or stack overflow." }, { "file": "pypdf/_writer.py", "line": 1541, "description": "In _insert_filtered_annotations, the handling of annotation destinations may not be robust against malformed or unexpected annotation structures, which could lead to exceptions if fields are missing or of the wrong type. Defensive programming (e.g., checking types and presence of keys) is limited." } ] }