{ "issues": [ { "file": "common/archiver/filestore/historyArchiver.go", "line": 183, "description": "Potential nil pointer dereference. The code assumes 'historyBlob' is not nil after error checks, but if 'err' is nil and 'historyBlob' is nil, a panic can occur." }, { "file": "common/archiver/filestore/queryParser.go", "line": 98, "description": "No input sanitization for query strings. This could lead to injection vulnerabilities if the queries are used downstream with file or DB operations." }, { "file": "common/archiver/gcloud/historyArchiver.go", "line": 165, "description": "No error check for file close operation. A failed file close may result in resource leaks or incomplete file writes." }, { "file": "common/archiver/gcloud/connector/client.go", "line": 87, "description": "Unvalidated user input in GCS path construction. If 'bucket' or 'object' are user-controlled, this could allow path traversal or access to unintended objects." }, { "file": "common/archiver/s3store/historyArchiver.go", "line": 207, "description": "S3 upload does not set server-side encryption. This may leave archived data unencrypted and vulnerable if the S3 bucket policy does not enforce encryption." }, { "file": "common/auth/tls.go", "line": 93, "description": "TLS config allows InsecureSkipVerify=true if passed from config. This disables certificate validation and exposes to MITM attacks." }, { "file": "common/authorization/default_token_key_provider.go", "line": 66, "description": "No expiration check on cached JWKS keys. The cache may use expired keys, leading to authorization bypass or failures." }, { "file": "common/backoff/retry.go", "line": 134, "description": "Potential infinite retry if maxAttempts is not properly set or validated. This could cause runaway goroutines and resource exhaustion." }, { "file": "common/collection/concurrentPriorityQueue.go", "line": 102, "description": "Improper use of sync.Cond and slices could lead to race conditions or missed wakeups if not carefully handled under lock." }, { "file": "common/codec/gob/gob.go", "line": 48, "description": "Gob decoder is used on arbitrary payloads with no size or type checks. This is susceptible to resource exhaustion or type confusion attacks." }, { "file": "common/locks/id_mutex.go", "line": 77, "description": "No limit on number of mutexes created for arbitrary IDs. This can lead to unbounded memory usage if IDs are user-controlled." }, { "file": "common/persistence/cassandra/cassandraHistoryPersistence.go", "line": 232, "description": "No sanitation or validation of query parameters before passing them to Cassandra. This could allow for query injection if not handled by the driver." }, { "file": "common/persistence/sql/sqlplugin/mysql/db.go", "line": 112, "description": "Directly concatenated SQL query strings with variables. This can lead to SQL injection unless all variables are strictly sanitized or parameterized." }, { "file": "common/persistence/serialization/blob.go", "line": 38, "description": "Unmarshal on untrusted input without size or type limits may result in resource exhaustion or panics." }, { "file": "common/persistence/visibility/store/elasticsearch/client/client.go", "line": 143, "description": "Elasticsearch client error handling swallows errors in bulk operations, possibly leading to silent data loss." }, { "file": "common/rpc/encryption/certificate.go", "line": 74, "description": "No check for empty certificate or key files. This can result in TLS startup panics or insecure defaults." }, { "file": "common/serviceerror/convert.go", "line": 51, "description": "Service error conversion uses string matching on error messages, which is fragile and can fail if error message wording changes." } ] }