{ "issues": [ { "file": "zstd/bitreader.go", "line": 74, "description": "In bitReader.fill(), when b.off < 4, the for loop reads b.in[b.off-1] without an explicit lower-bound check. If b.off == 0, b.in[-1] will panic. However, the loop condition (b.off > 0) provides some protection, but the logic is subtle and could be prone to future maintenance errors." }, { "file": "zstd/blockdec.go", "line": 512, "description": "decodeLiterals: When decompressing literals using huff.Decoder().Decompress4X or Decompress1X, the result is assigned to 'literals' and then checked for length. However, if an error occurs and the returned slice is nil, subsequent code may panic on len(literals)." }, { "file": "zstd/blockdec.go", "line": 557, "description": "decodeLiterals (compressed case): If hist.huffTree is nil and huff0.ReadTable returns an error, the function returns but does not reset or clear hist.huffTree, leading to possible reuse of invalid state in further decompression." }, { "file": "zstd/blockdec.go", "line": 485, "description": "decodeLiterals: For literalsBlockRLE, if litRegenSize is very large (close to int max), allocating a huge buffer could cause OOM. While some checks are present, the use of litRegenSize could be further hardened." }, { "file": "zstd/encoder.go", "line": 249, "description": "In Encoder.nextBlock(), concurrent goroutine errors are stored only in s.err and s.writeErr. There's a risk that an error set in the goroutine may not be immediately visible to the caller, leading to possible silent failures or data loss if not carefully coordinated with WaitGroups." }, { "file": "zstd/encoder.go", "line": 539, "description": "EncodeAll: If fh.appendTo returns an error (should not happen under normal conditions), the code panics instead of returning the error. This could crash applications using the library on malformed or unexpected input." }, { "file": "zstd/dict.go", "line": 76, "description": "loadDict: The dictionary ID 0 is explicitly disallowed, but this is only checked after the magic check and reading 8 bytes. If a malformed dictionary is provided, the error message could be more precise regarding the actual problem." }, { "file": "internal/lz4ref/block.go", "line": 144, "description": "CompressBlock: In the match finding logic, there are multiple places where src[ref:] is accessed, and ref can be negative (especially in the first window). Although later logic typically prevents out-of-bounds, the complex offset calculations could lead to panics on malformed or adversarial inputs." }, { "file": "internal/lz4ref/block.go", "line": 613, "description": "UncompressBlock: Use of panic/recover to catch out-of-bounds and other critical errors is not recommended for decompression security. Malformed or malicious input could trigger panics, which are then silently swallowed and mapped to a generic error code, making debugging and security auditing harder." }, { "file": "internal/snapref/decode.go", "line": 108, "description": "Decode: No check for overlap between dst and src. If the caller provides overlapping slices (which is explicitly disallowed), this could lead to memory corruption." } ] }