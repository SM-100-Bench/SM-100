{ "issues": [ { "file": "server/data/file/file.go", "line": 65, "description": "os.Create is called to create the file, but the created file descriptor 'out' is never closed. This can lead to file descriptor leaks and resource exhaustion. 'defer out.Close()' should be added after successful creation." }, { "file": "server/data/file/file.go", "line": 77, "description": "If io.Copy fails, the partially written file is not cleaned up. Consider deleting the file if the copy fails to avoid leaving corrupt files." }, { "file": "server/data/file/file.go", "line": 119, "description": "In RemoveFile(), a goroutine attempts to remove the parent directory without synchronization. This could result in race conditions if multiple operations try to remove the same directory simultaneously." }, { "file": "server/data/gcs/gcs.go", "line": 60, "description": "In AddFile, 'defer wc.Close()' is called before io.Copy. If io.Copy returns an error, the write may not be properly flushed or closed. It is safer to close the writer after io.Copy and to handle errors from both io.Copy and wc.Close()." }, { "file": "server/data/s3/s3.go", "line": 96, "description": "In NewBackend, bucket is created if not found, but there is no check for concurrent creation or race conditions which could result in errors if multiple instances try to create the bucket simultaneously." }, { "file": "server/data/s3/s3.go", "line": 120, "description": "GetFile returns the io.ReadCloser from minio.GetObject without checking if the object actually exists; errors will be delayed until the first read. Consider calling StatObject to fail early if the object does not exist." }, { "file": "server/data/stream/stream.go", "line": 54, "description": "In AddFile, 'defer delete(b.store, storeID)' is called while holding the lock, but the actual delete will not occur until after the function returns, which is after the potentially long io.Copy operation. This means the lock is released but the store entry is only deleted at the end, possibly leading to memory retention or resource leak." }, { "file": "server/data/stream/stream.go", "line": 59, "description": "The io.Copy to pipeWriter is not checked for returning io.ErrClosedPipe, which may happen if the reader closes early. This could cause goroutine leaks or unhandled errors." }, { "file": "server/data/swift/swift.go", "line": 51, "description": "In GetFile, a goroutine writes to pipeWriter but does not check for errors returned by ObjectGet or by CloseWithError. If ObjectGet fails, the reader may block indefinitely." }, { "file": "server/data/swift/swift.go", "line": 95, "description": "In AddFile, object.Close() is called after io.Copy, but if io.Copy fails, object.Close() may not be called, potentially leaking resources. Use defer for object.Close() after successful creation." } ] }