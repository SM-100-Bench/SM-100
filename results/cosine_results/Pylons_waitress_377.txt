{ "issues": [ { "file": "src/waitress/buffers.py", "line": 12, "description": "Class-level attribute 'remain' in FileBasedBuffer is shared across all instances, which can lead to incorrect buffer accounting and unpredictable behavior. It should be an instance attribute." }, { "file": "src/waitress/buffers.py", "line": 174, "description": "Class-level attributes 'overflowed', 'buf', and 'strbuf' in OverflowableBuffer are shared across all instances. This is unsafe for concurrent use and can result in corrupted buffer state." }, { "file": "src/waitress/channel.py", "line": 107, "description": "The method 'handle_write' calls 'handle_close' without checking if the channel is already closed. If 'will_close' is set multiple times, this can cause double-close attempts." }, { "file": "src/waitress/channel.py", "line": 275, "description": "Potential race condition: outbuf_lock is used for multi-threaded access to output buffers, but the scope of lock acquisition is sometimes narrow. There may be subtle races if buffer state is accessed elsewhere without holding the lock." }, { "file": "src/waitress/channel.py", "line": 357, "description": "In 'write_soon', if the socket is closed after the initial check but before data is written, a ClientDisconnected exception may not be raised, possibly causing exceptions elsewhere." }, { "file": "src/waitress/channel.py", "line": 447, "description": "In 'service', if an exception is thrown during 'task.service()', there is a fallback error response. However, if that error response also fails, the code may not clean up resources or close the connection properly." }, { "file": "src/waitress/receiver.py", "line": 24, "description": "Class-level attributes 'completed' and 'error' in FixedStreamReceiver are shared across all instances. This can cause incorrect state sharing between receivers." }, { "file": "src/waitress/receiver.py", "line": 49, "description": "Class-level attributes 'chunk_remainder', 'validate_chunk_end', 'control_line', 'chunk_end', 'all_chunks_received', 'trailer', 'completed', 'error' in ChunkedReceiver are shared across all instances. This can lead to severe bugs in concurrent or repeated use." }, { "file": "src/waitress/task.py", "line": 41, "description": "Class-level attributes ('close_on_finish', 'status', 'wrote_header', 'start_time', 'content_length', etc.) in Task and its subclasses are shared across all instances, leading to unpredictable task behavior." }, { "file": "src/waitress/trigger.py", "line": 101, "description": "In POSIX trigger's _close(), 'os.close(fd)' is called for each fd in self._fds without checking if the FD is already closed. This can result in OSError if close() is called more than once." }, { "file": "src/waitress/wasyncore.py", "line": 512, "description": "dispatcher.del_channel() sets self._fileno to None before calling self.socket.close() in dispatcher.close(). If self.socket.close() raises and relies on a valid fileno, this may cause issues." }, { "file": "src/waitress/wasyncore.py", "line": 633, "description": "In file_wrapper.del, warnings.warn is called unconditionally if fd >= 0, but del also calls self.close(), which may cause double-close or misleading warnings if close() has already been called elsewhere." } ] }