{ "issues": [ { "file": "django/core/files/locks.py", "line": 24, "description": "On Windows, the lock is implemented using msvcrt.locking, which applies only to the file descriptor, not the file object. This can cause problems if the file is opened more than once or in different modes, possibly allowing multiple processes to believe they have an exclusive lock. This is a platform limitation, but it's a potential source of data corruption." }, { "file": "django/core/files/temp.py", "line": 14, "description": "TemporaryFile is imported from tempfile, but the code may be used on platforms with different default temp directory permissions, which can be a security risk if not set properly. Always ensure temp directories are secure, especially when handling sensitive files." }, { "file": "django/core/files/uploadedfile.py", "line": 204, "description": "The InMemoryUploadedFile and TemporaryUploadedFile classes accept file uploads. There is a risk of denial-of-service (DoS) if 'DATA_UPLOAD_MAX_MEMORY_SIZE' and 'FILE_UPLOAD_MAX_MEMORY_SIZE' are not set properly in settings, as a large upload could consume excessive memory or disk space." }, { "file": "django/core/mail/backends/filebased.py", "line": 28, "description": "The backend writes email files using open() with 'wb' mode, but does not use os.open with O_EXCL, so there's a small race window where two processes could write to the same filename, causing possible data loss or corruption." }, { "file": "django/core/signing.py", "line": 156, "description": "The TimestampSigner uses base64 encoding and HMAC for signatures, but key rotation is not natively supported. If a key is leaked, old signatures remain valid until all are expired. This is a security design limitation." }, { "file": "django/core/cache/backends/filebased.py", "line": 82, "description": "FileBasedCache uses pickle to serialize cache values. If a cache directory is shared between trusted and untrusted code, this can lead to remote code execution (RCE) via pickle deserialization. Never share cache between apps with different trust boundaries." }, { "file": "django/core/handlers/asgi.py", "line": 57, "description": "ASGIHandler does not set a hard limit on concurrent requests or memory usage, which could allow unbounded resource exhaustion if a malicious client sends many concurrent requests." }, { "file": "django/core/handlers/wsgi.py", "line": 132, "description": "WSGIHandler does not catch all exceptions in the application, relying on the web server to handle uncaught exceptions. If misconfigured, this could expose tracebacks to the client or cause the server to crash." }, { "file": "django/conf/global_settings.py", "line": 377, "description": "The default SECRET_KEY is empty. If a user does not set their own SECRET_KEY, cryptographic signatures will be insecure, leading to session and CSRF vulnerabilities." }, { "file": "django/core/validators.py", "line": 472, "description": "The URLValidator uses a regular expression for URLs but can be bypassed for some invalid or dangerous URLs, such as javascript: URIs, unless the user also filters schemes. This can lead to XSS in applications that display user-submitted URLs without proper escaping." }, { "file": "django/core/checks/security/csrf.py", "line": 36, "description": "CSRF middleware relies on the presence of a CSRF token in cookies and POST data. If a site sets CSRF_TRUSTED_ORIGINS too broadly, it can allow cross-site request forgery attacks." }, { "file": "django/core/exceptions.py", "line": 61, "description": "ImproperlyConfigured, SuspiciousOperation, and other exceptions are raised in many places in Django. If caught and suppressed improperly by application code, this can lead to insecure or inconsistent application states." } ] }