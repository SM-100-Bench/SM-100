{ "issues": [ { "file": "etebase_fastapi/routers/authentication.py", "line": 217, "description": "In function 'signup_save', after creating a user, checks if 'userinfo' exists and raises if so, but does not handle the race condition where two requests could create the same user simultaneously, possibly leading to IntegrityError or duplicate creation attempts." }, { "file": "etebase_fastapi/routers/authentication.py", "line": 112, "description": "'get_encryption_key' uses 'settings.SECRET_KEY' directly for key derivation without key stretching (e.g., PBKDF2, scrypt, argon2), which could weaken brute-force resistance if the SECRET_KEY or salt is weak/guessable." }, { "file": "etebase_fastapi/routers/authentication.py", "line": 133, "description": "'save_changed_password' writes unvalidated user input directly to the 'loginPubkey' and 'encryptedContent' fields of UserInfo. If the upstream validation is bypassed, this could lead to a corrupted state or further downstream issues." }, { "file": "etebase_fastapi/routers/collection.py", "line": 343, "description": "In 'item_create', after fetching or creating an item, the function compares the current etag with the revision_data.uid to determine up-to-date status, but does not check if revision_data.uid is None. If it is, this could lead to a logical error or crash." }, { "file": "etebase_fastapi/routers/collection.py", "line": 388, "description": "'item_list_common' and related list endpoints allow a 'limit' parameter up to 50, but do not enforce an upper bound. An excessively high limit could lead to denial-of-service from large queries." }, { "file": "etebase_fastapi/routers/collection.py", "line": 527, "description": "'item_bulk_common' uses 'select_for_update' to lock the collection object, but does not lock related items, potentially allowing race conditions or inconsistent state if multiple bulk operations are attempted concurrently on the same collection." }, { "file": "etebase_fastapi/routers/collection.py", "line": 617, "description": "'chunk_update' does not validate the size of the uploaded chunk. This could allow a malicious client to upload large files and exhaust disk space (resource exhaustion)." }, { "file": "etebase_fastapi/routers/websocket.py", "line": 74, "description": "'get_ticket' uses a 32-byte random value as the ticket, but encodes it with URLSafeBase64Encoder, which results in a string that may not be uniformly random over the reduced alphabet, and does not check for possible (though very unlikely) collisions in Redis." }, { "file": "etebase_fastapi/routers/websocket.py", "line": 105, "description": "'load_websocket_ticket' deletes the ticket from Redis after retrieval, but does not check for replay attacks if an attacker manages to use the ticket twice before it's deleted (e.g., in a race condition)." }, { "file": "etebase_fastapi/routers/websocket.py", "line": 128, "description": "In 'websocket_endpoint', if authentication fails and user is None, the websocket is not explicitly closed, possibly leaving an open connection." } ] }