{ "issues": [ { "file": "src/apscheduler/triggers/calendarinterval.py", "line": 59, "description": "The '_last_fire_date' field is typed as 'date | None' but is initialized with 'as_aware_datetime', which returns a datetime. This mismatch could cause type-related issues. Furthermore, in 'next()', it is used as a date, which may lead to subtle bugs if a datetime is ever assigned." }, { "file": "src/apscheduler/triggers/calendarinterval.py", "line": 78, "description": "In 'next()', the code uses 'datetime.fromtimestamp(timestamp, self.timezone)' to construct the next fire time. On some Python versions/platforms, passing a non-UTC timezone here can yield inconsistent results or exceptions due to the underlying platform (see Python's datetime docs). This could cause incorrect scheduling in some environments." }, { "file": "src/apscheduler/triggers/combining.py", "line": 77, "description": "In 'AndTrigger.next()', 'self._next_fire_times[i] - earliest_fire_time' assumes both are not None, but if 'self._next_fire_times[i]' is None, this will raise a TypeError. The code above does check for None, but if the list is mutated elsewhere, this could be a problem. (Low risk in current code, but should be explicitly protected.)" }, { "file": "src/apscheduler/triggers/combining.py", "line": 108, "description": "In 'OrTrigger.next()', there is a risk of infinite loops or missed triggers if the underlying triggers' 'next()' methods do not advance their own state correctly. This risk is inherent in the design, but could lead to high CPU usage if malformed triggers are used." }, { "file": "src/apscheduler/triggers/cron/init.py", "line": 153, "description": "In '_increment_field_value()', the 'datetime(**values)' call does not set tzinfo. Later, 'datetime.fromtimestamp(..., self.timezone)' is called, but this could yield incorrect local times or DST issues if 'values' do not fully specify a valid datetime (especially when rolling over months/years)." }, { "file": "src/apscheduler/triggers/cron/fields.py", "line": 72, "description": "In 'BaseField.append_expression()', the code attempts to instantiate compilers using '**match.groupdict()'. If the regex groupdict does not match the constructor signature (e.g., missing required fields), this will raise TypeError. Ideally, this should be caught and reported as a user-facing error." }, { "file": "src/apscheduler/triggers/cron/fields.py", "line": 117, "description": "In 'DayOfWeekField.append_expression()', when converting numeric weekdays, the values are mapped with 'first = int(groups[0]) - 1; first = 6 if first < 0 else first'. If the input is '0', this maps to 6 (Saturday), which might not match user expectations since both 0 and 7 can represent Sunday in cron. This may cause confusion or incorrect scheduling." }, { "file": "src/apscheduler/triggers/interval.py", "line": 45, "description": "The constructor allows all interval parameters (weeks, days, etc.) to default to 0. If all are zero, the resulting timedelta is 0, which is forbidden in 'attrs_post_init', but this is only caught at instantiation. Consider making at least one parameter required or validating earlier." }, { "file": "src/apscheduler/triggers/cron/expressions.py", "line": 228, "description": "In 'WeekdayPositionExpression', the regex pattern is r'(?P<option_name>%s) +(?P<weekday_name>(?:\d+|\w+))', but no explicit error is raised if the input string does not match. This could cause silent failures or cryptic errors. Validation should be stricter." } ] }