{"repo_id": "prevwong_craft.js_131", "bugs": [{"description": "Potential runtime error when accessing properties of actualType without null/undefined checks. If actualType is null, undefined, or a primitive type, accessing actualType.craft will throw a TypeError. This can happen when the component type is not properly defined or is a string.", "file": "packages/core/src/utils/createNode.ts", "line": 52}, {"description": "Potential runtime error when accessing actualType.craft without proper validation. The code assumes actualType is an object with a craft property, but actualType could be a string, null, or undefined, leading to TypeError when trying to access properties.", "file": "packages/core/src/utils/createNode.ts", "line": 80}, {"description": "Potential runtime error when accessing nested properties actualType.craft.rules[key] without proper validation. If actualType.craft is undefined or actualType.craft.rules is undefined, this will throw a TypeError. The code should validate the existence of these nested properties before accessing them.", "file": "packages/core/src/utils/createNode.ts", "line": 98}, {"description": "Function can return undefined but the return type doesn't account for this. When deserializeComp is called recursively on line 38 and 44, if the recursive call returns undefined (void), it will be assigned to result[key], potentially causing issues downstream. The function should handle cases where deserialization fails.", "file": "packages/core/src/utils/deserializeNode.tsx", "line": 38}, {"description": "Incorrect falsy value check that excludes valid props. The condition `if (!prop)` will exclude legitimate falsy values like 0, false, and empty strings, which are valid React props. This could cause important prop values to be omitted during serialization. Should use `prop == null` or `prop === undefined` instead.", "file": "packages/core/src/utils/serializeNode.tsx", "line": 20}, {"description": "Potential runtime error when destructuring context without null check. The useContext hook can return null if the component is used outside of a NodeProvider, but the code immediately destructures the context without checking if it's null first. This will throw a TypeError when trying to destructure null.", "file": "packages/core/src/nodes/useInternalNode.ts", "line": 30}, {"description": "Potential runtime error when accessing state.nodes[id] without proper validation. The code accesses state.nodes[id] and then its _hydrationTimestamp property without checking if state.nodes exists or if the node with the given id exists. This could throw a TypeError if the node doesn't exist in the state.", "file": "packages/core/src/nodes/NodeContext.tsx", "line": 22}, {"description": "Potential runtime error when accessing component properties without type checking. The code accesses .name and .displayName properties on the comp parameter without verifying that comp is an object. If comp is a string, null, or undefined, this will either return undefined or throw a TypeError, leading to unpredictable behavior.", "file": "packages/core/src/utils/resolveComponent.ts", "line": 9}, {"description": "Function can return undefined but lacks explicit return type annotation. The resolveComponent function can return undefined when no matching component is found, but this is not reflected in the return type. This can lead to runtime errors when the calling code expects a string but receives undefined.", "file": "packages/core/src/utils/resolveComponent.ts", "line": 25}, {"description": "Potential runtime error when accessing nested properties without null checks. The code accesses data.linkedNodes[id] and then queries the node without checking if data.linkedNodes exists or if the linkedNodes[id] is defined. This could throw a TypeError if linkedNodes is undefined or if the specific id doesn't exist.", "file": "packages/core/src/nodes/Element.tsx", "line": 58}, {"description": "Potential runtime error when accessing state.events without validation. The code accesses state.events[key] without checking if state.events exists. If the events object is undefined or null, this will throw a TypeError when trying to access properties on it.", "file": "packages/core/src/utils/updateEventsNode.ts", "line": 8}, {"description": "Missing parent property validation in NodeData. The NodeData interface defines parent as required (NodeId), but in createTestNode.ts, the parent property is not included in the default data object. This could lead to runtime errors when code expects the parent property to always be present on node data.", "file": "packages/core/src/utils/createTestNode.ts", "line": 6}, {"description": "Potential runtime error when accessing properties of actualType without null/undefined checks. If actualType is null, undefined, or a primitive type, accessing actualType.craft will throw a TypeError. This can happen when the component type is not properly defined or is a string.", "file": "packages/core/src/utils/createNode.ts", "line": 52}, {"description": "Potential runtime error when accessing actualType.craft without proper validation. The code assumes actualType is an object with a craft property, but actualType could be a string, null, or undefined, leading to TypeError when trying to access properties.", "file": "packages/core/src/utils/createNode.ts", "line": 80}, {"description": "Potential runtime error when accessing nested properties actualType.craft.rules[key] without proper validation. If actualType.craft is undefined or actualType.craft.rules is undefined, this will throw a TypeError. The code should validate the existence of these nested properties before accessing them.", "file": "packages/core/src/utils/createNode.ts", "line": 98}, {"description": "Function can return undefined but the return type doesn't account for this. When deserializeComp is called recursively on line 38 and 44, if the recursive call returns undefined (void), it will be assigned to result[key], potentially causing issues downstream. The function should handle cases where deserialization fails.", "file": "packages/core/src/utils/deserializeNode.tsx", "line": 38}, {"description": "Incorrect falsy value check that excludes valid props. The condition `if (!prop)` will exclude legitimate falsy values like 0, false, and empty strings, which are valid React props. This could cause important prop values to be omitted during serialization. Should use `prop == null` or `prop === undefined` instead.", "file": "packages/core/src/utils/serializeNode.tsx", "line": 20}, {"description": "Potential runtime error when destructuring context without null check. The useContext hook can return null if the component is used outside of a NodeProvider, but the code immediately destructures the context without checking if it's null first. This will throw a TypeError when trying to destructure null.", "file": "packages/core/src/nodes/useInternalNode.ts", "line": 30}, {"description": "Potential runtime error when accessing state.nodes[id] without proper validation. The code accesses state.nodes[id] and then its _hydrationTimestamp property without checking if state.nodes exists or if the node with the given id exists. This could throw a TypeError if the node doesn't exist in the state.", "file": "packages/core/src/nodes/NodeContext.tsx", "line": 22}, {"description": "Potential runtime error when accessing component properties without type checking. The code accesses .name and .displayName properties on the comp parameter without verifying that comp is an object. If comp is a string, null, or undefined, this will either return undefined or throw a TypeError, leading to unpredictable behavior.", "file": "packages/core/src/utils/resolveComponent.ts", "line": 9}, {"description": "Function can return undefined but lacks explicit return type annotation. The resolveComponent function can return undefined when no matching component is found, but this is not reflected in the return type. This can lead to runtime errors when the calling code expects a string but receives undefined.", "file": "packages/core/src/utils/resolveComponent.ts", "line": 25}, {"description": "Potential runtime error when accessing nested properties without null checks. The code accesses data.linkedNodes[id] and then queries the node without checking if data.linkedNodes exists or if the linkedNodes[id] is defined. This could throw a TypeError if linkedNodes is undefined or if the specific id doesn't exist.", "file": "packages/core/src/nodes/Element.tsx", "line": 58}, {"description": "Potential runtime error when accessing state.events without validation. The code accesses state.events[key] without checking if state.events exists. If the events object is undefined or null, this will throw a TypeError when trying to access properties on it.", "file": "packages/core/src/utils/updateEventsNode.ts", "line": 8}, {"description": "Missing parent property validation in NodeData. The NodeData interface defines parent as required (NodeId), but in createTestNode.ts, the parent property is not included in the default data object. This could lead to runtime errors when code expects the parent property to always be present on node data.", "file": "packages/core/src/utils/createTestNode.ts", "line": 6}, {"description": "Incorrect property mapping in getDOMPadding function. Lines 5-6 have swapped property assignments: 'bottom' is assigned paddingTop and 'top' is assigned paddingBottom. This will return incorrect padding values.", "file": "./packages/utils/src/getDOMInfo.ts", "line": 5}, {"description": "Incorrect property mapping in getDOMMargin function. Lines 13-14 have swapped property assignments: 'bottom' is assigned marginTop and 'top' is assigned marginBottom. This will return incorrect margin values.", "file": "./packages/utils/src/getDOMInfo.ts", "line": 13}, {"description": "Typo in deprecation warning message. Line 7 has 'relases' instead of 'releases'. This is a spelling error in the warning message.", "file": "./packages/utils/src/deprecate.ts", "line": 7}, {"description": "Missing type annotation for 'effect' parameter in useEffectOnce function. The parameter should be typed as React.EffectCallback to ensure type safety.", "file": "./packages/utils/src/useEffectOnce.tsx", "line": 3}, {"description": "Missing type annotations for function parameters in expectNode function. Parameters 'node' and 'testData' have no type annotations, which could lead to runtime errors and reduces type safety.", "file": "./packages/core/src/utils/tests/createNode.test.tsx", "line": 4}, {"description": "Missing type annotation for 'href' parameter in Component function. The parameter should be typed to ensure type safety.", "file": "./packages/core/src/utils/tests/parseNodeFromJSX.test.tsx", "line": 5}, {"description": "Missing type annotations for 'history' variable and 'dummyTimeline' array. These variables should be properly typed to ensure type safety in the test file.", "file": "./packages/utils/src/tests/History.test.ts", "line": 7}, {"description": "Using 'any' type for React.FC generic parameter. The component should have proper type definition for its props instead of using 'any', which defeats the purpose of TypeScript type checking.", "file": "./packages/utils/src/RenderIndicator.tsx", "line": 3}, {"description": "Typo in error message constant. Line 5 has 'ommited' instead of 'omitted'. This is a spelling error in the error message.", "file": "./packages/utils/src/constants.ts", "line": 5}, {"description": "Missing type annotations for function parameters in createTestNode function. Parameters 'id', 'data', and 'config' should be properly typed to ensure type safety.", "file": "./packages/core/src/utils/createTestNode.ts", "line": 2}, {"description": "Missing type annotations for function parameters in testHelpers.ts. Functions like expectEditorState have parameters 'lhs' and 'rhs' without type annotations, which reduces type safety.", "file": "./packages/core/src/utils/testHelpers.ts", "line": 32}, {"description": "Potential null pointer exception in wrapConnectorHooks.tsx. In the throwIfCompositeComponentElement function, there's an empty error throw without a proper error message, which could make debugging difficult.", "file": "./packages/utils/src/wrapConnectorHooks.tsx", "line": 52}, {"description": "Potential null reference error in Handlers.ts. Line 9 accesses payload properties without null checking. If payload is undefined, accessing payload.suggest or payload.doc will cause a runtime error.", "file": "./packages/utils/src/deprecate.ts", "line": 9}, {"description": "Missing type annotations for function parameters in resolveComponent function. The function should have proper return type annotation since it can return undefined, which could lead to runtime errors if not handled properly.", "file": "./packages/core/src/utils/resolveComponent.ts", "line": 4}, {"description": "Potential runtime error in createNode function. Line 52 accesses actualType.craft without null checking. If actualType is null or undefined, this will cause a runtime error.", "file": "./packages/core/src/utils/createNode.ts", "line": 52}, {"description": "Potential runtime error in createNode function. Line 80 accesses actualType.craft without checking if actualType is defined. This could cause a runtime error if actualType is null or undefined.", "file": "./packages/core/src/utils/createNode.ts", "line": 80}], "updated_files": {}}