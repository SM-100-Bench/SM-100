{"repo_id": "astropy_astropy_14365", "bugs": [{"description": "In CsvWriter.writerow() and writerows() methods, the code modifies the input 'values' list in-place by replacing empty strings with sentinel values (lines 113 and 131). This mutates the caller's data, which is unexpected behavior and could cause bugs if the caller reuses the same list. The methods should work on a copy of the values to avoid side effects.", "file": "./astropy/io/ascii/core.py", "line": 113}, {"description": "In BaseInputter.get_lines() method, line 333 uses string concatenation 'table + \"\"' to check if table is a string-like object. However, if 'table' is not a string or doesn't support the '+' operator with strings, this will raise a TypeError. This TypeError is caught later, but it's inefficient and could mask other legitimate TypeErrors. A better approach would be to use isinstance(table, str) or hasattr(table, 'split') to check if table is string-like.", "file": "./astropy/io/ascii/core.py", "line": 333}, {"description": "In _get_line_index function, line 563 uses 'sum(1 for line in lines)' to count lines, which consumes the iterator if 'lines' is a generator. This could cause issues if the 'lines' iterator is used elsewhere after this function call, as it would be exhausted. The function should either work with a copy or ensure 'lines' is converted to a list first.", "file": "./astropy/io/ascii/core.py", "line": 563}, {"description": "In BaseHeader.get_cols method, line 622 calls _get_line_index with self.process_lines(lines) which returns a generator. This generator is consumed by _get_line_index, but then lines 636-642 call self.process_lines(lines) again expecting to iterate through the same data. However, if lines is a generator/iterator, it may have been partially or fully consumed by the first call, leading to incorrect behavior or missing the header line.", "file": "./astropy/io/ascii/core.py", "line": 622}, {"description": "In BaseData._set_fill_values method, lines 874-876 use a try-except pattern with suppress(TypeError) to check if self.fill_values[0] can be concatenated with a string. However, this approach is problematic because: 1) It assumes self.fill_values has at least one element without checking, which could raise IndexError, 2) The string concatenation test (self.fill_values[0] + '') is an unreliable way to detect if fill_values is a single tuple vs a list of tuples, and 3) It modifies self.fill_values in place which could have side effects. A better approach would be to check the structure more explicitly.", "file": "./astropy/io/ascii/core.py", "line": 875}, {"description": "In BaseData.write method, line 964 appends 'itertools.cycle(self.write_spacer_lines)' directly to the lines list. This is incorrect because itertools.cycle() returns an iterator object, not a string. The code should probably append the next value from the cycle, like 'next(itertools.cycle(self.write_spacer_lines))' or use a different approach to get spacer line strings.", "file": "./astropy/io/ascii/core.py", "line": 964}, {"description": "In HTMLSplitter.__call__ method, line 131 accesses el['colspan'] without checking if the 'colspan' attribute exists as a key. While line 132 uses el.has_attr('colspan') to check for the attribute's existence, line 131 directly accesses it as a dictionary key which could raise a KeyError if the attribute exists but is not accessible as a dictionary key. The code should use el.get('colspan') or el.attrs.get('colspan') for safer access.", "file": "./astropy/io/ascii/html.py", "line": 131}, {"description": "In HTML.__init__ method, line 330 uses a mutable default argument 'htmldict={}'. This is a common Python pitfall where the same dictionary object is reused across all instances of the class, potentially causing unexpected behavior when one instance modifies the dictionary and affects other instances. The default should be 'htmldict=None' with a check inside the method to create a new empty dict if None.", "file": "./astropy/io/ascii/html.py", "line": 330}, {"description": "In FixedWidthData.write method, line 274 uses the walrus operator (:=) in a conditional expression within a list comprehension. The expression '(val := getattr(col.info, col_attr)) is None' assigns the result of getattr to 'val' and then checks if it's None. However, if getattr raises an AttributeError (when col.info doesn't have the attribute col_attr), this will cause an unhandled exception. The code should use hasattr() to check for attribute existence first, or wrap getattr in a try-except block.", "file": "./astropy/io/ascii/fixedwidth.py", "line": 274}, {"description": "In FixedWidthHeader.get_cols method, lines 100-103 call core._get_line_index with self.process_lines(lines) twice. Since process_lines() returns a generator, the first call to _get_line_index may consume the generator, leaving the second call with an empty or partially consumed generator. This could lead to incorrect line indexing or missing data. The process_lines(lines) result should be converted to a list first or stored in a variable to be reused.", "file": "./astropy/io/ascii/fixedwidth.py", "line": 100}, {"description": "In tokenizer.c, the create_tokenizer function at line 10 calls malloc() to allocate memory for the tokenizer but does not check if malloc() returns NULL. If memory allocation fails, malloc() returns NULL, and subsequent operations on the tokenizer pointer will cause undefined behavior or segmentation faults. The function should check if malloc() returns NULL and handle the error appropriately.", "file": "./astropy/io/ascii/src/tokenizer.c", "line": 10}, {"description": "In tokenizer.c, the create_tokenizer function at line 34 calls malloc() to allocate memory for comment_lines but does not check if malloc() returns NULL. Similarly, line 40 calls calloc() for buf without checking for NULL return. If memory allocation fails, these functions return NULL, and subsequent operations will cause undefined behavior or segmentation faults. All memory allocation calls should be checked for NULL returns.", "file": "./astropy/io/ascii/src/tokenizer.c", "line": 34}, {"description": "In tokenizer.c, the resize_col function at lines 92-93 calls realloc() but does not check if it returns NULL. If realloc() fails, it returns NULL and the original memory block remains unchanged, but the code assigns NULL to self->output_cols[index], losing the reference to the original memory and causing a memory leak. Additionally, subsequent operations on the NULL pointer will cause undefined behavior. The function should check if realloc() returns NULL and handle the error appropriately.", "file": "./astropy/io/ascii/src/tokenizer.c", "line": 92}, {"description": "In tokenizer.c, the resize_comments function at lines 109-110 calls realloc() but does not check if it returns NULL. If realloc() fails, it returns NULL and the original memory block remains unchanged, but the code assigns NULL to self->comment_lines, losing the reference to the original memory and causing a memory leak. Additionally, the subsequent memset() call on line 112 will operate on a NULL pointer, causing undefined behavior. The function should check if realloc() returns NULL and handle the error appropriately.", "file": "./astropy/io/ascii/src/tokenizer.c", "line": 109}, {"description": "In qdp.py, the _interpret_err_lines function has a potential index out of bounds issue. At lines 222, 227, and 228, the code accesses colnames[i + 1] and colnames[i + 2] without checking if these indices are within the bounds of the colnames list. If i is near the end of the list, this could cause an IndexError. The function should verify that i + 1 and i + 2 are valid indices before accessing them.", "file": "./astropy/io/ascii/qdp.py", "line": 222}, {"description": "In ecsv.py, the EcsvHeader.get_cols method at line 176 accesses header['datatype'] without checking if the 'datatype' key exists in the header dictionary. If the ECSV file is malformed and doesn't contain the required 'datatype' key, this will raise a KeyError. The code should check for the existence of the 'datatype' key before accessing it and provide a more informative error message if it's missing.", "file": "./astropy/io/ascii/ecsv.py", "line": 176}, {"description": "In mrt.py, the MrtHeader._set_column_val_limits method at lines 113-114 calls max(col) and min(col) directly on the column object. However, if the column contains non-numeric data or has all masked values, these functions could raise a TypeError or ValueError. The code should handle these exceptions gracefully, especially since lines 115-118 already handle the case where the result is a MaskedConstant, indicating awareness of potential issues with masked data.", "file": "./astropy/io/ascii/mrt.py", "line": 113}], "updated_files": {}}