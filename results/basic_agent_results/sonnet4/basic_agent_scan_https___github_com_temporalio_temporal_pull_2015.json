{"repo_id": "temporalio_temporal_2015", "bugs": [{"description": "Potential nil pointer dereference in putInternal method. At line 299, the code accesses c.byAccess.Back().Value without checking if Back() returns nil. If the cache is empty (which shouldn't happen given the len check, but could occur due to race conditions or other edge cases), this would cause a panic. The same issue exists at line 304 where c.byAccess.Front() is accessed without nil checking.", "file": "common/cache/lru.go", "line": 299}, {"description": "Potential nil pointer dereference in iterator. At line 222, the code iterates over cmap.shards[i].items without checking if items is nil. While lazyInitShard is called in write operations, the iterator only acquires read locks and doesn't initialize the shard. If a shard has never been written to, its items map will be nil, causing a panic when range is called on it.", "file": "common/collection/concurrent_tx_map.go", "line": 222}, {"description": "Incorrect error message in UnlockLow method. At line 133, the panic message says 'unable to unlock high priority' but it should say 'unable to unlock low priority' since this is the UnlockLow method. This could cause confusion during debugging.", "file": "common/locks/priority_mutex_impl.go", "line": 133}, {"description": "Multiple typos in error messages: 'Erorr' should be 'Error'. This appears in several error messages throughout the file at lines 96, 255, 1118, 1122, 1158, and 1162. While this doesn't affect functionality, it makes error messages unprofessional and harder to search for in logs.", "file": "common/persistence/sql/execution_util.go", "line": 96}, {"description": "Race condition in ConcurrentRetrier.throttleInternal method. At lines 65-66, the defer statement for Unlock() is placed before the Lock() call. This means if the failureCount check at line 64 passes but the second check at line 67 fails, the Unlock() will be called without a corresponding Lock(), potentially causing a panic. The defer should be placed after the Lock() call.", "file": "common/backoff/retry.go", "line": 65}, {"description": "Inconsistent locking in RateLimiterImpl. The Rate() and Burst() methods use write locks (Lock/Unlock) at lines 108-110 and 115-117, but they are only reading values, not modifying them. They should use read locks (RLock/RUnlock) instead. This can cause unnecessary blocking when multiple goroutines try to read the rate or burst values concurrently.", "file": "common/quotas/rate_limiter_impl.go", "line": 108}, {"description": "Potential nil pointer dereference in writeFile function. At line 90, the defer function calls f.Close() without checking if f is nil. If os.Create() at line 88 fails and returns an error, f will be nil, but the defer function will still execute when the function returns, causing a panic when trying to call Close() on a nil pointer.", "file": "common/archiver/filestore/util.go", "line": 90}, {"description": "Potential type assertion panic in namespace cache. At lines 213, 241, 498, and 506, the code performs type assertions on values loaded from atomic.Value without checking if the assertion succeeds. If the cache is accessed during initialization or after an error state, these type assertions could panic. For example, at line 213: c.cacheByID.Load().(cache.Cache) - if Load() returns nil or a different type, this will panic.", "file": "common/namespace/cache.go", "line": 213}, {"description": "Potential nil pointer dereference in DaysFromDuration and DaysInt32FromDuration functions. At lines 56 and 60, the functions call duration.Hours() without checking if the duration parameter is nil. If a nil pointer is passed to these functions, they will panic when trying to dereference it.", "file": "common/primitives/timestamp/duration.go.go", "line": 56}, {"description": "Potential nil pointer dereference in putInternal method. At line 299, the code accesses c.byAccess.Back().Value without checking if Back() returns nil. If the cache is empty (which shouldn't happen given the len check, but could occur due to race conditions or other edge cases), this would cause a panic. The same issue exists at line 304 where c.byAccess.Front() is accessed without nil checking.", "file": "common/cache/lru.go", "line": 299}, {"description": "Potential nil pointer dereference in iterator. At line 222, the code iterates over cmap.shards[i].items without checking if items is nil. While lazyInitShard is called in write operations, the iterator only acquires read locks and doesn't initialize the shard. If a shard has never been written to, its items map will be nil, causing a panic when range is called on it.", "file": "common/collection/concurrent_tx_map.go", "line": 222}, {"description": "Incorrect error message in UnlockLow method. At line 133, the panic message says 'unable to unlock high priority' but it should say 'unable to unlock low priority' since this is the UnlockLow method. This could cause confusion during debugging.", "file": "common/locks/priority_mutex_impl.go", "line": 133}, {"description": "Multiple typos in error messages: 'Erorr' should be 'Error'. This appears in several error messages throughout the file at lines 96, 255, 1118, 1122, 1158, and 1162. While this doesn't affect functionality, it makes error messages unprofessional and harder to search for in logs.", "file": "common/persistence/sql/execution_util.go", "line": 96}, {"description": "Race condition in ConcurrentRetrier.throttleInternal method. At lines 65-66, the defer statement for Unlock() is placed before the Lock() call. This means if the failureCount check at line 64 passes but the second check at line 67 fails, the Unlock() will be called without a corresponding Lock(), potentially causing a panic. The defer should be placed after the Lock() call.", "file": "common/backoff/retry.go", "line": 65}, {"description": "Inconsistent locking in RateLimiterImpl. The Rate() and Burst() methods use write locks (Lock/Unlock) at lines 108-110 and 115-117, but they are only reading values, not modifying them. They should use read locks (RLock/RUnlock) instead. This can cause unnecessary blocking when multiple goroutines try to read the rate or burst values concurrently.", "file": "common/quotas/rate_limiter_impl.go", "line": 108}, {"description": "Potential nil pointer dereference in writeFile function. At line 90, the defer function calls f.Close() without checking if f is nil. If os.Create() at line 88 fails and returns an error, f will be nil, but the defer function will still execute when the function returns, causing a panic when trying to call Close() on a nil pointer.", "file": "common/archiver/filestore/util.go", "line": 90}, {"description": "Potential type assertion panic in namespace cache. At lines 213, 241, 498, and 506, the code performs type assertions on values loaded from atomic.Value without checking if the assertion succeeds. If the cache is accessed during initialization or after an error state, these type assertions could panic. For example, at line 213: c.cacheByID.Load().(cache.Cache) - if Load() returns nil or a different type, this will panic.", "file": "common/namespace/cache.go", "line": 213}, {"description": "Potential nil pointer dereference in DaysFromDuration and DaysInt32FromDuration functions. At lines 56 and 60, the functions call duration.Hours() without checking if the duration parameter is nil. If a nil pointer is passed to these functions, they will panic when trying to dereference it.", "file": "common/primitives/timestamp/duration.go.go", "line": 56}, {"description": "Potential panic due to unsafe type assertion. In extractShardOwnershipLostError function, line 174 performs a direct type assertion `record[\"range_id\"].(int64)` without checking if the value exists or is of the correct type. If the value is nil or not an int64, this will cause a panic. Similar issue exists in other functions that perform direct type assertions without safety checks.", "file": "./common/persistence/cassandra/errors.go", "line": 174}, {"description": "Multiple unsafe type assertions that can cause panics. Lines 1023-1071 perform direct type assertions without checking if the values exist or are of the correct type. For example, `result[\"activity_map\"].(map[int64][]byte)` will panic if the value is nil or not the expected type. This pattern is repeated throughout the function for various map fields.", "file": "./common/persistence/cassandra/cassandraPersistence.go", "line": 1023}, {"description": "Inconsistent error handling pattern. Line 1075 performs an unsafe type assertion `dbRecordVersion.(int64)` after checking if the key exists, but doesn't verify the type. If the value exists but is not an int64, this will panic. The code should use the comma ok idiom: `dbVersion, ok := dbRecordVersion.(int64)`", "file": "./common/persistence/cassandra/cassandraPersistence.go", "line": 1075}, {"description": "Potential race condition in Close() method. The Factory struct has an RWMutex but the Close() method only uses Lock() instead of properly coordinating with readers. If other goroutines are calling methods like NewTaskStore(), NewShardStore(), etc. concurrently with Close(), they could access the session after it's been closed, leading to undefined behavior. The factory methods should use RLock() to protect against concurrent Close() calls.", "file": "./common/persistence/cassandra/factory.go", "line": 111}, {"description": "Panic instead of error handling in NewDataBlob function. Line 43 uses panic() when an invalid encoding type is provided, which can crash the entire application. This should return an error instead of panicking, allowing callers to handle the invalid encoding gracefully. Panics should be reserved for truly unrecoverable situations, not input validation failures.", "file": "./common/persistence/data_blob.go", "line": 43}, {"description": "Potential nil pointer dereference in size calculation functions. Functions like sizeOfBlob (line 34), sizeOfInt64BlobMap (line 60), sizeOfStringBlobMap (line 71), and sizeOfBlobSlice (line 91) call methods on blob pointers without checking if they are nil. If any of the DataBlob pointers in the maps or slices are nil, calling blob.Size() will cause a panic.", "file": "./common/persistence/size_util.go", "line": 34}, {"description": "Logic error in ValidateCreateWorkflowStateStatus function. Line 70 uses OR logic instead of AND logic for validation. The condition `state == enumsspb.WORKFLOW_EXECUTION_STATE_COMPLETED || status != enumspb.WORKFLOW_EXECUTION_STATUS_RUNNING` will incorrectly reject valid workflows that are in CREATED state with RUNNING status. The logic should be `state == enumsspb.WORKFLOW_EXECUTION_STATE_COMPLETED && status != enumspb.WORKFLOW_EXECUTION_STATUS_RUNNING` to properly validate that completed workflows don't have running status.", "file": "./common/persistence/workflowStateStatusValidator.go", "line": 70}], "updated_files": {}}