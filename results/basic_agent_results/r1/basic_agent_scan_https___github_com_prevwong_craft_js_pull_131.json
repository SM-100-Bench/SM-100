{"repo_id": "prevwong_craft.js_131", "bugs": [{"description": "Potential prototype pollution vulnerability in deserializeNode due to unsafe JSON.parse usage", "file": "packages/core/src/utils/deserializeNode.tsx", "line": 0}, {"description": "Potential prototype pollution vulnerability exists at JSON parsing site (not in viewed files) - serialized data input should be sanitized before deserialization", "file": "packages/core/src/utils/deserializeNode.tsx", "line": 71}, {"description": "Potential prototype pollution vulnerability in deserializeNode due to unsafe JSON.parse usage", "file": "packages/core/src/utils/deserializeNode.tsx", "line": 0}, {"description": "Potential prototype pollution vulnerability exists at JSON parsing site (not in viewed files) - serialized data input should be sanitized before deserialization", "file": "packages/core/src/utils/deserializeNode.tsx", "line": 71}, {"description": "Potential unhandled null reference when accessing DOM element properties without existence check in getDOMInfo.ts", "file": "packages/utils/src/getDOMInfo.ts", "line": 10}, {"description": "Missing input validation in fromEntries.ts could allow non-array entries to propagate", "file": "packages/core/src/utils/fromEntries.ts", "line": 5}, {"description": "Missing null check in mergeTrees.tsx when merging node children could cause TypeError", "file": "packages/core/src/utils/mergeTrees.tsx", "line": 23}, {"description": "Unsafe object cloning in deserializeNode.tsx using JSON.parse/stringify could lose prototype methods/React refs", "file": "packages/core/src/utils/deserializeNode.tsx", "line": 8}, {"description": "Missing component existence check in resolveComponent.ts could return undefined and cause runtime errors when unresolved components are used", "file": "packages/core/src/utils/resolveComponent.ts", "line": 7}, {"description": "Missing input validation in useMethods.ts for method implementations could allow invalid method signatures to propagate", "file": "packages/utils/src/useMethods.ts", "line": 12}, {"description": "History state mutations in History.ts may not handle immutability correctly - pushed states could share object references leading to unintended mutations", "file": "packages/utils/src/History.ts", "line": 15}, {"description": "Unhandled non-element children in mapChildrenToNodes.ts leads to runtime errors when accessing element properties on primitive types", "file": "packages/core/src/utils/mapChildrenToNodes.ts", "line": 8}], "updated_files": {"/var/folders/00/2s87djc11y75kyy8jdhmzlwr0000gn/T/tmp8hf27vrj/packages/core/src/utils/deserializeNode.tsx": "import React from 'react';\nimport {\n  NodeData,\n  SerializedNode,\n  ReducedComp,\n  ReduceCompType,\n} from '../interfaces';\nimport { Canvas } from '../nodes/Canvas';\nimport { Resolver } from '../interfaces';\nimport { resolveComponent } from './resolveComponent';\n\ntype DeserialisedType = JSX.Element & { name: string };\n\nconst restoreType = (type: ReduceCompType, resolver: Resolver) =>\n  typeof type === 'object' && type.resolvedName\n    ? type.resolvedName === 'Canvas'\n      ? Canvas\n      : resolver[type.resolvedName]\n    : typeof type === 'string'\n    ? type\n    : null;\n\nexport const deserializeComp = (\n  data: ReducedComp,\n  resolver: Resolver,\n  index?: number\n): DeserialisedType | void => {\n  let { type, props } = data;\n  const main = restoreType(type, resolver);\n\n  if (!main) {\n    return;\n  }\n\n  props = Object.keys(props).reduce((result: Record<string, any>, key) => {\n    if (key === '__proto__' || key === 'constructor') return result;\n    const prop = props[key];\n    if (typeof prop === 'object' && prop.resolvedName) {\n      result[key] = deserializeComp(prop, resolver);\n    } else if (key === 'children' && Array.isArray(prop)) {\n      result[key] = prop.map((child) => {\n        if (typeof child === 'string') {\n          return child;\n        }\n        return deserializeComp(child, resolver);\n      });\n    } else {\n      result[key] = prop;\n    }\n    return result;\n  }, {});\n\n  if (index) {\n    props.key = index;\n  }\n\n  const jsx = {\n    ...React.createElement(main, {\n      ...props,\n    }),\n  };\n\n  return {\n    ...jsx,\n    name: resolveComponent(resolver, jsx.type),\n  };\n};\n\nexport const deserializeNode = (\n  data: SerializedNode,\n  resolver: Resolver\n): Omit<NodeData, 'event'> => {\n  const { type: Comp, props: Props, ...nodeData } = data;\n\n  const { type, name, props } = (deserializeComp(\n    data,\n    resolver\n  ) as unknown) as NodeData;\n\n  const { parent, custom, displayName, isCanvas, nodes, hidden } = nodeData;\n\n  const linkedNodes = nodeData.linkedNodes || nodeData._childCanvas;\n\n  return {\n    type,\n    name,\n    displayName: displayName || name,\n    props,\n    custom: custom || {},\n    isCanvas: !!isCanvas,\n    hidden: !!hidden,\n    parent,\n    linkedNodes: linkedNodes || {},\n    nodes: nodes || [],\n  };\n};\n"}}