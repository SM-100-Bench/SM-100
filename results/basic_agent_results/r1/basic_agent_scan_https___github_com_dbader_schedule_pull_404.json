{"repo_id": "dbader_schedule_404", "bugs": [{"description": "Jobs scheduled with `at()` do not respect the specified time when calculating `next_run`. The current implementation adds the interval to the current datetime, causing the job to drift instead of running at the exact specified time each interval.", "file": "schedule/__init__.py", "line": 506}, {"description": "The fix introduces a call to undefined method '_get_next_at_time()', which would cause AttributeError at runtime. This method needs to be implemented to properly handle at_time scheduling.", "file": "schedule/__init__.py", "line": 507}], "updated_files": {"/var/folders/hp/rv5nbb3140l0404lfjq_pq140000gn/T/tmpvf525f6_/schedule/__init__.py": "\"\"\"\nPython job scheduling for humans.\n\ngithub.com/dbader/schedule\n\nAn in-process scheduler for periodic jobs that uses the builder pattern\nfor configuration. Schedule lets you run Python functions (or any other\ncallable) periodically at pre-determined intervals using a simple,\nhuman-friendly syntax.\n\nInspired by Addam Wiggins' article \"Rethinking Cron\" [1] and the\n\"clockwork\" Ruby module [2][3].\n\nFeatures:\n    - A simple to use API for scheduling jobs.\n    - Very lightweight and no external dependencies.\n    - Excellent test coverage.\n    - Tested on Python 2.7, 3.5 and 3.6\n\nUsage:\n    >>> import schedule\n    >>> import time\n\n    >>> def job(message='stuff'):\n    >>>     print(\"I'm working on:\", message)\n\n    >>> schedule.every(10).minutes.do(job)\n    >>> schedule.every(5).to(10).days.do(job)\n    >>> schedule.every().hour.do(job, message='things')\n    >>> schedule.every().day.at(\"10:30\").do(job)\n\n    >>> while True:\n    >>>     schedule.run_pending()\n    >>>     time.sleep(1)\n\n[1] https://adam.herokuapp.com/past/2010/4/13/rethinking_cron/\n[2] https://github.com/Rykian/clockwork\n[3] https://adam.herokuapp.com/past/2010/6/30/replace_cron_with_clockwork/\n\"\"\"\ntry:\n    from collections.abc import Hashable\nexcept ImportError:\n    from collections import Hashable\nimport datetime\nimport functools\nimport logging\nimport random\nimport re\nimport time\n\nlogger = logging.getLogger('schedule')\n\n\nclass ScheduleError(Exception):\n    \"\"\"Base schedule exception\"\"\"\n    pass\n\n\nclass ScheduleValueError(ScheduleError):\n    \"\"\"Base schedule value error\"\"\"\n    pass\n\n\nclass IntervalError(ScheduleValueError):\n    \"\"\"An improper interval was used\"\"\"\n    pass\n\n\nclass CancelJob(object):\n    \"\"\"\n    Can be returned from a job to unschedule itself.\n    \"\"\"\n    pass\n\n\nclass Scheduler(object):\n    \"\"\"\n    Objects instantiated by the :class:`Scheduler <Scheduler>` are\n    factories to create jobs, keep record of scheduled jobs and\n    handle their execution.\n    \"\"\"\n    def __init__(self):\n        self.jobs = []\n\n    def run_pending(self):\n        \"\"\"\n        Run all jobs that are scheduled to run.\n\n        Please note that it is *intended behavior that run_pending()\n        does not run missed jobs*. For example, if you've registered a job\n        that should run every minute and you only call run_pending()\n        in one hour increments then your job won't be run 60 times in\n        between but only once.\n        \"\"\"\n        runnable_jobs = (job for job in self.jobs if job.should_run)\n        for job in sorted(runnable_jobs):\n            self._run_job(job)\n\n    def run_all(self, delay_seconds=0):\n        \"\"\"\n        Run all jobs regardless if they are scheduled to run or not.\n\n        A delay of `delay` seconds is added between each job. This helps\n        distribute system load generated by the jobs more evenly\n        over time.\n\n        :param delay_seconds: A delay added between every executed job\n        \"\"\"\n        logger.debug('Running *all* %i jobs with %is delay inbetween',\n                     len(self.jobs), delay_seconds)\n        for job in self.jobs[:]:\n            self._run_job(job)\n            time.sleep(delay_seconds)\n\n    def clear(self, tag=None):\n        \"\"\"\n        Deletes scheduled jobs marked with the given tag, or all jobs\n        if tag is omitted.\n\n        :param tag: An identifier used to identify a subset of\n                    jobs to delete\n        \"\"\"\n        if tag is None:\n            del self.jobs[:]\n        else:\n            self.jobs[:] = (job for job in self.jobs if tag not in job.tags)\n\n    def cancel_job(self, job):\n        \"\"\"\n        Delete a scheduled job.\n\n        :param job: The job to be unscheduled\n        \"\"\"\n        try:\n            self.jobs.remove(job)\n        except ValueError:\n            pass\n\n    def every(self, interval=1):\n        \"\"\"\n        Schedule a new periodic job.\n\n        :param interval: A quantity of a certain time unit\n        :return: An unconfigured :class:`Job <Job>`\n        \"\"\"\n        job = Job(interval, self)\n        return job\n\n    def _run_job(self, job):\n        ret = job.run()\n        if isinstance(ret, CancelJob) or ret is CancelJob:\n            self.cancel_job(job)\n\n    @property\n    def next_run(self):\n        \"\"\"\n        Datetime when the next job should run.\n\n        :return: A :class:`~datetime.datetime` object\n                 or None if no jobs scheduled\n        \"\"\"\n        if not self.jobs:\n            return None\n        return min(self.jobs).next_run\n\n    @property\n    def idle_seconds(self):\n        \"\"\"\n        :return: Number of seconds until\n                 :meth:`next_run <Scheduler.next_run>`.\n        \"\"\"\n        return (self.next_run - datetime.datetime.now()).total_seconds()\n\n\nclass Job(object):\n    \"\"\"\n    A periodic job as used by :class:`Scheduler`.\n\n    :param interval: A quantity of a certain time unit\n    :param scheduler: The :class:`Scheduler <Scheduler>` instance that\n                      this job will register itself with once it has\n                      been fully configured in :meth:`Job.do()`.\n\n    Every job runs at a given fixed time interval that is defined by:\n\n    * a :meth:`time unit <Job.second>`\n    * a quantity of `time units` defined by `interval`\n\n    A job is usually created and returned by :meth:`Scheduler.every`\n    method, which also defines its `interval`.\n    \"\"\"\n    def __init__(self, interval, scheduler=None):\n        self.interval = interval  # pause interval * unit between runs\n        self.latest = None  # upper limit to the interval\n        self.job_func = None  # the job job_func to run\n        self.unit = None  # time units, e.g. 'minutes', 'hours', ...\n        self.at_time = None  # optional time at which this job runs\n        self.last_run = None  # datetime of the last run\n        self.next_run = None  # datetime of the next run\n        self.period = None  # timedelta between runs, only valid for\n        self.start_day = None  # Specific day of the week to start on\n        self.tags = set()  # unique set of tags for the job\n        self.scheduler = scheduler  # scheduler to register with\n\n    def __lt__(self, other):\n        \"\"\"\n        PeriodicJobs are sortable based on the scheduled time they\n        run next.\n        \"\"\"\n        return self.next_run < other.next_run\n\n    def __str__(self):\n        return (\n            \"Job(interval={}, \"\n            \"unit={}, \"\n            \"do={}, \"\n            \"args={}, \"\n            \"kwargs={})\"\n        ).format(self.interval,\n                 self.unit,\n                 self.job_func.__name__,\n                 self.job_func.args,\n                 self.job_func.keywords)\n\n    def __repr__(self):\n        def format_time(t):\n            return t.strftime('%Y-%m-%d %H:%M:%S') if t else '[never]'\n\n        def is_repr(j):\n            return not isinstance(j, Job)\n\n        timestats = '(last run: %s, next run: %s)' % (\n                    format_time(self.last_run), format_time(self.next_run))\n\n        if hasattr(self.job_func, '__name__'):\n            job_func_name = self.job_func.__name__\n        else:\n            job_func_name = repr(self.job_func)\n        args = [repr(x) if is_repr(x) else str(x) for x in self.job_func.args]\n        kwargs = ['%s=%s' % (k, repr(v))\n                  for k, v in self.job_func.keywords.items()]\n        call_repr = job_func_name + '(' + ', '.join(args + kwargs) + ')'\n\n        if self.at_time is not None:\n            return 'Every %s %s at %s do %s %s' % (\n                   self.interval,\n                   self.unit[:-1] if self.interval == 1 else self.unit,\n                   self.at_time, call_repr, timestats)\n        else:\n            fmt = (\n                'Every %(interval)s ' +\n                ('to %(latest)s ' if self.latest is not None else '') +\n                '%(unit)s do %(call_repr)s %(timestats)s'\n            )\n\n            return fmt % dict(\n                interval=self.interval,\n                latest=self.latest,\n                unit=(self.unit[:-1] if self.interval == 1 else self.unit),\n                call_repr=call_repr,\n                timestats=timestats\n            )\n\n    @property\n    def second(self):\n        if self.interval != 1:\n            raise IntervalError('Use seconds instead of second')\n        return self.seconds\n\n    @property\n    def seconds(self):\n        self.unit = 'seconds'\n        return self\n\n    @property\n    def minute(self):\n        if self.interval != 1:\n            raise IntervalError('Use minutes instead of minute')\n        return self.minutes\n\n    @property\n    def minutes(self):\n        self.unit = 'minutes'\n        return self\n\n    @property\n    def hour(self):\n        if self.interval != 1:\n            raise IntervalError('Use hours instead of hour')\n        return self.hours\n\n    @property\n    def hours(self):\n        self.unit = 'hours'\n        return self\n\n    @property\n    def day(self):\n        if self.interval != 1:\n            raise IntervalError('Use days instead of day')\n        return self.days\n\n    @property\n    def days(self):\n        self.unit = 'days'\n        return self\n\n    @property\n    def week(self):\n        if self.interval != 1:\n            raise IntervalError('Use weeks instead of week')\n        return self.weeks\n\n    @property\n    def weeks(self):\n        self.unit = 'weeks'\n        return self\n\n    @property\n    def monday(self):\n        if self.interval != 1:\n            raise IntervalError('Use mondays instead of monday')\n        self.start_day = 'monday'\n        return self.weeks\n\n    @property\n    def tuesday(self):\n        if self.interval != 1:\n            raise IntervalError('Use tuesdays instead of tuesday')\n        self.start_day = 'tuesday'\n        return self.weeks\n\n    @property\n    def wednesday(self):\n        if self.interval != 1:\n            raise IntervalError('Use wednesdays instead of wednesday')\n        self.start_day = 'wednesday'\n        return self.weeks\n\n    @property\n    def thursday(self):\n        if self.interval != 1:\n            raise IntervalError('Use thursdays instead of thursday')\n        self.start_day = 'thursday'\n        return self.weeks\n\n    @property\n    def friday(self):\n        if self.interval != 1:\n            raise IntervalError('Use fridays instead of friday')\n        self.start_day = 'friday'\n        return self.weeks\n\n    @property\n    def saturday(self):\n        if self.interval != 1:\n            raise IntervalError('Use saturdays instead of saturday')\n        self.start_day = 'saturday'\n        return self.weeks\n\n    @property\n    def sunday(self):\n        if self.interval != 1:\n            raise IntervalError('Use sundays instead of sunday')\n        self.start_day = 'sunday'\n        return self.weeks\n\n    def tag(self, *tags):\n        \"\"\"\n        Tags the job with one or more unique indentifiers.\n\n        Tags must be hashable. Duplicate tags are discarded.\n\n        :param tags: A unique list of ``Hashable`` tags.\n        :return: The invoked job instance\n        \"\"\"\n        if not all(isinstance(tag, Hashable) for tag in tags):\n            raise TypeError('Tags must be hashable')\n        self.tags.update(tags)\n        return self\n\n    def at(self, time_str):\n        \"\"\"\n        Specify a particular time that the job should be run at.\n\n        :param time_str: A string in one of the following formats: `HH:MM:SS`,\n            `HH:MM`,`:MM`, `:SS`. The format must make sense given how often\n            the job is repeating; for example, a job that repeats every minute\n            should not be given a string in the form `HH:MM:SS`. The difference\n            between `:MM` and `:SS` is inferred from the selected time-unit\n            (e.g. `every().hour.at(':30')` vs. `every().minute.at(':30')`).\n        :return: The invoked job instance\n        \"\"\"\n        if (self.unit not in ('days', 'hours', 'minutes')\n                and not self.start_day):\n            raise ScheduleValueError('Invalid unit')\n        if not isinstance(time_str, str):\n            raise TypeError('at() should be passed a string')\n        if self.unit == 'days' or self.start_day:\n            if not re.match(r'^([0-2]\\d:)?[0-5]\\d:[0-5]\\d$', time_str):\n                raise ScheduleValueError('Invalid time format')\n        if self.unit == 'hours':\n            if not re.match(r'^([0-5]\\d)?:[0-5]\\d$', time_str):\n                raise ScheduleValueError(('Invalid time format for'\n                                          ' an hourly job'))\n        if self.unit == 'minutes':\n            if not re.match(r'^:[0-5]\\d$', time_str):\n                raise ScheduleValueError(('Invalid time format for'\n                                          ' a minutely job'))\n        time_values = time_str.split(':')\n        if len(time_values) == 3:\n            hour, minute, second = time_values\n        elif len(time_values) == 2 and self.unit == 'minutes':\n            hour = 0\n            minute = 0\n            _, second = time_values\n        else:\n            hour, minute = time_values\n            second = 0\n        if self.unit == 'days' or self.start_day:\n            hour = int(hour)\n            if not (0 <= hour <= 23):\n                raise ScheduleValueError('Invalid number of hours')\n        elif self.unit == 'hours':\n            hour = 0\n        elif self.unit == 'minutes':\n            hour = 0\n            minute = 0\n        minute = int(minute)\n        second = int(second)\n        self.at_time = datetime.time(hour, minute, second)\n        return self\n\n    def to(self, latest):\n        \"\"\"\n        Schedule the job to run at an irregular (randomized) interval.\n\n        The job's interval will randomly vary from the value given\n        to  `every` to `latest`. The range defined is inclusive on\n        both ends. For example, `every(A).to(B).seconds` executes\n        the job function every N seconds such that A <= N <= B.\n\n        :param latest: Maximum interval between randomized job runs\n        :return: The invoked job instance\n        \"\"\"\n        self.latest = latest\n        return self\n\n    def do(self, job_func, *args, **kwargs):\n        \"\"\"\n        Specifies the job_func that should be called every time the\n        job runs.\n\n        Any additional arguments are passed on to job_func when\n        the job runs.\n\n        :param job_func: The function to be scheduled\n        :return: The invoked job instance\n        \"\"\"\n        self.job_func = functools.partial(job_func, *args, **kwargs)\n        try:\n            functools.update_wrapper(self.job_func, job_func)\n        except AttributeError:\n            # job_funcs already wrapped by functools.partial won't have\n            # __name__, __module__ or __doc__ and the update_wrapper()\n            # call will fail.\n            pass\n        self._schedule_next_run()\n        self.scheduler.jobs.append(self)\n        return self\n\n    @property\n    def should_run(self):\n        \"\"\"\n        :return: ``True`` if the job should be run now.\n        \"\"\"\n        return datetime.datetime.now() >= self.next_run\n\n    def run(self):\n        \"\"\"\n        Run the job and immediately reschedule it.\n\n        :return: The return value returned by the `job_func`\n        \"\"\"\n        logger.debug('Running job %s', self)\n        ret = self.job_func()\n        self.last_run = datetime.datetime.now()\n        self._schedule_next_run()\n        return ret\n\n\n    def _get_next_at_time(self):\n        \"\"\"Calculate next run time when using at() time specification\"\"\"\n        now = datetime.datetime.now()\n        candidate = datetime.datetime.combine(now.date(), self.at_time)\n\n        if candidate > now:\n            return candidate\n        \n        if self.unit == 'days':\n            return candidate + datetime.timedelta(days=self.interval)\n        elif self.unit == 'weeks':\n            return candidate + datetime.timedelta(weeks=self.interval)\n        else:\n            return candidate + self.period\n\n    def _schedule_next_run(self):\n        \"\"\"\n        Compute the instant when this job should run next.\n        \"\"\"\n        if self.unit not in ('seconds', 'minutes', 'hours', 'days', 'weeks'):\n            raise ScheduleValueError('Invalid unit')\n\n        if self.latest is not None:\n            if not (self.latest >= self.interval):\n                raise ScheduleError('`latest` is greater than `interval`')\n            interval = random.randint(self.interval, self.latest)\n        else:\n            interval = self.interval\n\n        self.period = datetime.timedelta(**{self.unit: interval})\n        if self.at_time is not None:\n            self.next_run = self._get_next_at_time()\n        else:\n            self.next_run = datetime.datetime.now() + self.period\n        if self.start_day is not None:\n            if self.unit != 'weeks':\n                raise ScheduleValueError('`unit` should be \\'weeks\\'')\n            weekdays = (\n                'monday',\n                'tuesday',\n                'wednesday',\n                'thursday',\n                'friday',\n                'saturday',\n                'sunday'\n            )\n            if self.start_day not in weekdays:\n                raise ScheduleValueError('Invalid start day')\n            weekday = weekdays.index(self.start_day)\n            days_ahead = weekday - self.next_run.weekday()\n            if days_ahead <= 0:  # Target day already happened this week\n                days_ahead += 7\n            self.next_run += datetime.timedelta(days_ahead) - self.period\n        if self.at_time is not None:\n            if (self.unit not in ('days', 'hours', 'minutes')\n                    and self.start_day is None):\n                raise ScheduleValueError(('Invalid unit without'\n                                          ' specifying start day'))\n            kwargs = {\n                'second': self.at_time.second,\n                'microsecond': 0\n            }\n            if self.unit == 'days' or self.start_day is not None:\n                kwargs['hour'] = self.at_time.hour\n            if self.unit in ['days', 'hours'] or self.start_day is not None:\n                kwargs['minute'] = self.at_time.minute\n            self.next_run = self.next_run.replace(**kwargs)\n            # If we are running for the first time, make sure we run\n            # at the specified time *today* (or *this hour*) as well\n            if not self.last_run:\n                now = datetime.datetime.now()\n                if (self.unit == 'days' and self.at_time > now.time() and\n                        self.interval == 1):\n                    self.next_run = self.next_run - datetime.timedelta(days=1)\n                elif self.unit == 'hours' \\\n                        and (\n                            self.at_time.minute > now.minute\n                            or (self.at_time.minute == now.minute\n                                and self.at_time.second > now.second)\n                        ):\n                    self.next_run = self.next_run - datetime.timedelta(hours=1)\n                elif self.unit == 'minutes' \\\n                        and self.at_time.second > now.second:\n                    self.next_run = self.next_run - \\\n                                    datetime.timedelta(minutes=1)\n        if self.start_day is not None and self.at_time is not None:\n            # Let's see if we will still make that time we specified today\n            if (self.next_run - datetime.datetime.now()).days >= 7:\n                self.next_run -= self.period\n\n\n# The following methods are shortcuts for not having to\n# create a Scheduler instance:\n\n#: Default :class:`Scheduler <Scheduler>` object\ndefault_scheduler = Scheduler()\n\n#: Default :class:`Jobs <Job>` list\njobs = default_scheduler.jobs  # todo: should this be a copy, e.g. jobs()?\n\n\ndef every(interval=1):\n    \"\"\"Calls :meth:`every <Scheduler.every>` on the\n    :data:`default scheduler instance <default_scheduler>`.\n    \"\"\"\n    return default_scheduler.every(interval)\n\n\ndef run_pending():\n    \"\"\"Calls :meth:`run_pending <Scheduler.run_pending>` on the\n    :data:`default scheduler instance <default_scheduler>`.\n    \"\"\"\n    default_scheduler.run_pending()\n\n\ndef run_all(delay_seconds=0):\n    \"\"\"Calls :meth:`run_all <Scheduler.run_all>` on the\n    :data:`default scheduler instance <default_scheduler>`.\n    \"\"\"\n    default_scheduler.run_all(delay_seconds=delay_seconds)\n\n\ndef clear(tag=None):\n    \"\"\"Calls :meth:`clear <Scheduler.clear>` on the\n    :data:`default scheduler instance <default_scheduler>`.\n    \"\"\"\n    default_scheduler.clear(tag)\n\n\ndef cancel_job(job):\n    \"\"\"Calls :meth:`cancel_job <Scheduler.cancel_job>` on the\n    :data:`default scheduler instance <default_scheduler>`.\n    \"\"\"\n    default_scheduler.cancel_job(job)\n\n\ndef next_run():\n    \"\"\"Calls :meth:`next_run <Scheduler.next_run>` on the\n    :data:`default scheduler instance <default_scheduler>`.\n    \"\"\"\n    return default_scheduler.next_run\n\n\ndef idle_seconds():\n    \"\"\"Calls :meth:`idle_seconds <Scheduler.idle_seconds>` on the\n    :data:`default scheduler instance <default_scheduler>`.\n    \"\"\"\n    return default_scheduler.idle_seconds\n"}}