{"repo_id": "agronholm_apscheduler_898", "bugs": [{"description": "Incorrect mapping of cron day_of_week values to Python's weekday. Cron uses 0 for Sunday, but Python's date.weekday() returns 6 for Sunday. The DayOfWeekField should adjust the value to match cron's expected day of week.", "file": "src/apscheduler/triggers/cron/fields.py", "line": 35}], "updated_files": {"/var/folders/hp/rv5nbb3140l0404lfjq_pq140000gn/T/tmpwr_lljus/src/apscheduler/triggers/cron/fields.py": "\"\"\"\nFields represent CronTrigger options which map to :class:`~datetime.datetime` fields.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nfrom calendar import monthrange\nfrom collections.abc import Mapping\nfrom datetime import datetime\nfrom typing import Any, ClassVar, Sequence\n\nfrom .expressions import (\n    WEEKDAYS,\n    AllExpression,\n    LastDayOfMonthExpression,\n    MonthRangeExpression,\n    RangeExpression,\n    WeekdayPositionExpression,\n    WeekdayRangeExpression,\n    get_weekday_index,\n)\n\nMIN_VALUES = {\n    \"year\": 1970,\n    \"month\": 1,\n    \"day\": 1,\n    \"week\": 1,\n    \"day_of_week\": 0,\n    \"hour\": 0,\n    \"minute\": 0,\n    \"second\": 0,\n}\nMAX_VALUES = {\n    \"year\": 9999,\n    \"month\": 12,\n    \"day\": 31,\n    \"week\": 53,\n    \"day_of_week\": 7,\n    \"hour\": 23,\n    \"minute\": 59,\n    \"second\": 59,\n}\nDEFAULT_VALUES: Mapping[str, str | int] = {\n    \"year\": \"*\",\n    \"month\": 1,\n    \"day\": 1,\n    \"week\": \"*\",\n    \"day_of_week\": \"*\",\n    \"hour\": 0,\n    \"minute\": 0,\n    \"second\": 0,\n}\nSEPARATOR = re.compile(\" *, *\")\n\n\nclass BaseField:\n    __slots__ = \"name\", \"expressions\"\n\n    real: ClassVar[bool] = True\n    compilers: ClassVar[Any] = (AllExpression, RangeExpression)\n\n    def __init_subclass__(cls, real: bool = True, extra_compilers: Sequence = ()):\n        cls.real = real\n        if extra_compilers:\n            cls.compilers += extra_compilers\n\n    def __init__(self, name: str, exprs: int | str):\n        self.name = name\n        self.expressions: list = []\n        for expr in SEPARATOR.split(str(exprs).strip()):\n            self.append_expression(expr)\n\n    def get_min(self, dateval: datetime) -> int:\n        return MIN_VALUES[self.name]\n\n    def get_max(self, dateval: datetime) -> int:\n        return MAX_VALUES[self.name]\n\n    def get_value(self, dateval: datetime) -> int:\n        return getattr(dateval, self.name)\n\n    def get_next_value(self, dateval: datetime) -> int | None:\n        smallest = None\n        for expr in self.expressions:\n            value = expr.get_next_value(dateval, self)\n            if smallest is None or (value is not None and value < smallest):\n                smallest = value\n\n        return smallest\n\n    def append_expression(self, expr: str) -> None:\n        for compiler in self.compilers:\n            match = compiler.value_re.match(expr)\n            if match:\n                compiled_expr = compiler(**match.groupdict())\n\n                try:\n                    compiled_expr.validate_range(\n                        self.name, MIN_VALUES[self.name], MAX_VALUES[self.name]\n                    )\n                except ValueError as exc:\n                    raise ValueError(\n                        f\"Error validating expression {expr!r}: {exc}\"\n                    ) from exc\n\n                self.expressions.append(compiled_expr)\n                return\n\n        raise ValueError(f\"Unrecognized expression {expr!r} for field {self.name!r}\")\n\n    def __str__(self) -> str:\n        expr_strings = (str(e) for e in self.expressions)\n        return \",\".join(expr_strings)\n\n\nclass WeekField(BaseField, real=False):\n    __slots__ = ()\n\n    def get_value(self, dateval: datetime) -> int:\n        return dateval.isocalendar()[1]\n\n\nclass DayOfMonthField(\n    BaseField, extra_compilers=(WeekdayPositionExpression, LastDayOfMonthExpression)\n):\n    __slots__ = ()\n\n    def get_max(self, dateval: datetime) -> int:\n        return monthrange(dateval.year, dateval.month)[1]\n\n\nclass DayOfWeekField(BaseField, real=False, extra_compilers=(WeekdayRangeExpression,)):\n    __slots__ = ()\n\n    def get_value(self, dateval: datetime) -> int:\n        return (dateval.weekday() + 1) % 7  # Convert Python weekday (0=Mon) to cron (0=Sun)\n\n    def append_expression(self, expr: str) -> None:\n        # Convert numeric weekday expressions into textual ones\n        match = RangeExpression.value_re.match(expr)\n        if match:\n            groups = match.groups()\n            first = int(groups[0]) - 1\n            first = 6 if first < 0 else first\n            if groups[1]:\n                last = int(groups[1]) - 1\n                last = 6 if last < 0 else last\n            else:\n                last = first\n\n            expr = f\"{WEEKDAYS[first]}-{WEEKDAYS[last]}\"\n\n        # For expressions like Sun-Tue or Sat-Mon, add two expressions that together\n        # cover the expected weekdays\n        match = WeekdayRangeExpression.value_re.match(expr)\n        if match and match.groups()[1]:\n            groups = match.groups()\n            first_index = get_weekday_index(groups[0])\n            last_index = get_weekday_index(groups[1])\n            if first_index > last_index:\n                super().append_expression(f\"{WEEKDAYS[0]}-{groups[1]}\")\n                super().append_expression(f\"{groups[0]}-{WEEKDAYS[-1]}\")\n                return\n\n        super().append_expression(expr)\n\n    def get_value(self, dateval: datetime) -> int:\n        return dateval.weekday()\n\n\nclass MonthField(BaseField, extra_compilers=(MonthRangeExpression,)):\n    __slots__ = ()\n"}}