{"repo_id": "pylint-dev_pylint_10300", "bugs": [{"description": "Potential AttributeError when accessing 'doc_node.value' without null check. When a node lacks docstring (doc_node=None), accessing 'doc_node.value' in _check_docstring method would raise AttributeError.", "file": "pylint/checkers/base/docstring_checker.py", "line": 108}, {"description": "Potential AttributeError when accessing 'doc_node.value' without null check. When a node lacks docstring (doc_node=None), accessing 'doc_node.value' in _check_docstring method would raise AttributeError.", "file": "pylint/checkers/base/docstring_checker.py", "line": 108}], "updated_files": {"/var/folders/hp/rv5nbb3140l0404lfjq_pq140000gn/T/tmpxfvftof5/pylint/checkers/base/docstring_checker.py": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Docstring checker from the basic checker.\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nfrom typing import Literal\n\nimport astroid\nfrom astroid import nodes\n\nfrom pylint import interfaces\nfrom pylint.checkers import utils\nfrom pylint.checkers.base.basic_checker import _BasicChecker\nfrom pylint.checkers.utils import (\n    is_overload_stub,\n    is_property_deleter,\n    is_property_setter,\n)\n\n# do not require a doc string on private/system methods\nNO_REQUIRED_DOC_RGX = re.compile(\"^_\")\n\n\ndef _infer_dunder_doc_attribute(\n    node: nodes.Module | nodes.ClassDef | nodes.FunctionDef,\n) -> str | None:\n    # Try to see if we have a `__doc__` attribute.\n    try:\n        docstring = node[\"__doc__\"]\n    except KeyError:\n        return None\n\n    docstring = utils.safe_infer(docstring)\n    if not docstring:\n        return None\n    if not isinstance(docstring, nodes.Const):\n        return None\n    return str(docstring.value)\n\n\nclass DocStringChecker(_BasicChecker):\n    msgs = {\n        \"C0112\": (\n            \"Empty %s docstring\",\n            \"empty-docstring\",\n            \"Used when a module, function, class or method has an empty \"\n            \"docstring (it would be too easy ;).\",\n            {\"old_names\": [(\"W0132\", \"old-empty-docstring\")]},\n        ),\n        \"C0114\": (\n            \"Missing module docstring\",\n            \"missing-module-docstring\",\n            \"Used when a module has no docstring. \"\n            \"Empty modules do not require a docstring.\",\n            {\"old_names\": [(\"C0111\", \"missing-docstring\")]},\n        ),\n        \"C0115\": (\n            \"Missing class docstring\",\n            \"missing-class-docstring\",\n            \"Used when a class has no docstring. \"\n            \"Even an empty class must have a docstring.\",\n            {\"old_names\": [(\"C0111\", \"missing-docstring\")]},\n        ),\n        \"C0116\": (\n            \"Missing function or method docstring\",\n            \"missing-function-docstring\",\n            \"Used when a function or method has no docstring. \"\n            \"Some special methods like __init__ do not require a \"\n            \"docstring.\",\n            {\"old_names\": [(\"C0111\", \"missing-docstring\")]},\n        ),\n    }\n    options = (\n        (\n            \"no-docstring-rgx\",\n            {\n                \"default\": NO_REQUIRED_DOC_RGX,\n                \"type\": \"regexp\",\n                \"metavar\": \"<regexp>\",\n                \"help\": \"Regular expression which should only match \"\n                \"function or class names that do not require a \"\n                \"docstring.\",\n            },\n        ),\n        (\n            \"docstring-min-length\",\n            {\n                \"default\": -1,\n                \"type\": \"int\",\n                \"metavar\": \"<int>\",\n                \"help\": (\n                    \"Minimum line length for functions/classes that\"\n                    \" require docstrings, shorter ones are exempt.\"\n                ),\n            },\n        ),\n    )\n\n    def open(self) -> None:\n        self.linter.stats.reset_undocumented()\n\n    @utils.only_required_for_messages(\"missing-module-docstring\", \"empty-docstring\")\n    def visit_module(self, node: nodes.Module) -> None:\n        if node.doc_node:\n            self._check_docstring(\"module\", node)\n\n    @utils.only_required_for_messages(\"missing-class-docstring\", \"empty-docstring\")\n    def visit_classdef(self, node: nodes.ClassDef) -> None:\n        if self.linter.config.no_docstring_rgx.match(node.name) is None:\n            self._check_docstring(\"class\", node)\n\n    @utils.only_required_for_messages(\"missing-function-docstring\", \"empty-docstring\")\n    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        if self.linter.config.no_docstring_rgx.match(node.name) is None:\n            ftype = \"method\" if node.is_method() else \"function\"\n            if (\n                is_property_setter(node)\n                or is_property_deleter(node)\n                or is_overload_stub(node)\n            ):\n                return\n\n            if isinstance(node.parent.frame(), nodes.ClassDef):\n                overridden = False\n                confidence = (\n                    interfaces.INFERENCE\n                    if utils.has_known_bases(node.parent.frame())\n                    else interfaces.INFERENCE_FAILURE\n                )\n                # check if node is from a method overridden by its ancestor\n                for ancestor in node.parent.frame().ancestors():\n                    if ancestor.qname() == \"builtins.object\":\n                        continue\n                    if node.name in ancestor and isinstance(\n                        ancestor[node.name], nodes.FunctionDef\n                    ):\n                        overridden = True\n                        break\n                self._check_docstring(\n                    ftype, node, report_missing=not overridden, confidence=confidence  # type: ignore[arg-type]\n                )\n            elif isinstance(node.parent.frame(), nodes.Module):\n                self._check_docstring(ftype, node)  # type: ignore[arg-type]\n            else:\n                return\n\n    visit_asyncfunctiondef = visit_functiondef\n\n    def _check_docstring(\n        self,\n        node_type: Literal[\"class\", \"function\", \"method\", \"module\"],\n        node: nodes.Module | nodes.ClassDef | nodes.FunctionDef,\n        report_missing: bool = True,\n        confidence: interfaces.Confidence = interfaces.HIGH,\n    ) -> None:\n        \"\"\"Check if the node has a non-empty docstring.\"\"\"\n        docstring = node.doc_node.value if node.doc_node else None\n        if docstring is None:\n            docstring = _infer_dunder_doc_attribute(node)\n\n        if docstring is None:\n            if not report_missing:\n                return\n            lines = utils.get_node_last_lineno(node) - node.lineno\n\n            if node_type == \"module\" and not lines:\n                # If the module does not have a body, there's no reason\n                # to require a docstring.\n                return\n            max_lines = self.linter.config.docstring_min_length\n\n            if node_type != \"module\" and max_lines > -1 and lines < max_lines:\n                return\n            if node_type == \"class\":\n                self.linter.stats.undocumented[\"klass\"] += 1\n            else:\n                self.linter.stats.undocumented[node_type] += 1\n            if (\n                node.body\n                and isinstance(node.body[0], nodes.Expr)\n                and isinstance(node.body[0].value, nodes.Call)\n            ):\n                # Most likely a string with a format call. Let's see.\n                func = utils.safe_infer(node.body[0].value.func)\n                if isinstance(func, astroid.BoundMethod) and isinstance(\n                    func.bound, astroid.Instance\n                ):\n                    # Strings.\n                    if func.bound.name in {\"str\", \"unicode\", \"bytes\"}:\n                        return\n            if node_type == \"module\":\n                message = \"missing-module-docstring\"\n            elif node_type == \"class\":\n                message = \"missing-class-docstring\"\n            else:\n                message = \"missing-function-docstring\"\n            self.add_message(message, node=node, confidence=confidence)\n        elif not docstring.strip():\n            if node_type == \"class\":\n                self.linter.stats.undocumented[\"klass\"] += 1\n            else:\n                self.linter.stats.undocumented[node_type] += 1\n            self.add_message(\n                \"empty-docstring\", node=node, args=(node_type,), confidence=confidence\n            )\n"}}