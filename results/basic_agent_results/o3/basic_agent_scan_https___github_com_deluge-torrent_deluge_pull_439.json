{"repo_id": "deluge-torrent_deluge_439", "bugs": [{"description": "Auth._create_session passes a str to twisted.web.http.Request.addCookie as the cookie value (`session_id + checksum`). Twisted's addCookie expects the cookie key and value to be `bytes`, but `session_id + checksum` is a Python `str`. This type mismatch will raise a `TypeError` at runtime, preventing users from logging in via the Web UI.", "file": "deluge/ui/web/auth.py", "line": 102}, {"description": "JSON_API uses request.getHeader with a bytes argument: request.getHeader(b'content-type'). Twisted's Request.getHeader expects a str header name, so passing bytes will raise a TypeError, breaking JSON requests. The argument should be a str 'content-type'.", "file": "deluge/ui/web/json_api.py", "line": 194}], "updated_files": {"/var/folders/hp/rv5nbb3140l0404lfjq_pq140000gn/T/tmpvr_0mcq8/deluge/ui/web/auth.py": "#\n# Copyright (C) 2009 Damien Churchill <damoxc@gmail.com>\n#\n# This file is part of Deluge and is licensed under GNU General Public License 3.0, or later, with\n# the additional special exception to link portions of this program with the OpenSSL library.\n# See LICENSE for more details.\n#\n\nimport hashlib\nimport logging\nimport os\nimport time\nfrom datetime import datetime, timedelta\nfrom email.utils import formatdate\n\nfrom twisted.internet.task import LoopingCall\n\nfrom deluge.common import AUTH_LEVEL_ADMIN, AUTH_LEVEL_NONE\nfrom deluge.error import NotAuthorizedError\nfrom deluge.ui.web.json_api import JSONComponent, export\n\nlog = logging.getLogger(__name__)\n\n\ndef make_checksum(session_id):\n    checksum = 0\n    for value in [ord(char) for char in session_id]:\n        checksum += value\n    return checksum\n\n\ndef get_session_id(session_id):\n    \"\"\"\n    Checks a session id against its checksum\n    \"\"\"\n    if not session_id:\n        return None\n\n    try:\n        checksum = int(session_id[-4:])\n        session_id = session_id[:-4]\n\n        if checksum == make_checksum(session_id):\n            return session_id\n        return None\n    except Exception as ex:\n        log.exception(ex)\n        return None\n\n\ndef make_expires(timeout):\n    dt = timedelta(seconds=timeout)\n    expires = time.mktime((datetime.now() + dt).timetuple())\n    expires_str = formatdate(timeval=expires, localtime=False, usegmt=True)\n    return expires, expires_str\n\n\nclass Auth(JSONComponent):\n    \"\"\"\n    The component that implements authentication into the JSON interface.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__('Auth')\n        self.worker = LoopingCall(self._clean_sessions)\n        self.config = config\n\n    def start(self):\n        self.worker.start(5)\n\n    def stop(self):\n        self.worker.stop()\n\n    def _clean_sessions(self):\n        now = time.gmtime()\n        for session_id in list(self.config['sessions']):\n            session = self.config['sessions'][session_id]\n\n            if 'expires' not in session:\n                del self.config['sessions'][session_id]\n                continue\n\n            if time.gmtime(session['expires']) < now:\n                del self.config['sessions'][session_id]\n                continue\n\n    def _create_session(self, request, login='admin'):\n        \"\"\"\n        Creates a new session.\n\n        :param login: the username of the user logging in, currently \\\n        only for future use currently.\n        :type login: string\n        \"\"\"\n        m = hashlib.sha256()\n        m.update(os.urandom(32))\n        session_id = m.hexdigest()\n\n        expires, expires_str = make_expires(self.config['session_timeout'])\n        checksum = str(make_checksum(session_id))\n\n        request.addCookie(\n            b'_session_id',\n            (session_id + checksum).encode(),\n            path=request.base + b'json',\n            expires=expires_str,\n        )\n\n        log.debug('Creating session for %s', login)\n\n        if isinstance(self.config['sessions'], list):\n            self.config['sessions'] = {}\n\n        self.config['sessions'][session_id] = {\n            'login': login,\n            'level': AUTH_LEVEL_ADMIN,\n            'expires': expires,\n        }\n        return True\n\n    def check_password(self, password):\n        config = self.config\n        if 'pwd_sha1' not in config.config:\n            log.debug('Failed to find config login details.')\n            return False\n\n        s = hashlib.sha1()\n        s.update(config['pwd_salt'].encode('utf8'))\n        s.update(password.encode('utf8'))\n        return s.hexdigest() == config['pwd_sha1']\n\n    def check_request(self, request, method=None, level=None):\n        \"\"\"\n        Check to ensure that a request is authorised to call the specified\n        method of authentication level.\n\n        :param request: The HTTP request in question\n        :type request: twisted.web.http.Request\n        :param method: Check the specified method\n        :type method: function\n        :param level: Check the specified auth level\n        :type level: integer\n\n        :raises: Exception\n        \"\"\"\n        cookie_sess_id = request.getCookie(b'_session_id')\n        if cookie_sess_id:\n            session_id = get_session_id(cookie_sess_id.decode())\n        else:\n            session_id = None\n\n        if session_id not in self.config['sessions']:\n            auth_level = AUTH_LEVEL_NONE\n            session_id = None\n        else:\n            session = self.config['sessions'][session_id]\n            auth_level = session['level']\n            expires, expires_str = make_expires(self.config['session_timeout'])\n            session['expires'] = expires\n\n            _session_id = request.getCookie(b'_session_id')\n            request.addCookie(\n                b'_session_id',\n                _session_id,\n                path=request.base + b'json',\n                expires=expires_str.encode('utf8'),\n            )\n\n        if method:\n            if not hasattr(method, '_json_export'):\n                raise Exception('Not an exported method')\n\n            method_level = getattr(method, '_json_auth_level')\n            if method_level is None:\n                raise Exception('Method has no auth level')\n\n            level = method_level\n\n        if level is None:\n            raise Exception('No level specified to check against')\n\n        request.auth_level = auth_level\n        request.session_id = session_id\n\n        if auth_level < level:\n            raise NotAuthorizedError(auth_level, level)\n\n    def _change_password(self, new_password):\n        \"\"\"\n        Change the password. This is to allow the UI to change/reset a\n        password.\n\n        :param new_password: the password to change to\n        :type new_password: string\n        \"\"\"\n        log.debug('Changing password')\n        salt = hashlib.sha1(os.urandom(32)).hexdigest()\n        s = hashlib.sha1(salt.encode('utf-8'))\n        s.update(new_password.encode('utf8'))\n        self.config['pwd_salt'] = salt\n        self.config['pwd_sha1'] = s.hexdigest()\n        return True\n\n    @export\n    def change_password(self, old_password, new_password):\n        \"\"\"\n        Change the password.\n\n        :param old_password: the current password\n        :type old_password: string\n        :param new_password: the password to change to\n        :type new_password: string\n        \"\"\"\n        if not self.check_password(old_password):\n            return False\n        return self._change_password(new_password)\n\n    @export(AUTH_LEVEL_NONE)\n    def check_session(self, session_id=None):\n        \"\"\"\n        Check a session to see if it's still valid.\n\n        :returns: True if the session is valid, False if not.\n        :rtype: booleon\n        \"\"\"\n        return __request__.session_id is not None\n\n    @export\n    def delete_session(self):\n        \"\"\"\n        Removes a session.\n\n        :param session_id: the id for the session to remove\n        :type session_id: string\n        \"\"\"\n        del self.config['sessions'][__request__.session_id]\n        return True\n\n    @export(AUTH_LEVEL_NONE)\n    def login(self, password):\n        \"\"\"\n        Test a password to see if it's valid.\n\n        :param password: the password to test\n        :type password: string\n        :returns: a session id or False\n        :rtype: string or False\n        \"\"\"\n        if self.check_password(password):\n            log.info('Login success (ClientIP %s)', __request__.getClientIP())\n            return self._create_session(__request__)\n        else:\n            log.error('Login failed (ClientIP %s)', __request__.getClientIP())\n            return False\n"}}