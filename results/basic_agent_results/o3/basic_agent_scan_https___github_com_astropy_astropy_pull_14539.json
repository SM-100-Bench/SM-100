{"repo_id": "astropy_astropy_14539", "bugs": [{"description": "In Quantize.encode_quantized(), the code only handles dtype.itemsize of 4 and 8 bytes. If the input buffer has any other itemsize, neither of the branches is executed, leaving the variables `qbytes` and `status` undefined. The subsequent check `if status == 0:` will then raise an UnboundLocalError instead of a controlled TypeError. An explicit `else` branch should raise a meaningful exception when an unsupported dtype size is encountered.", "file": "astropy/io/fits/_tiled_compression/quantization.py", "line": 115}, {"description": "The encode_quantized function fails when the input dtype itemsize is not 4 or 8 bytes because variables qbytes and status are not defined. This leads to UnboundLocalError at line 138 when status is referenced. A proper else branch should raise TypeError earlier.", "file": "astropy/io/fits/_tiled_compression/quantization.py", "line": 116}, {"description": "encode_quantized uses `if uarray.dtype.itemsize == 4` and `elif == 8`, but has no `else`. For unsupported sizes, variables qbytes and status stay undefined; subsequent `if status == 0` raises UnboundLocalError. Should add else raising TypeError.", "file": "astropy/io/fits/_tiled_compression/quantization.py", "line": 116}, {"description": "encode_quantized handles only 4- or 8-byte floating point arrays. For any other dtype itemsize, control falls through leaving `qbytes`, `status`, `scale`, and `zero` undefined. The subsequent `if status == 0:` statement therefore raises an UnboundLocalError instead of a clear TypeError. Add an explicit `else:` branch that raises a descriptive exception for unsupported item sizes.", "file": "astropy/io/fits/_tiled_compression/quantization.py", "line": 116}], "updated_files": {"/var/folders/hp/rv5nbb3140l0404lfjq_pq140000gn/T/tmp7v6nmknd/astropy/io/fits/_tiled_compression/quantization.py": "\"\"\"\nThis file contains the code for Quantizing / Dequantizing floats.\n\"\"\"\nimport numpy as np\n\nfrom astropy.io.fits._tiled_compression._compression import (\n    quantize_double_c,\n    quantize_float_c,\n    unquantize_double_c,\n    unquantize_float_c,\n)\nfrom astropy.io.fits.hdu.base import BITPIX2DTYPE\n\n__all__ = [\"Quantize\"]\n\n\nDITHER_METHODS = {\n    \"NONE\": 0,\n    \"NO_DITHER\": -1,\n    \"SUBTRACTIVE_DITHER_1\": 1,\n    \"SUBTRACTIVE_DITHER_2\": 2,\n}\n\n\nclass QuantizationFailedException(Exception):\n    pass\n\n\nclass Quantize:\n    \"\"\"\n    Quantization of floating-point data following the FITS standard.\n    \"\"\"\n\n    def __init__(\n        self, *, row: int, dither_method: int, quantize_level: int, bitpix: int\n    ):\n        super().__init__()\n        self.row = row\n        # TODO: pass dither method as a string instead of int?\n        self.quantize_level = quantize_level\n        self.dither_method = dither_method\n        self.bitpix = bitpix\n\n    # NOTE: below we use decode_quantized and encode_quantized instead of\n    # decode and encode as we need to break with the numcodec API and take/return\n    # scale and zero in addition to quantized value. We should figure out how\n    # to properly use the numcodec API for this use case.\n\n    def decode_quantized(self, buf, scale, zero):\n        \"\"\"\n        Unquantize data.\n\n        Parameters\n        ----------\n        buf : bytes or array_like\n            The buffer to unquantize.\n\n        Returns\n        -------\n        np.ndarray\n            The unquantized buffer.\n        \"\"\"\n        qbytes = np.asarray(buf)\n        qbytes = qbytes.astype(qbytes.dtype.newbyteorder(\"=\"))\n        # TODO: figure out if we need to support null checking\n        if self.dither_method == -1:\n            # For NO_DITHER we should just use the scale and zero directly\n            return qbytes * scale + zero\n        if self.bitpix == -32:\n            ubytes = unquantize_float_c(\n                qbytes.tobytes(),\n                self.row,\n                qbytes.size,\n                scale,\n                zero,\n                self.dither_method,\n                0,\n                0,\n                0.0,\n                qbytes.dtype.itemsize,\n            )\n        elif self.bitpix == -64:\n            ubytes = unquantize_double_c(\n                qbytes.tobytes(),\n                self.row,\n                qbytes.size,\n                scale,\n                zero,\n                self.dither_method,\n                0,\n                0,\n                0.0,\n                qbytes.dtype.itemsize,\n            )\n        else:\n            raise TypeError(\"bitpix should be one of -32 or -64\")\n        return np.frombuffer(ubytes, dtype=BITPIX2DTYPE[self.bitpix]).data\n\n    def encode_quantized(self, buf):\n        \"\"\"\n        Quantize data.\n\n        Parameters\n        ----------\n        buf : bytes or array_like\n            The buffer to quantize.\n\n        Returns\n        -------\n        np.ndarray\n            A buffer with quantized data.\n        \"\"\"\n        uarray = np.asarray(buf)\n        uarray = uarray.astype(uarray.dtype.newbyteorder(\"=\"))\n        # TODO: figure out if we need to support null checking\n        if uarray.dtype.itemsize == 4:\n            qbytes, status, scale, zero = quantize_float_c(\n                uarray.tobytes(),\n                self.row,\n                uarray.size,\n                1,\n                0,\n                0,\n                self.quantize_level,\n                self.dither_method,\n            )[:4]\n        elif uarray.dtype.itemsize == 8:\n            qbytes, status, scale, zero = quantize_double_c(\n                uarray.tobytes(),\n                self.row,\n                uarray.size,\n                1,\n                0,\n                0,\n                self.quantize_level,\n                self.dither_method,\n            )[:4]\n        else:\n            # Unsupported dtype size \u2013 only 4-byte (single precision) and 8-byte (double\n            # precision) floating point types are currently handled.  Raise an explicit\n            # error here instead of falling through and later causing an\n            # UnboundLocalError when ``status`` is referenced.\n            raise TypeError(\n                \"Unsupported dtype itemsize for quantization; expected 4 or 8 bytes, \"\n                f\"got {uarray.dtype.itemsize}\"\n            )\n\n        if status == 0:\n            raise QuantizationFailedException()\n        else:\n            return np.frombuffer(qbytes, dtype=np.int32), scale, zero\n"}}