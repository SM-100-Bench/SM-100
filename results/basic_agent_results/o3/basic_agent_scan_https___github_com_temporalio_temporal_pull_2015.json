{"repo_id": "temporalio_temporal_2015", "bugs": [{"description": "Potential nil-pointer dereference in writeFile(): The deferred function captures variable f before checking if os.Create succeeded. If os.Create returns an error, f will be nil, but the deferred f.Close() will still execute, causing a panic when it tries to call Close() on a nil pointer.", "file": "common/archiver/filestore/util.go", "line": 55}, {"description": "Potential nil-pointer dereference in writeFile(): The deferred function captures variable f before checking if os.Create succeeded. If os.Create returns an error, f will be nil, but the deferred f.Close() will still execute, causing a panic when it tries to call Close() on a nil pointer.", "file": "common/archiver/filestore/util.go", "line": 55}, {"description": "convertHistoryNode() performs direct type assertions on the values extracted from the map returned by gocql Iter without verifying the actual concrete type, e.g., `message[\"node_id\"].(int64)`. Depending on the Cassandra driver / schema, integer columns may be returned as `int`, `int32`, or `int64`. If the concrete type is not exactly `int64`, the type assertion will panic and crash the process, leading to potential availability issues. Safe conversion with a type-switch or using the driver\u2019s scanning helpers should be used instead.", "file": "common/persistence/cassandra/cassandraHistoryPersistence.go", "line": 398}], "updated_files": {"/var/folders/hp/rv5nbb3140l0404lfjq_pq140000gn/T/tmpyzgcq20i/common/archiver/filestore/util.go": "// The MIT License\n//\n// Copyright (c) 2020 Temporal Technologies Inc.  All rights reserved.\n//\n// Copyright (c) 2020 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage filestore\n\nimport (\n        \"context\"\n        \"encoding/json\"\n        \"errors\"\n        \"fmt\"\n        \"io/ioutil\"\n        \"os\"\n        \"strconv\"\n        \"strings\"\n        \"time\"\n\n        \"github.com/dgryski/go-farm\"\n        \"github.com/gogo/protobuf/proto\"\n        historypb \"go.temporal.io/api/history/v1\"\n\n        archiverspb \"go.temporal.io/server/api/archiver/v1\"\n        \"go.temporal.io/server/common/archiver\"\n        \"go.temporal.io/server/common/codec\"\n        \"go.temporal.io/server/common/primitives/timestamp\"\n)\n\nvar (\n        errDirectoryExpected  = errors.New(\"a path to a directory was expected\")\n        errFileExpected       = errors.New(\"a path to a file was expected\")\n        errEmptyDirectoryPath = errors.New(\"directory path is empty\")\n)\n\n// File I/O util\n\nfunc fileExists(filepath string) (bool, error) {\n        if info, err := os.Stat(filepath); err != nil {\n                if os.IsNotExist(err) {\n                        return false, nil\n                }\n                return false, err\n        } else if info.IsDir() {\n                return false, errFileExpected\n        }\n        return true, nil\n}\n\nfunc directoryExists(path string) (bool, error) {\n        if info, err := os.Stat(path); err != nil {\n                if os.IsNotExist(err) {\n                        return false, nil\n                }\n                return false, err\n        } else if !info.IsDir() {\n                return false, errDirectoryExpected\n        }\n        return true, nil\n}\n\nfunc mkdirAll(path string, dirMode os.FileMode) error {\n        return os.MkdirAll(path, dirMode)\n}\n\nfunc writeFile(filepath string, data []byte, fileMode os.FileMode) (retErr error) {\n        if err := os.Remove(filepath); err != nil && !os.IsNotExist(err) {\n                return err\n        }\n        f, err := os.Create(filepath)\n        if err != nil {\n                return err\n        }\n        defer func() {\n                if cerr := f.Close(); cerr != nil && retErr == nil {\n                        retErr = cerr\n                }\n        }()\n        if err = f.Chmod(fileMode); err != nil {\n                return err\n        }\n        if _, err = f.Write(data); err != nil {\n                return err\n        }\n        return nil\n}\n\n// readFile reads the contents of a file specified by filepath\n// WARNING: callers of this method should be extremely careful not to use it in a context where filepath is supplied by\n// the user.\nfunc readFile(filepath string) ([]byte, error) {\n        // #nosec\n        return ioutil.ReadFile(filepath)\n}\n\nfunc listFiles(dirPath string) ([]string, error) {\n        if info, err := os.Stat(dirPath); err != nil {\n                return nil, err\n        } else if !info.IsDir() {\n                return nil, errDirectoryExpected\n        }\n\n        f, err := os.Open(dirPath)\n        if err != nil {\n                return nil, err\n        }\n        fileNames, err := f.Readdirnames(-1)\n        f.Close()\n        if err != nil {\n                return nil, err\n        }\n        return fileNames, nil\n}\n\nfunc listFilesByPrefix(dirPath string, prefix string) ([]string, error) {\n        fileNames, err := listFiles(dirPath)\n        if err != nil {\n                return nil, err\n        }\n\n        var filteredFileNames []string\n        for _, name := range fileNames {\n                if strings.HasPrefix(name, prefix) {\n                        filteredFileNames = append(filteredFileNames, name)\n                }\n        }\n        return filteredFileNames, nil\n}\n\n// encoding & decoding util\n\nfunc encode(message proto.Message) ([]byte, error) {\n        encoder := codec.NewJSONPBEncoder()\n        return encoder.Encode(message)\n}\n\nfunc encodeHistories(histories []*historypb.History) ([]byte, error) {\n        encoder := codec.NewJSONPBEncoder()\n        return encoder.EncodeHistories(histories)\n}\n\nfunc decodeVisibilityRecord(data []byte) (*archiverspb.VisibilityRecord, error) {\n        record := &archiverspb.VisibilityRecord{}\n        encoder := codec.NewJSONPBEncoder()\n        err := encoder.Decode(data, record)\n        if err != nil {\n                return nil, err\n        }\n        return record, nil\n}\n\nfunc serializeToken(token interface{}) ([]byte, error) {\n        if token == nil {\n                return nil, nil\n        }\n        return json.Marshal(token)\n}\n\nfunc deserializeGetHistoryToken(bytes []byte) (*getHistoryToken, error) {\n        token := &getHistoryToken{}\n        err := json.Unmarshal(bytes, token)\n        return token, err\n}\n\nfunc deserializeQueryVisibilityToken(bytes []byte) (*queryVisibilityToken, error) {\n        token := &queryVisibilityToken{}\n        err := json.Unmarshal(bytes, token)\n        return token, err\n}\n\n// File name construction\n\nfunc constructHistoryFilename(namespaceID, workflowID, runID string, version int64) string {\n        combinedHash := constructHistoryFilenamePrefix(namespaceID, workflowID, runID)\n        return fmt.Sprintf(\"%s_%v.history\", combinedHash, version)\n}\n\nfunc constructHistoryFilenamePrefix(namespaceID, workflowID, runID string) string {\n        return strings.Join([]string{hash(namespaceID), hash(workflowID), hash(runID)}, \"\")\n}\n\nfunc constructVisibilityFilename(closeTimestamp *time.Time, runID string) string {\n        return fmt.Sprintf(\"%v_%s.visibility\", timestamp.TimeValue(closeTimestamp).UnixNano(), hash(runID))\n}\n\nfunc hash(s string) string {\n        return fmt.Sprintf(\"%v\", farm.Fingerprint64([]byte(s)))\n}\n\n// Validation\n\nfunc validateDirPath(dirPath string) error {\n        if len(dirPath) == 0 {\n                return errEmptyDirectoryPath\n        }\n        info, err := os.Stat(dirPath)\n        if os.IsNotExist(err) {\n                return nil\n        }\n        if err != nil {\n                return err\n        }\n        if !info.IsDir() {\n                return errDirectoryExpected\n        }\n        return nil\n}\n\n// Misc.\n\nfunc extractCloseFailoverVersion(filename string) (int64, error) {\n        filenameParts := strings.FieldsFunc(filename, func(r rune) bool {\n                return r == '_' || r == '.'\n        })\n        if len(filenameParts) != 3 {\n                return -1, errors.New(\"unknown filename structure\")\n        }\n        return strconv.ParseInt(filenameParts[1], 10, 64)\n}\n\nfunc historyMutated(request *archiver.ArchiveHistoryRequest, historyBatches []*historypb.History, isLast bool) bool {\n        lastBatch := historyBatches[len(historyBatches)-1].Events\n        lastEvent := lastBatch[len(lastBatch)-1]\n        lastFailoverVersion := lastEvent.GetVersion()\n        if lastFailoverVersion > request.CloseFailoverVersion {\n                return true\n        }\n\n        if !isLast {\n                return false\n        }\n        lastEventID := lastEvent.GetEventId()\n        return lastFailoverVersion != request.CloseFailoverVersion || lastEventID+1 != request.NextEventID\n}\n\nfunc contextExpired(ctx context.Context) bool {\n        select {\n        case <-ctx.Done():\n                return true\n        default:\n                return false\n        }\n}\n"}}