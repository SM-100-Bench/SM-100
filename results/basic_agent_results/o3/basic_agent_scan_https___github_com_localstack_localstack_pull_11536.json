{"repo_id": "localstack_localstack_11536", "bugs": [{"description": "_serve_werkzeug iterates over 'threads' and immediately returns inside the first iteration: 'for thread in threads: return thread.join()'. This causes the loop to stop after joining only the first server thread, leaving the remaining gateway servers un-joined when running synchronously. The premature return can lead to dangling threads and inconsistent shutdown behavior.", "file": "localstack-core/localstack/aws/serving/edge.py", "line": 84}, {"description": "_serve_werkzeug iterates over 'threads' and immediately returns inside the first iteration: 'for thread in threads: return thread.join()'. This causes the loop to stop after joining only the first server thread, leaving the remaining gateway servers un-joined when running synchronously. The premature return can lead to dangling threads and inconsistent shutdown behavior.", "file": "localstack-core/localstack/aws/serving/edge.py", "line": 84}, {"description": "In extract_bucket_key_version_id_from_copy_source() the code replaces every '+' in the URL path with a whitespace before URL-decoding (``parsed_path = urlparser.unquote(copy_source_parsed.path.replace(\"+\", \" \")).lstrip(\"/\")``).\nA literal plus sign ('+') is a valid character in S3 object keys and *is not* a synonym for a space in the path segment (only within the query component). Replacing it alters legitimate keys that contain '+', causing incorrect key resolution and potential NoSuchKey errors.", "file": "localstack-core/localstack/services/s3/utils.py", "line": 68}, {"description": "In extract_bucket_key_version_id_from_copy_source(), the code forcibly replaces all '+' characters in the URL path with spaces before URL-decoding:\n\n```python\nparsed_path = urlparser.unquote(copy_source_parsed.path.replace(\"+\", \" \")).lstrip(\"/\")\n```\n\nA plus sign is a perfectly valid character inside S3 object keys. Only in the query component of an URL does '+' represent a space. By converting every '+' in the path to a space, legitimate keys containing '+' are mangled, leading to incorrect object look-ups and potential NoSuchKey errors.", "file": "localstack-core/localstack/services/s3/utils.py", "line": 68}, {"description": "The function `extract_bucket_key_version_id_from_copy_source` wrongly converts all '+' characters in the URL path to spaces before URL-decoding:\n\n```python\nparsed_path = urlparser.unquote(copy_source_parsed.path.replace(\"+\", \" \")).lstrip(\"/\")\n```\n\nA plus sign is a valid character in S3 object keys and should remain unchanged in the path segment. Replacing it corrupts keys containing '+', leading to incorrect look-ups or `NoSuchKey` errors.", "file": "localstack-core/localstack/services/s3/utils.py", "line": 68}, {"description": "In AwsChunkedDecoder._get_next_chunk_length(), the code reads a line with `self._stream.readline()` and immediately executes:\n\n```python\nchunk_length = int(line.split(b\";\")[0], 16)\n```\n\nWhen the stream contains a normal chunk header without a trailing signature (e.g., `b\"a\\r\\n\"` for a 10-byte chunk), `line.split(b\";\")[0]` returns `b\"a\\r\\n\"`. The trailing CR/LF characters are **not** stripped, so `int(b\"a\\r\\n\", 16)` raises a `ValueError` (invalid literal for int()). This causes the decoder to crash when processing standard AWS chunked uploads that do not include a `;chunk-signature` suffix. The value must be stripped (e.g., `line.strip()` or `partition(b\";\")[0].strip()`) before conversion.", "file": "localstack-core/localstack/services/s3/codec.py", "line": 48}], "updated_files": {"/var/folders/hp/rv5nbb3140l0404lfjq_pq140000gn/T/tmp8twbj7qb/localstack-core/localstack/aws/serving/edge.py": "import logging\nimport threading\nfrom typing import List\n\nfrom rolo.gateway.wsgi import WsgiGateway\n\nfrom localstack import config\nfrom localstack.aws.app import LocalstackAwsGateway\nfrom localstack.config import HostAndPort\nfrom localstack.runtime import get_current_runtime\nfrom localstack.runtime.shutdown import ON_AFTER_SERVICE_SHUTDOWN_HANDLERS\nfrom localstack.utils.collections import ensure_list\n\nLOG = logging.getLogger(__name__)\n\n\ndef serve_gateway(\n    listen: HostAndPort | List[HostAndPort], use_ssl: bool, asynchronous: bool = False\n):\n    \"\"\"\n    Implementation of the edge.do_start_edge_proxy interface to start a Hypercorn server instance serving the\n    LocalstackAwsGateway.\n    \"\"\"\n\n    gateway = get_current_runtime().components.gateway\n\n    listens = ensure_list(listen)\n\n    if config.GATEWAY_SERVER == \"hypercorn\":\n        return _serve_hypercorn(gateway, listens, use_ssl, asynchronous)\n    elif config.GATEWAY_SERVER == \"werkzeug\":\n        return _serve_werkzeug(gateway, listens, use_ssl, asynchronous)\n    elif config.GATEWAY_SERVER == \"twisted\":\n        return _serve_twisted(gateway, listens, use_ssl, asynchronous)\n    else:\n        raise ValueError(f\"Unknown gateway server type {config.GATEWAY_SERVER}\")\n\n\ndef _serve_werkzeug(\n    gateway: LocalstackAwsGateway, listen: List[HostAndPort], use_ssl: bool, asynchronous: bool\n):\n    from werkzeug.serving import ThreadedWSGIServer\n\n    from .werkzeug import CustomWSGIRequestHandler\n\n    params = {\n        \"app\": WsgiGateway(gateway),\n        \"handler\": CustomWSGIRequestHandler,\n    }\n\n    if use_ssl:\n        from localstack.utils.ssl import create_ssl_cert, install_predefined_cert_if_available\n\n        install_predefined_cert_if_available()\n        serial_number = listen[0].port\n        _, cert_file_name, key_file_name = create_ssl_cert(serial_number=serial_number)\n        params[\"ssl_context\"] = (cert_file_name, key_file_name)\n\n    threads = []\n    servers: List[ThreadedWSGIServer] = []\n\n    for host_port in listen:\n        kwargs = dict(params)\n        kwargs[\"host\"] = host_port.host\n        kwargs[\"port\"] = host_port.port\n        server = ThreadedWSGIServer(**kwargs)\n        servers.append(server)\n        threads.append(\n            threading.Thread(\n                target=server.serve_forever, name=f\"werkzeug-server-{host_port.port}\", daemon=True\n            )\n        )\n\n    def _shutdown_servers():\n        LOG.debug(\"[shutdown] Shutting down gateway servers\")\n        for _srv in servers:\n            _srv.shutdown()\n\n    ON_AFTER_SERVICE_SHUTDOWN_HANDLERS.register(_shutdown_servers)\n\n    for thread in threads:\n        thread.start()\n\n    if not asynchronous:\n        for thread in threads:\n            thread.join()\n        return\n\n    # FIXME: thread handling is a bit wonky\n    return threads[0]\n\n\ndef _serve_hypercorn(\n    gateway: LocalstackAwsGateway, listen: List[HostAndPort], use_ssl: bool, asynchronous: bool\n):\n    from localstack.http.hypercorn import GatewayServer\n\n    # start serving gateway\n    server = GatewayServer(gateway, listen, use_ssl, config.GATEWAY_WORKER_COUNT)\n    server.start()\n\n    # with the current way the infrastructure is started, this is the easiest way to shut down the server correctly\n    # FIXME: but the infrastructure shutdown should be much cleaner, core components like the gateway should be handled\n    #  explicitly by the thing starting the components, not implicitly by the components.\n    def _shutdown_gateway():\n        LOG.debug(\"[shutdown] Shutting down gateway server\")\n        server.shutdown()\n\n    ON_AFTER_SERVICE_SHUTDOWN_HANDLERS.register(_shutdown_gateway)\n    if not asynchronous:\n        server.join()\n    return server._thread\n\n\ndef _serve_twisted(\n    gateway: LocalstackAwsGateway, listen: List[HostAndPort], use_ssl: bool, asynchronous: bool\n):\n    from .twisted import serve_gateway\n\n    return serve_gateway(gateway, listen, use_ssl, asynchronous)\n"}}