{"repo_id": "microsoft_inshellisense_212", "bugs": [{"description": "Incorrect usage of chalk to color border text. `chalk.hex(borderColor).apply(text)` attempts to call non-existent 'apply' method; correct usage is `chalk.hex(borderColor)(text)`. This will throw a TypeError at runtime when borderColor is provided, causing the UI to break.", "file": "src/ui/utils.ts", "line": 17}], "updated_files": {"/var/folders/hp/rv5nbb3140l0404lfjq_pq140000gn/T/tmpjjoomwob/src/ui/utils.ts": "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport ansi from \"ansi-escapes\";\nimport wrapAnsi from \"wrap-ansi\";\nimport chalk from \"chalk\";\nimport wcwdith from \"wcwidth\";\n\n/**\n * Renders a box around the given rows\n * @param rows the text content to be included in the box, must be <= width - 2\n * @param width the max width of a row\n * @param x the column to start the box at\n */\nexport const renderBox = (rows: string[], width: number, x: number, borderColor?: string) => {\n  const result = [];\n  const setColor = (text: string) => (borderColor ? chalk.hex(borderColor)(text) : text);\n  result.push(ansi.cursorTo(x) + setColor(\"\u250c\" + \"\u2500\".repeat(width - 2) + \"\u2510\") + ansi.cursorTo(x));\n  rows.forEach((row) => {\n    result.push(ansi.cursorDown() + setColor(\"\u2502\") + row + setColor(\"\u2502\") + ansi.cursorTo(x));\n  });\n  result.push(ansi.cursorDown() + setColor(\"\u2514\" + \"\u2500\".repeat(width - 2) + \"\u2518\") + ansi.cursorTo(x));\n  return result.join(\"\") + ansi.cursorUp(rows.length + 1);\n};\n\nexport const truncateMultilineText = (description: string, width: number, maxHeight: number) => {\n  const wrappedText = wrapAnsi(description, width, {\n    trim: false,\n    hard: true,\n  });\n  const lines = wrappedText.split(\"\\n\");\n  const truncatedLines = lines.slice(0, maxHeight);\n  if (lines.length > maxHeight) {\n    truncatedLines[maxHeight - 1] = [...truncatedLines[maxHeight - 1]].slice(0, -1).join(\"\") + \"\u2026\";\n  }\n  return truncatedLines.map((line) => line.padEnd(width));\n};\n\n/**\n * Truncates the text to the given width\n */\nexport const truncateText = (text: string, width: number) => {\n  const textPoints = [...text];\n  const wcOffset = Math.max(wcwdith(text) - textPoints.length, 0);\n  const slicedText = textPoints.slice(0, width - 1 - wcOffset);\n  return slicedText.length == textPoints.length ? text.padEnd(width) : (slicedText.join(\"\") + \"\u2026\").padEnd(width);\n};\n"}}