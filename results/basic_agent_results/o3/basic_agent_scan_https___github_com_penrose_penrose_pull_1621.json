{"repo_id": "penrose_penrose_1621", "bugs": [{"description": "Started code review but haven't reported any bugs yet.", "file": "N/A", "line": 0}, {"description": "Started code review but haven't reported any bugs yet.", "file": "N/A", "line": 0}, {"description": "WebSocket opened in `connectRoger()` is never closed when the `App` component unmounts. This can leave the connection open, cause memory leaks, and may trigger unexpected behaviour when the user navigates away or when React performs hot-reloads during development. A `useEffect` cleanup function that calls `ws.current.close()` (and removes event listeners) should be added.", "file": "packages/editor/src/App.tsx", "line": 118}, {"description": "The `connectRoger` function is wrapped in `useCallback` with an empty dependency array (`[]`). Inside, it references `rogerState`. Because `rogerState` is not listed as a dependency, the callbacks it installs on `ws.current` (e.g., `onclose`, `onerror`) capture the initial (stale) value of `rogerState` (likely `{ kind: \"disconnected\" }`). As a result, after the WebSocket transitions to `connected`, these handlers will still think the state is `disconnected` and will *not* trigger toast notifications or state updates when the socket closes or errors. This leads to incorrect UI behaviour and missed error handling.", "file": "packages/editor/src/App.tsx", "line": 97}, {"description": "Started code review but haven't reported any bugs yet.", "file": "N/A", "line": 0}, {"description": "WebSocket opened in `connectRoger()` is never closed when the `App` component unmounts. This can leave the connection open, cause memory leaks, and may trigger unexpected behaviour when the user navigates away or when React performs hot-reloads during development. A `useEffect` cleanup function that calls `ws.current.close()` (and removes event listeners) should be added.", "file": "packages/editor/src/App.tsx", "line": 118}, {"description": "The `connectRoger` function is wrapped in `useCallback` with an empty dependency array (`[]`). Inside, it references `rogerState`. Because `rogerState` is not listed as a dependency, the callbacks it installs on `ws.current` (e.g., `onclose`, `onerror`) capture the initial (stale) value of `rogerState` (likely `{ kind: \"disconnected\" }`). As a result, after the WebSocket transitions to `connected`, these handlers will still think the state is `disconnected` and will *not* trigger toast notifications or state updates when the socket closes or errors. This leads to incorrect UI behaviour and missed error handling.", "file": "packages/editor/src/App.tsx", "line": 97}, {"description": "When codegen.js creates the TypeScript wrapper for a .style file, it builds the path to `resolver.js` using:\n\n```js\n`${dir.split(path.sep).map(() => \"..\").join(\"/\")}/resolver.js`\n```\n\nIf `dir` is an empty string (i.e., the .style file is located directly inside `src/`), then `dir.split(path.sep)` returns `[\"\"]`. Mapping that array still produces `[\"..\"]`, so the template literal becomes `\"/resolver.js\"` (note the leading slash). This absolute-style import points to the filesystem root, and the module cannot be resolved at compile/run time, causing a build failure. The path should be `\"./resolver.js\"` when `dir === \"\"` (or otherwise ensure the leading segment is omitted).", "file": "packages/examples/codegen.js", "line": 53}, {"description": "Started code review but haven't reported any bugs yet.", "file": "N/A", "line": 0}, {"description": "WebSocket opened in `connectRoger()` is never closed when the `App` component unmounts. This can leave the connection open, cause memory leaks, and may trigger unexpected behaviour when the user navigates away or when React performs hot-reloads during development. A `useEffect` cleanup function that calls `ws.current.close()` (and removes event listeners) should be added.", "file": "packages/editor/src/App.tsx", "line": 118}, {"description": "The `connectRoger` function is wrapped in `useCallback` with an empty dependency array (`[]`). Inside, it references `rogerState`. Because `rogerState` is not listed as a dependency, the callbacks it installs on `ws.current` (e.g., `onclose`, `onerror`) capture the initial (stale) value of `rogerState` (likely `{ kind: \"disconnected\" }`). As a result, after the WebSocket transitions to `connected`, these handlers will still think the state is `disconnected` and will *not* trigger toast notifications or state updates when the socket closes or errors. This leads to incorrect UI behaviour and missed error handling.", "file": "packages/editor/src/App.tsx", "line": 97}, {"description": "When codegen.js creates the TypeScript wrapper for a .style file, it builds the path to `resolver.js` using:\n\n```js\n`${dir.split(path.sep).map(() => \"..\").join(\"/\")}/resolver.js`\n```\n\nIf `dir` is an empty string (i.e., the .style file is located directly inside `src/`), then `dir.split(path.sep)` returns `[\"\"]`. Mapping that array still produces `[\"..\"]`, so the template literal becomes `\"/resolver.js\"` (note the leading slash). This absolute-style import points to the filesystem root, and the module cannot be resolved at compile/run time, causing a build failure. The path should be `\"./resolver.js\"` when `dir === \"\"` (or otherwise ensure the leading segment is omitted).", "file": "packages/examples/codegen.js", "line": 53}, {"description": "Function `replaceStmt` identifies the target statement using strict reference equality (`s === originalStmt`). When the caller passes an equivalent statement that is not the same object instance (e.g., reconstructed from a parse, deep-cloned, or produced by other helpers), the replacement silently fails, leaving the AST unchanged. Given the rest of the subsystem frequently uses structural comparison via `nodesEqual`, `replaceStmt` should also rely on `nodesEqual` (or similar) instead of reference equality to avoid incorrect behavior.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "replaceStmt uses strict reference equality (===) to identify which statement to replace. If the caller passes a structurally-identical but different object instance of the statement (e.g., produced by parsing, cloning, or via nodesEqual elsewhere), the function silently fails to replace it, leading to incorrect program behavior. It should rely on structural comparison via the existing `nodesEqual` helper instead of strict identity.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "Function `replaceStmt` (packages/edgeworth/src/analysis/SubstanceAnalysis.ts) uses strict reference equality (`===`) to locate the statement to replace. If the caller passes a structurally\u2010identical but different object instance (e.g., cloned AST node), the replacement silently fails, causing incorrect program behavior. It should use structural comparison (`nodesEqual`) which already exists in the same file.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "Function `replaceStmt` identifies the statement to replace using strict reference equality (`===`). If the caller supplies a structurally identical but different object instance of the statement (e.g., produced by re-parsing or cloning the AST), the replacement silently fails, leaving the program unchanged and causing incorrect behavior. It should rely on structural comparison (`nodesEqual`) instead of reference equality.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "The function `replaceStmt` identifies a statement to be replaced using strict reference equality (`===`). If a structurally identical but different object instance is supplied (e.g., from a cloned/parsing operation), the replacement silently fails, leaving the program unchanged. This is inconsistent with the subsystem\u2019s use of structural comparisons (e.g., `nodesEqual`) elsewhere and can lead to incorrect behavior. `replaceStmt` should use `nodesEqual` (or similar) instead of `===`.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "Started code review but haven't reported any bugs yet.", "file": "N/A", "line": 0}, {"description": "WebSocket opened in `connectRoger()` is never closed when the `App` component unmounts. This can leave the connection open, cause memory leaks, and may trigger unexpected behaviour when the user navigates away or when React performs hot-reloads during development. A `useEffect` cleanup function that calls `ws.current.close()` (and removes event listeners) should be added.", "file": "packages/editor/src/App.tsx", "line": 118}, {"description": "The `connectRoger` function is wrapped in `useCallback` with an empty dependency array (`[]`). Inside, it references `rogerState`. Because `rogerState` is not listed as a dependency, the callbacks it installs on `ws.current` (e.g., `onclose`, `onerror`) capture the initial (stale) value of `rogerState` (likely `{ kind: \"disconnected\" }`). As a result, after the WebSocket transitions to `connected`, these handlers will still think the state is `disconnected` and will *not* trigger toast notifications or state updates when the socket closes or errors. This leads to incorrect UI behaviour and missed error handling.", "file": "packages/editor/src/App.tsx", "line": 97}, {"description": "When codegen.js creates the TypeScript wrapper for a .style file, it builds the path to `resolver.js` using:\n\n```js\n`${dir.split(path.sep).map(() => \"..\").join(\"/\")}/resolver.js`\n```\n\nIf `dir` is an empty string (i.e., the .style file is located directly inside `src/`), then `dir.split(path.sep)` returns `[\"\"]`. Mapping that array still produces `[\"..\"]`, so the template literal becomes `\"/resolver.js\"` (note the leading slash). This absolute-style import points to the filesystem root, and the module cannot be resolved at compile/run time, causing a build failure. The path should be `\"./resolver.js\"` when `dir === \"\"` (or otherwise ensure the leading segment is omitted).", "file": "packages/examples/codegen.js", "line": 53}, {"description": "Function `replaceStmt` identifies the target statement using strict reference equality (`s === originalStmt`). When the caller passes an equivalent statement that is not the same object instance (e.g., reconstructed from a parse, deep-cloned, or produced by other helpers), the replacement silently fails, leaving the AST unchanged. Given the rest of the subsystem frequently uses structural comparison via `nodesEqual`, `replaceStmt` should also rely on `nodesEqual` (or similar) instead of reference equality to avoid incorrect behavior.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "replaceStmt uses strict reference equality (===) to identify which statement to replace. If the caller passes a structurally-identical but different object instance of the statement (e.g., produced by parsing, cloning, or via nodesEqual elsewhere), the function silently fails to replace it, leading to incorrect program behavior. It should rely on structural comparison via the existing `nodesEqual` helper instead of strict identity.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "Function `replaceStmt` (packages/edgeworth/src/analysis/SubstanceAnalysis.ts) uses strict reference equality (`===`) to locate the statement to replace. If the caller passes a structurally\u2010identical but different object instance (e.g., cloned AST node), the replacement silently fails, causing incorrect program behavior. It should use structural comparison (`nodesEqual`) which already exists in the same file.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "Function `replaceStmt` identifies the statement to replace using strict reference equality (`===`). If the caller supplies a structurally identical but different object instance of the statement (e.g., produced by re-parsing or cloning the AST), the replacement silently fails, leaving the program unchanged and causing incorrect behavior. It should rely on structural comparison (`nodesEqual`) instead of reference equality.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "The function `replaceStmt` identifies a statement to be replaced using strict reference equality (`===`). If a structurally identical but different object instance is supplied (e.g., from a cloned/parsing operation), the replacement silently fails, leaving the program unchanged. This is inconsistent with the subsystem\u2019s use of structural comparisons (e.g., `nodesEqual`) elsewhere and can lead to incorrect behavior. `replaceStmt` should use `nodesEqual` (or similar) instead of `===`.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "The WebSocket 'retrieve_file_from_style' and 'retrieve_file' handlers in watch.ts read and send arbitrary files specified by the client without validating or restricting the requested path. A malicious client can craft paths like \"../../../etc/passwd\" to achieve directory-traversal and exfiltrate sensitive files, constituting a serious security vulnerability.", "file": "packages/roger/watch.ts", "line": 30}, {"description": "Started code review but haven't reported any bugs yet.", "file": "N/A", "line": 0}, {"description": "WebSocket opened in `connectRoger()` is never closed when the `App` component unmounts. This can leave the connection open, cause memory leaks, and may trigger unexpected behaviour when the user navigates away or when React performs hot-reloads during development. A `useEffect` cleanup function that calls `ws.current.close()` (and removes event listeners) should be added.", "file": "packages/editor/src/App.tsx", "line": 118}, {"description": "The `connectRoger` function is wrapped in `useCallback` with an empty dependency array (`[]`). Inside, it references `rogerState`. Because `rogerState` is not listed as a dependency, the callbacks it installs on `ws.current` (e.g., `onclose`, `onerror`) capture the initial (stale) value of `rogerState` (likely `{ kind: \"disconnected\" }`). As a result, after the WebSocket transitions to `connected`, these handlers will still think the state is `disconnected` and will *not* trigger toast notifications or state updates when the socket closes or errors. This leads to incorrect UI behaviour and missed error handling.", "file": "packages/editor/src/App.tsx", "line": 97}, {"description": "When codegen.js creates the TypeScript wrapper for a .style file, it builds the path to `resolver.js` using:\n\n```js\n`${dir.split(path.sep).map(() => \"..\").join(\"/\")}/resolver.js`\n```\n\nIf `dir` is an empty string (i.e., the .style file is located directly inside `src/`), then `dir.split(path.sep)` returns `[\"\"]`. Mapping that array still produces `[\"..\"]`, so the template literal becomes `\"/resolver.js\"` (note the leading slash). This absolute-style import points to the filesystem root, and the module cannot be resolved at compile/run time, causing a build failure. The path should be `\"./resolver.js\"` when `dir === \"\"` (or otherwise ensure the leading segment is omitted).", "file": "packages/examples/codegen.js", "line": 53}, {"description": "Function `replaceStmt` identifies the target statement using strict reference equality (`s === originalStmt`). When the caller passes an equivalent statement that is not the same object instance (e.g., reconstructed from a parse, deep-cloned, or produced by other helpers), the replacement silently fails, leaving the AST unchanged. Given the rest of the subsystem frequently uses structural comparison via `nodesEqual`, `replaceStmt` should also rely on `nodesEqual` (or similar) instead of reference equality to avoid incorrect behavior.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "replaceStmt uses strict reference equality (===) to identify which statement to replace. If the caller passes a structurally-identical but different object instance of the statement (e.g., produced by parsing, cloning, or via nodesEqual elsewhere), the function silently fails to replace it, leading to incorrect program behavior. It should rely on structural comparison via the existing `nodesEqual` helper instead of strict identity.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "Function `replaceStmt` (packages/edgeworth/src/analysis/SubstanceAnalysis.ts) uses strict reference equality (`===`) to locate the statement to replace. If the caller passes a structurally\u2010identical but different object instance (e.g., cloned AST node), the replacement silently fails, causing incorrect program behavior. It should use structural comparison (`nodesEqual`) which already exists in the same file.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "Function `replaceStmt` identifies the statement to replace using strict reference equality (`===`). If the caller supplies a structurally identical but different object instance of the statement (e.g., produced by re-parsing or cloning the AST), the replacement silently fails, leaving the program unchanged and causing incorrect behavior. It should rely on structural comparison (`nodesEqual`) instead of reference equality.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "The function `replaceStmt` identifies a statement to be replaced using strict reference equality (`===`). If a structurally identical but different object instance is supplied (e.g., from a cloned/parsing operation), the replacement silently fails, leaving the program unchanged. This is inconsistent with the subsystem\u2019s use of structural comparisons (e.g., `nodesEqual`) elsewhere and can lead to incorrect behavior. `replaceStmt` should use `nodesEqual` (or similar) instead of `===`.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "The WebSocket 'retrieve_file_from_style' and 'retrieve_file' handlers in watch.ts read and send arbitrary files specified by the client without validating or restricting the requested path. A malicious client can craft paths like \"../../../etc/passwd\" to achieve directory-traversal and exfiltrate sensitive files, constituting a serious security vulnerability.", "file": "packages/roger/watch.ts", "line": 30}, {"description": "App.tsx imports './eigenvectors.jsx', but the actual file is 'eigenvectors.tsx'. This incorrect file extension causes the module resolution to fail, leading to a compile-time error (\"Cannot find module './eigenvectors.jsx'\").", "file": "packages/solids/src/App.tsx", "line": 1}, {"description": "Started code review but haven't reported any bugs yet.", "file": "N/A", "line": 0}, {"description": "WebSocket opened in `connectRoger()` is never closed when the `App` component unmounts. This can leave the connection open, cause memory leaks, and may trigger unexpected behaviour when the user navigates away or when React performs hot-reloads during development. A `useEffect` cleanup function that calls `ws.current.close()` (and removes event listeners) should be added.", "file": "packages/editor/src/App.tsx", "line": 118}, {"description": "The `connectRoger` function is wrapped in `useCallback` with an empty dependency array (`[]`). Inside, it references `rogerState`. Because `rogerState` is not listed as a dependency, the callbacks it installs on `ws.current` (e.g., `onclose`, `onerror`) capture the initial (stale) value of `rogerState` (likely `{ kind: \"disconnected\" }`). As a result, after the WebSocket transitions to `connected`, these handlers will still think the state is `disconnected` and will *not* trigger toast notifications or state updates when the socket closes or errors. This leads to incorrect UI behaviour and missed error handling.", "file": "packages/editor/src/App.tsx", "line": 97}, {"description": "When codegen.js creates the TypeScript wrapper for a .style file, it builds the path to `resolver.js` using:\n\n```js\n`${dir.split(path.sep).map(() => \"..\").join(\"/\")}/resolver.js`\n```\n\nIf `dir` is an empty string (i.e., the .style file is located directly inside `src/`), then `dir.split(path.sep)` returns `[\"\"]`. Mapping that array still produces `[\"..\"]`, so the template literal becomes `\"/resolver.js\"` (note the leading slash). This absolute-style import points to the filesystem root, and the module cannot be resolved at compile/run time, causing a build failure. The path should be `\"./resolver.js\"` when `dir === \"\"` (or otherwise ensure the leading segment is omitted).", "file": "packages/examples/codegen.js", "line": 53}, {"description": "Function `replaceStmt` identifies the target statement using strict reference equality (`s === originalStmt`). When the caller passes an equivalent statement that is not the same object instance (e.g., reconstructed from a parse, deep-cloned, or produced by other helpers), the replacement silently fails, leaving the AST unchanged. Given the rest of the subsystem frequently uses structural comparison via `nodesEqual`, `replaceStmt` should also rely on `nodesEqual` (or similar) instead of reference equality to avoid incorrect behavior.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "replaceStmt uses strict reference equality (===) to identify which statement to replace. If the caller passes a structurally-identical but different object instance of the statement (e.g., produced by parsing, cloning, or via nodesEqual elsewhere), the function silently fails to replace it, leading to incorrect program behavior. It should rely on structural comparison via the existing `nodesEqual` helper instead of strict identity.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "Function `replaceStmt` (packages/edgeworth/src/analysis/SubstanceAnalysis.ts) uses strict reference equality (`===`) to locate the statement to replace. If the caller passes a structurally\u2010identical but different object instance (e.g., cloned AST node), the replacement silently fails, causing incorrect program behavior. It should use structural comparison (`nodesEqual`) which already exists in the same file.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "Function `replaceStmt` identifies the statement to replace using strict reference equality (`===`). If the caller supplies a structurally identical but different object instance of the statement (e.g., produced by re-parsing or cloning the AST), the replacement silently fails, leaving the program unchanged and causing incorrect behavior. It should rely on structural comparison (`nodesEqual`) instead of reference equality.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "The function `replaceStmt` identifies a statement to be replaced using strict reference equality (`===`). If a structurally identical but different object instance is supplied (e.g., from a cloned/parsing operation), the replacement silently fails, leaving the program unchanged. This is inconsistent with the subsystem\u2019s use of structural comparisons (e.g., `nodesEqual`) elsewhere and can lead to incorrect behavior. `replaceStmt` should use `nodesEqual` (or similar) instead of `===`.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "The WebSocket 'retrieve_file_from_style' and 'retrieve_file' handlers in watch.ts read and send arbitrary files specified by the client without validating or restricting the requested path. A malicious client can craft paths like \"../../../etc/passwd\" to achieve directory-traversal and exfiltrate sensitive files, constituting a serious security vulnerability.", "file": "packages/roger/watch.ts", "line": 30}, {"description": "App.tsx imports './eigenvectors.jsx', but the actual file is 'eigenvectors.tsx'. This incorrect file extension causes the module resolution to fail, leading to a compile-time error (\"Cannot find module './eigenvectors.jsx'\").", "file": "packages/solids/src/App.tsx", "line": 1}, {"description": "The regex for support types in style.tmGrammar.json begins with '^\\b', anchoring the pattern to the start of the line. This prevents matching type keywords that appear after initial whitespace or other characters, causing incorrect syntax highlighting. The beginning-of-line anchor '^' should be removed so the word-boundary '\\b' alone is used.", "file": "packages/vscode/syntaxes/style.tmGrammar.json", "line": 45}, {"description": "Started code review but haven't reported any bugs yet.", "file": "N/A", "line": 0}, {"description": "WebSocket opened in `connectRoger()` is never closed when the `App` component unmounts. This can leave the connection open, cause memory leaks, and may trigger unexpected behaviour when the user navigates away or when React performs hot-reloads during development. A `useEffect` cleanup function that calls `ws.current.close()` (and removes event listeners) should be added.", "file": "packages/editor/src/App.tsx", "line": 118}, {"description": "The `connectRoger` function is wrapped in `useCallback` with an empty dependency array (`[]`). Inside, it references `rogerState`. Because `rogerState` is not listed as a dependency, the callbacks it installs on `ws.current` (e.g., `onclose`, `onerror`) capture the initial (stale) value of `rogerState` (likely `{ kind: \"disconnected\" }`). As a result, after the WebSocket transitions to `connected`, these handlers will still think the state is `disconnected` and will *not* trigger toast notifications or state updates when the socket closes or errors. This leads to incorrect UI behaviour and missed error handling.", "file": "packages/editor/src/App.tsx", "line": 97}, {"description": "When codegen.js creates the TypeScript wrapper for a .style file, it builds the path to `resolver.js` using:\n\n```js\n`${dir.split(path.sep).map(() => \"..\").join(\"/\")}/resolver.js`\n```\n\nIf `dir` is an empty string (i.e., the .style file is located directly inside `src/`), then `dir.split(path.sep)` returns `[\"\"]`. Mapping that array still produces `[\"..\"]`, so the template literal becomes `\"/resolver.js\"` (note the leading slash). This absolute-style import points to the filesystem root, and the module cannot be resolved at compile/run time, causing a build failure. The path should be `\"./resolver.js\"` when `dir === \"\"` (or otherwise ensure the leading segment is omitted).", "file": "packages/examples/codegen.js", "line": 53}, {"description": "Function `replaceStmt` identifies the target statement using strict reference equality (`s === originalStmt`). When the caller passes an equivalent statement that is not the same object instance (e.g., reconstructed from a parse, deep-cloned, or produced by other helpers), the replacement silently fails, leaving the AST unchanged. Given the rest of the subsystem frequently uses structural comparison via `nodesEqual`, `replaceStmt` should also rely on `nodesEqual` (or similar) instead of reference equality to avoid incorrect behavior.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "replaceStmt uses strict reference equality (===) to identify which statement to replace. If the caller passes a structurally-identical but different object instance of the statement (e.g., produced by parsing, cloning, or via nodesEqual elsewhere), the function silently fails to replace it, leading to incorrect program behavior. It should rely on structural comparison via the existing `nodesEqual` helper instead of strict identity.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "Function `replaceStmt` (packages/edgeworth/src/analysis/SubstanceAnalysis.ts) uses strict reference equality (`===`) to locate the statement to replace. If the caller passes a structurally\u2010identical but different object instance (e.g., cloned AST node), the replacement silently fails, causing incorrect program behavior. It should use structural comparison (`nodesEqual`) which already exists in the same file.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "Function `replaceStmt` identifies the statement to replace using strict reference equality (`===`). If the caller supplies a structurally identical but different object instance of the statement (e.g., produced by re-parsing or cloning the AST), the replacement silently fails, leaving the program unchanged and causing incorrect behavior. It should rely on structural comparison (`nodesEqual`) instead of reference equality.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "The function `replaceStmt` identifies a statement to be replaced using strict reference equality (`===`). If a structurally identical but different object instance is supplied (e.g., from a cloned/parsing operation), the replacement silently fails, leaving the program unchanged. This is inconsistent with the subsystem\u2019s use of structural comparisons (e.g., `nodesEqual`) elsewhere and can lead to incorrect behavior. `replaceStmt` should use `nodesEqual` (or similar) instead of `===`.", "file": "packages/edgeworth/src/analysis/SubstanceAnalysis.ts", "line": 56}, {"description": "The WebSocket 'retrieve_file_from_style' and 'retrieve_file' handlers in watch.ts read and send arbitrary files specified by the client without validating or restricting the requested path. A malicious client can craft paths like \"../../../etc/passwd\" to achieve directory-traversal and exfiltrate sensitive files, constituting a serious security vulnerability.", "file": "packages/roger/watch.ts", "line": 30}, {"description": "App.tsx imports './eigenvectors.jsx', but the actual file is 'eigenvectors.tsx'. This incorrect file extension causes the module resolution to fail, leading to a compile-time error (\"Cannot find module './eigenvectors.jsx'\").", "file": "packages/solids/src/App.tsx", "line": 1}, {"description": "The regex for support types in style.tmGrammar.json begins with '^\\b', anchoring the pattern to the start of the line. This prevents matching type keywords that appear after initial whitespace or other characters, causing incorrect syntax highlighting. The beginning-of-line anchor '^' should be removed so the word-boundary '\\b' alone is used.", "file": "packages/vscode/syntaxes/style.tmGrammar.json", "line": 45}, {"description": "The `lint-pr.yml` workflow is triggered using the `pull_request_target` event and directly executes a third-party action (`amannn/action-semantic-pull-request@v4`) with the repository-scoped `GITHUB_TOKEN`.  Because the action code is fetched from an external repository at run-time, a supply-chain attack on that action (or a compromised commit hash being pushed under the same tag) would grant write access to the repository (e.g. the ability to push, modify issues, etc.).  Granting write permissions to unpinned third-party code in a `pull_request_target` workflow is considered a security vulnerability by GitHub\u2019s own guidance.", "file": ".github/workflows/lint-pr.yml", "line": 15}, {"description": "The custom composite action downloads and executes a pre-built binary of `wasm-bindgen` via `wget` without verifying a checksum or GPG signature.  An attacker able to man-in-the-middle the download or compromise the GitHub Release asset could supply a malicious executable that would run in every CI job, leading to remote-code-execution in the workflow runner.\n\nMitigation: Pin the download by SHA256 checksum (or install via `cargo install wasm-bindgen-cli --version \u2026`) or use an official, version-pinned GitHub Action instead of an ad-hoc download.", "file": ".github/actions/setup/action.yml", "line": 15}], "updated_files": {"/var/folders/hp/rv5nbb3140l0404lfjq_pq140000gn/T/tmp1y01hkze/packages/examples/codegen.js": "import * as fs from \"fs\";\nimport * as path from \"path\";\n\nconst src = \"src\";\nconst trioSuffix = \".trio.json\";\n\nconst svgs = [];\n\nconst codegen = (dir) => {\n  const srcDir = path.join(src, dir);\n  for (const child of fs.readdirSync(srcDir)) {\n    const dirChild = path.join(dir, child);\n    const srcDirChild = path.join(src, dirChild);\n    if (fs.statSync(srcDirChild).isDirectory()) {\n      codegen(dirChild);\n    } else {\n      const ext = path.extname(child);\n      const contents = fs.readFileSync(srcDirChild, \"utf8\");\n      if (child.endsWith(trioSuffix) && child !== trioSuffix) {\n        const trio = JSON.parse(contents);\n        fs.writeFileSync(\n          path.join(srcDir, `${path.basename(child, \".json\")}.ts`),\n          [\n            `import substance from \"${trio.substance}.js\";`,\n            ...trio.style.map(\n              (style, i) =>\n                `import style${i}, { resolver as resolver${i} } from \"${style}.js\";`,\n            ),\n            `import domain from \"${trio.domain}.js\";`,\n            \"export default {\",\n            \"  substance,\",\n            \"  style: [\",\n            ...trio.style.map(\n              (style, i) =>\n                `    { contents: style${i}, resolver: resolver${i} },`,\n            ),\n            \"  ],\",\n            \"  domain,\",\n            `  variation: ${JSON.stringify(trio.variation)},`,\n            `  excludeWarnings: ${\n              trio.excludeWarnings === undefined\n                ? JSON.stringify([])\n                : JSON.stringify(trio.excludeWarnings)\n            }`,\n            \"};\",\n            \"\",\n          ].join(\"\\n\"),\n        );\n      } else if (ext === \".style\") {\n        fs.writeFileSync(\n          `${srcDirChild}.ts`,\n          [\n            `import { makeResolver } from \"${\n              dir === \"\" ? \".\" : dir\n                .split(path.sep)\n                .map(() => \"..\")\n                .join(\"/\")\n            }/resolver.js\";`,\n            `export const resolver = makeResolver(${JSON.stringify(dir)});`,\n            `export default ${JSON.stringify(contents)};`,\n            \"\",\n          ].join(\"\\n\"),\n        );\n      } else if (ext === \".domain\" || ext === \".substance\") {\n        fs.writeFileSync(\n          `${srcDirChild}.ts`,\n          `export default ${JSON.stringify(contents)};`,\n        );\n      } else if (ext === \".svg\") {\n        svgs.push(dirChild);\n        fs.writeFileSync(\n          `${srcDirChild}.ts`,\n          `export default ${JSON.stringify(contents)};`,\n        );\n      }\n    }\n  }\n};\n\ncodegen(\"\");\n\nconst registry = JSON.parse(fs.readFileSync(`${src}/registry.json`, \"utf8\"));\nconst lines = [\n  'import { Meta, Trio } from \"./index.js\";',\n  \"\",\n  \"const trio = async (x: Promise<{ default: Trio }>): Promise<Trio> =>\",\n  \"  (await x).default;\",\n  \"\",\n  \"const entries: [string, Meta][] = [\",\n];\nfor (const [k, v] of Object.entries(registry)) {\n  lines.push(`  [${JSON.stringify(k)}, {`);\n  const isTrio = v.trio ?? true;\n  lines.push(`    trio: ${isTrio},`);\n  if (isTrio) {\n    lines.push(\n      `    get: () => trio(import(${JSON.stringify(`./${k}.trio.js`)})),`,\n    );\n    if (\"gallery\" in v) lines.push(`    gallery: ${v.gallery},`);\n  } else {\n    lines.push(\n      `    f: async () => (await import(${JSON.stringify(\n        `./${k}.js`,\n      )})).default(),`,\n    );\n  }\n  if (\"name\" in v) lines.push(`    name: ${JSON.stringify(v.name)},`);\n  lines.push(`  }],`);\n}\nlines.push(\"];\");\nlines.push(\"\");\nlines.push(\"export default new Map<string, Meta>(entries);\");\nlines.push(\"\");\nfs.writeFileSync(`${src}/registry.ts`, lines.join(\"\\n\"));\n\nfs.writeFileSync(\n  `${src}/resolver.ts`,\n  [\n    'import { PathResolver, join } from \"./index.js\";',\n    \"\",\n    \"export const makeResolver = (dir: string): PathResolver => async (path: string): Promise<string | undefined> => {\",\n    \"  switch (join(dir, path)) {\",\n    ...svgs.flatMap((svg) => [\n      `    case ${JSON.stringify(svg)}:`,\n      `      return (await import(${JSON.stringify(`./${svg}.js`)})).default;`,\n    ]),\n    \"    default:\",\n    \"      return undefined;\",\n    \"  }\",\n    \"};\",\n    \"\",\n  ].join(\"\\n\"),\n);\n"}}