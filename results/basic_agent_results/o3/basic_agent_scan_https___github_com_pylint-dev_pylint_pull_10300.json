{"repo_id": "pylint-dev_pylint_10300", "bugs": [{"description": "OutputLine.from_msg accesses 'msg.confidence.name'. When a Pylint Message has an undefined confidence level, 'msg.confidence' can be the sentinel UNDEFINED (imported from pylint.interfaces), which is not an Enum instance and therefore has no 'name' attribute. Attempting to read 'name' raises AttributeError, causing crashes when messages with undefined confidence are processed.", "file": "pylint/testutils/output_line.py", "line": 56}], "updated_files": {"/var/folders/hp/rv5nbb3140l0404lfjq_pq140000gn/T/tmpjxltb4ns/pylint/testutils/output_line.py": "# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\nfrom __future__ import annotations\n\nfrom collections.abc import Sequence\nfrom typing import Any, NamedTuple, TypeVar\n\nfrom astroid import nodes\n\nfrom pylint.interfaces import UNDEFINED, Confidence\nfrom pylint.message.message import Message\n\n_T = TypeVar(\"_T\")\n\n\nclass MessageTest(NamedTuple):\n    msg_id: str\n    line: int | None = None\n    node: nodes.NodeNG | None = None\n    args: Any | None = None\n    confidence: Confidence | None = UNDEFINED\n    col_offset: int | None = None\n    end_line: int | None = None\n    end_col_offset: int | None = None\n    \"\"\"Used to test messages produced by pylint.\n\n    Class name cannot start with Test as pytest doesn't allow constructors in test classes.\n    \"\"\"\n\n\nclass OutputLine(NamedTuple):\n    symbol: str\n    lineno: int\n    column: int\n    end_lineno: int | None\n    end_column: int | None\n    object: str\n    msg: str\n    confidence: str\n\n    @classmethod\n    def from_msg(cls, msg: Message, check_endline: bool = True) -> OutputLine:\n        \"\"\"Create an OutputLine from a Pylint Message.\"\"\"\n        column = cls._get_column(msg.column)\n        end_line = cls._get_end_line_and_end_col(msg.end_line, check_endline)\n        end_column = cls._get_end_line_and_end_col(msg.end_column, check_endline)\n        return cls(\n            msg.symbol,\n            msg.line,\n            column,\n            end_line,\n            end_column,\n            msg.obj or \"\",\n            msg.msg.replace(\"\\r\\n\", \"\\n\"),\n            getattr(msg.confidence, \"name\", str(msg.confidence)),\n        )\n\n    @staticmethod\n    def _get_column(column: str | int) -> int:\n        \"\"\"Handle column numbers.\"\"\"\n        return int(column)\n\n    @staticmethod\n    def _get_end_line_and_end_col(value: _T, check_endline: bool) -> _T | None:\n        \"\"\"Used to make end_line and end_column None as indicated by our version\n        compared to `min_pyver_end_position`.\n        \"\"\"\n        if not check_endline:\n            return None  # pragma: no cover\n        return value\n\n    @classmethod\n    def from_csv(\n        cls, row: Sequence[str] | str, check_endline: bool = True\n    ) -> OutputLine:\n        \"\"\"Create an OutputLine from a comma separated list (the functional tests\n        expected output .txt files).\n        \"\"\"\n        if isinstance(row, str):\n            row = row.split(\",\")\n        try:\n            line = int(row[1])\n            column = cls._get_column(row[2])\n            end_line = cls._value_to_optional_int(\n                cls._get_end_line_and_end_col(row[3], check_endline)\n            )\n            end_column = cls._value_to_optional_int(\n                cls._get_end_line_and_end_col(row[4], check_endline)\n            )\n            # symbol, line, column, end_line, end_column, node, msg, confidences\n            assert len(row) == 8\n            return cls(\n                row[0], line, column, end_line, end_column, row[5], row[6], row[7]\n            )\n        except Exception:  # pylint: disable=broad-except\n            # We need this to not fail for the update script to work.\n            return cls(\"\", 0, 0, None, None, \"\", \"\", \"\")\n\n    def to_csv(self) -> tuple[str, str, str, str, str, str, str, str]:\n        \"\"\"Convert an OutputLine to a tuple of string to be written by a\n        csv-writer.\n        \"\"\"\n        return (\n            str(self.symbol),\n            str(self.lineno),\n            str(self.column),\n            str(self.end_lineno),\n            str(self.end_column),\n            str(self.object),\n            str(self.msg),\n            str(self.confidence),\n        )\n\n    @staticmethod\n    def _value_to_optional_int(value: str | None) -> int | None:\n        \"\"\"Checks if a (stringified) value should be None or a Python integer.\"\"\"\n        if value == \"None\" or not value:\n            return None\n        return int(value)\n"}}