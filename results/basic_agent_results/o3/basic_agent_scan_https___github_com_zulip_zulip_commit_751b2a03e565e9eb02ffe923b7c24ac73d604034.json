{"repo_id": "zulip_zulip_751b2a03e565e9eb02ffe923b7c24ac73d604034", "bugs": [{"description": "MAX_EMOJI_GIF_FILE_SIZE_BYTES is set to 128 * 1024 * 1024 (128 MB) while the accompanying comment says \u201c128 kb\u201d. The multiplier should be 1024, not 1024 * 1024. As written, the code permits custom animated emoji files up to 128 MB, 1024\u00d7 larger than intended, which can waste storage and be abused for DoS via large uploads.", "file": "zerver/lib/upload.py", "line": 54}], "updated_files": {"/var/folders/hp/rv5nbb3140l0404lfjq_pq140000gn/T/tmpicexpf5e/zerver/lib/upload.py": "import base64\nimport binascii\nimport io\nimport logging\nimport os\nimport random\nimport re\nimport secrets\nimport shutil\nimport unicodedata\nimport urllib\nfrom datetime import timedelta\nfrom mimetypes import guess_extension, guess_type\nfrom typing import IO, Any, Callable, Optional, Tuple\nfrom urllib.parse import urljoin\n\nimport boto3\nimport botocore\nfrom boto3.session import Session\nfrom botocore.client import Config\nfrom django.conf import settings\nfrom django.core.files import File\nfrom django.core.signing import BadSignature, TimestampSigner\nfrom django.http import HttpRequest\nfrom django.urls import reverse\nfrom django.utils.translation import gettext as _\nfrom markupsafe import Markup as mark_safe\nfrom mypy_boto3_s3.client import S3Client\nfrom mypy_boto3_s3.service_resource import Bucket, Object\nfrom PIL import GifImagePlugin, Image, ImageOps, PngImagePlugin\nfrom PIL.Image import DecompressionBombError\n\nfrom zerver.lib.avatar_hash import user_avatar_path\nfrom zerver.lib.exceptions import ErrorCode, JsonableError\nfrom zerver.lib.outgoing_http import OutgoingSession\nfrom zerver.lib.utils import assert_is_not_none\nfrom zerver.models import (\n    Attachment,\n    Message,\n    Realm,\n    RealmEmoji,\n    UserProfile,\n    is_cross_realm_bot_email,\n)\n\nDEFAULT_AVATAR_SIZE = 100\nMEDIUM_AVATAR_SIZE = 500\nDEFAULT_EMOJI_SIZE = 64\n\n# These sizes were selected based on looking at the maximum common\n# sizes in a library of animated custom emoji, balanced against the\n# network cost of very large emoji images.\nMAX_EMOJI_GIF_SIZE = 128\nMAX_EMOJI_GIF_FILE_SIZE_BYTES = 128 * 1024  # 128 kb\n\n# Duration that the signed upload URLs that we redirect to when\n# accessing uploaded files are available for clients to fetch before\n# they expire.\nSIGNED_UPLOAD_URL_DURATION = 60\n\nINLINE_MIME_TYPES = [\n    \"application/pdf\",\n    \"image/gif\",\n    \"image/jpeg\",\n    \"image/png\",\n    \"image/webp\",\n    # To avoid cross-site scripting attacks, DO NOT add types such\n    # as application/xhtml+xml, application/x-shockwave-flash,\n    # image/svg+xml, text/html, or text/xml.\n]\n\n# Performance note:\n#\n# For writing files to S3, the file could either be stored in RAM\n# (if it is less than 2.5MiB or so) or an actual temporary file on disk.\n#\n# Because we set FILE_UPLOAD_MAX_MEMORY_SIZE to 0, only the latter case\n# should occur in practice.\n#\n# This is great, because passing the pseudofile object that Django gives\n# you to boto would be a pain.\n\n# To come up with a s3 key we randomly generate a \"directory\". The\n# \"file name\" is the original filename provided by the user run\n# through a sanitization function.\n\n\n# https://github.com/boto/botocore/issues/2644 means that the IMDS\n# request _always_ pulls from the environment.  Monkey-patch the\n# `should_bypass_proxies` function if we need to skip them, based\n# on S3_SKIP_PROXY.\nif settings.S3_SKIP_PROXY is True:  # nocoverage\n    botocore.utils.should_bypass_proxies = lambda url: True\n\n\nclass RealmUploadQuotaError(JsonableError):\n    code = ErrorCode.REALM_UPLOAD_QUOTA\n\n\ndef sanitize_name(value: str) -> str:\n    \"\"\"\n    Sanitizes a value to be safe to store in a Linux filesystem, in\n    S3, and in a URL.  So Unicode is allowed, but not special\n    characters other than \".\", \"-\", and \"_\".\n\n    This implementation is based on django.utils.text.slugify; it is\n    modified by:\n    * adding '.' to the list of allowed characters.\n    * preserving the case of the value.\n    * not stripping trailing dashes and underscores.\n    \"\"\"\n    value = unicodedata.normalize(\"NFKC\", value)\n    value = re.sub(r\"[^\\w\\s.-]\", \"\", value).strip()\n    value = re.sub(r\"[-\\s]+\", \"-\", value)\n    assert value not in {\"\", \".\", \"..\"}\n    return mark_safe(value)\n\n\nclass BadImageError(JsonableError):\n    code = ErrorCode.BAD_IMAGE\n\n\ndef resize_avatar(image_data: bytes, size: int = DEFAULT_AVATAR_SIZE) -> bytes:\n    try:\n        im = Image.open(io.BytesIO(image_data))\n        im = ImageOps.exif_transpose(im)\n        im = ImageOps.fit(im, (size, size), Image.ANTIALIAS)\n    except OSError:\n        raise BadImageError(_(\"Could not decode image; did you upload an image file?\"))\n    except DecompressionBombError:\n        raise BadImageError(_(\"Image size exceeds limit.\"))\n    out = io.BytesIO()\n    if im.mode == \"CMYK\":\n        im = im.convert(\"RGB\")\n    im.save(out, format=\"png\")\n    return out.getvalue()\n\n\ndef resize_logo(image_data: bytes) -> bytes:\n    try:\n        im = Image.open(io.BytesIO(image_data))\n        im = ImageOps.exif_transpose(im)\n        im.thumbnail((8 * DEFAULT_AVATAR_SIZE, DEFAULT_AVATAR_SIZE), Image.ANTIALIAS)\n    except OSError:\n        raise BadImageError(_(\"Could not decode image; did you upload an image file?\"))\n    except DecompressionBombError:\n        raise BadImageError(_(\"Image size exceeds limit.\"))\n    out = io.BytesIO()\n    if im.mode == \"CMYK\":\n        im = im.convert(\"RGB\")\n    im.save(out, format=\"png\")\n    return out.getvalue()\n\n\ndef resize_animated(im: Image.Image, size: int = DEFAULT_EMOJI_SIZE) -> bytes:\n    assert im.n_frames > 1\n    frames = []\n    duration_info = []\n    disposals = []\n    # If 'loop' info is not set then loop for infinite number of times.\n    loop = im.info.get(\"loop\", 0)\n    for frame_num in range(0, im.n_frames):\n        im.seek(frame_num)\n        new_frame = im.copy()\n        new_frame.paste(im, (0, 0), im.convert(\"RGBA\"))\n        new_frame = ImageOps.pad(new_frame, (size, size), Image.ANTIALIAS)\n        frames.append(new_frame)\n        if im.info.get(\"duration\") is None:  # nocoverage\n            raise BadImageError(_(\"Corrupt animated image.\"))\n        duration_info.append(im.info[\"duration\"])\n        if isinstance(im, GifImagePlugin.GifImageFile):\n            disposals.append(\n                im.disposal_method  # type: ignore[attr-defined]  # private member missing from stubs\n            )\n        elif isinstance(im, PngImagePlugin.PngImageFile):\n            disposals.append(im.info.get(\"disposal\", PngImagePlugin.APNG_DISPOSE_OP_NONE))\n        else:  # nocoverage\n            raise BadImageError(_(\"Unknown animated image format.\"))\n    out = io.BytesIO()\n    frames[0].save(\n        out,\n        save_all=True,\n        optimize=False,\n        format=im.format,\n        append_images=frames[1:],\n        duration=duration_info,\n        disposal=disposals,\n        loop=loop,\n    )\n\n    return out.getvalue()\n\n\ndef resize_emoji(\n    image_data: bytes, size: int = DEFAULT_EMOJI_SIZE\n) -> Tuple[bytes, bool, Optional[bytes]]:\n    # This function returns three values:\n    # 1) Emoji image data.\n    # 2) If emoji is gif i.e animated.\n    # 3) If is animated then return still image data i.e first frame of gif.\n\n    try:\n        im = Image.open(io.BytesIO(image_data))\n        image_format = im.format\n        if getattr(im, \"n_frames\", 1) > 1:\n            # There are a number of bugs in Pillow which cause results\n            # in resized images being broken. To work around this we\n            # only resize under certain conditions to minimize the\n            # chance of creating ugly images.\n            should_resize = (\n                im.size[0] != im.size[1]  # not square\n                or im.size[0] > MAX_EMOJI_GIF_SIZE  # dimensions too large\n                or len(image_data) > MAX_EMOJI_GIF_FILE_SIZE_BYTES  # filesize too large\n            )\n\n            # Generate a still image from the first frame.  Since\n            # we're converting the format to PNG anyway, we resize unconditionally.\n            still_image = im.copy()\n            still_image.seek(0)\n            still_image = ImageOps.exif_transpose(still_image)\n            still_image = ImageOps.fit(still_image, (size, size), Image.ANTIALIAS)\n            out = io.BytesIO()\n            still_image.save(out, format=\"PNG\")\n            still_image_data = out.getvalue()\n\n            if should_resize:\n                image_data = resize_animated(im, size)\n\n            return image_data, True, still_image_data\n        else:\n            # Note that this is essentially duplicated in the\n            # still_image code path, above.\n            im = ImageOps.exif_transpose(im)\n            im = ImageOps.fit(im, (size, size), Image.ANTIALIAS)\n            out = io.BytesIO()\n            im.save(out, format=image_format)\n            return out.getvalue(), False, None\n    except OSError:\n        raise BadImageError(_(\"Could not decode image; did you upload an image file?\"))\n    except DecompressionBombError:\n        raise BadImageError(_(\"Image size exceeds limit.\"))\n\n\n### Common\n\n\nclass ZulipUploadBackend:\n    def get_public_upload_root_url(self) -> str:\n        raise NotImplementedError()\n\n    def generate_message_upload_path(self, realm_id: str, uploaded_file_name: str) -> str:\n        raise NotImplementedError()\n\n    def upload_message_file(\n        self,\n        uploaded_file_name: str,\n        uploaded_file_size: int,\n        content_type: Optional[str],\n        file_data: bytes,\n        user_profile: UserProfile,\n        target_realm: Optional[Realm] = None,\n    ) -> str:\n        raise NotImplementedError()\n\n    def upload_avatar_image(\n        self,\n        user_file: IO[bytes],\n        acting_user_profile: UserProfile,\n        target_user_profile: UserProfile,\n        content_type: Optional[str] = None,\n    ) -> None:\n        raise NotImplementedError()\n\n    def delete_avatar_image(self, user: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def delete_message_image(self, path_id: str) -> bool:\n        raise NotImplementedError()\n\n    def get_avatar_url(self, hash_key: str, medium: bool = False) -> str:\n        raise NotImplementedError()\n\n    def copy_avatar(self, source_profile: UserProfile, target_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def ensure_avatar_image(self, user_profile: UserProfile, is_medium: bool = False) -> None:\n        raise NotImplementedError()\n\n    def upload_realm_icon_image(self, icon_file: IO[bytes], user_profile: UserProfile) -> None:\n        raise NotImplementedError()\n\n    def get_realm_icon_url(self, realm_id: int, version: int) -> str:\n        raise NotImplementedError()\n\n    def upload_realm_logo_image(\n        self, logo_file: IO[bytes], user_profile: UserProfile, night: bool\n    ) -> None:\n        raise NotImplementedError()\n\n    def get_realm_logo_url(self, realm_id: int, version: int, night: bool) -> str:\n        raise NotImplementedError()\n\n    def upload_emoji_image(\n        self, emoji_file: IO[bytes], emoji_file_name: str, user_profile: UserProfile\n    ) -> bool:\n        raise NotImplementedError()\n\n    def get_emoji_url(self, emoji_file_name: str, realm_id: int, still: bool = False) -> str:\n        raise NotImplementedError()\n\n    def upload_export_tarball(\n        self,\n        realm: Realm,\n        tarball_path: str,\n        percent_callback: Optional[Callable[[Any], None]] = None,\n    ) -> str:\n        raise NotImplementedError()\n\n    def delete_export_tarball(self, export_path: str) -> Optional[str]:\n        raise NotImplementedError()\n\n    def get_export_tarball_url(self, realm: Realm, export_path: str) -> str:\n        raise NotImplementedError()\n\n    def realm_avatar_and_logo_path(self, realm: Realm) -> str:\n        raise NotImplementedError()\n\n\n### S3\n\n\ndef get_bucket(bucket_name: str, session: Optional[Session] = None) -> Bucket:\n    if session is None:\n        session = boto3.Session(settings.S3_KEY, settings.S3_SECRET_KEY)\n    bucket = session.resource(\n        \"s3\", region_name=settings.S3_REGION, endpoint_url=settings.S3_ENDPOINT_URL\n    ).Bucket(bucket_name)\n    return bucket\n\n\ndef upload_image_to_s3(\n    bucket: Bucket,\n    file_name: str,\n    content_type: Optional[str],\n    user_profile: UserProfile,\n    contents: bytes,\n) -> None:\n    key = bucket.Object(file_name)\n    metadata = {\n        \"user_profile_id\": str(user_profile.id),\n        \"realm_id\": str(user_profile.realm_id),\n    }\n\n    content_disposition = \"\"\n    if content_type is None:\n        content_type = \"\"\n    if content_type not in INLINE_MIME_TYPES:\n        content_disposition = \"attachment\"\n\n    key.put(\n        Body=contents,\n        Metadata=metadata,\n        ContentType=content_type,\n        ContentDisposition=content_disposition,\n    )\n\n\ndef check_upload_within_quota(realm: Realm, uploaded_file_size: int) -> None:\n    upload_quota = realm.upload_quota_bytes()\n    if upload_quota is None:\n        return\n    used_space = realm.currently_used_upload_space_bytes()\n    if (used_space + uploaded_file_size) > upload_quota:\n        raise RealmUploadQuotaError(_(\"Upload would exceed your organization's upload quota.\"))\n\n\ndef get_file_info(request: HttpRequest, user_file: File) -> Tuple[str, int, Optional[str]]:\n\n    uploaded_file_name = user_file.name\n    assert uploaded_file_name is not None\n    content_type = request.GET.get(\"mimetype\")\n    if content_type is None:\n        guessed_type = guess_type(uploaded_file_name)[0]\n        if guessed_type is not None:\n            content_type = guessed_type\n    else:\n        extension = guess_extension(content_type)\n        if extension is not None:\n            uploaded_file_name = uploaded_file_name + extension\n\n    uploaded_file_name = urllib.parse.unquote(uploaded_file_name)\n    uploaded_file_size = user_file.size\n\n    return uploaded_file_name, uploaded_file_size, content_type\n\n\ndef get_signed_upload_url(path: str, download: bool = False) -> str:\n    client = boto3.client(\n        \"s3\",\n        aws_access_key_id=settings.S3_KEY,\n        aws_secret_access_key=settings.S3_SECRET_KEY,\n        region_name=settings.S3_REGION,\n        endpoint_url=settings.S3_ENDPOINT_URL,\n    )\n    params = {\n        \"Bucket\": settings.S3_AUTH_UPLOADS_BUCKET,\n        \"Key\": path,\n    }\n    if download:\n        params[\"ResponseContentDisposition\"] = \"attachment\"\n\n    return client.generate_presigned_url(\n        ClientMethod=\"get_object\",\n        Params=params,\n        ExpiresIn=SIGNED_UPLOAD_URL_DURATION,\n        HttpMethod=\"GET\",\n    )\n\n\nclass S3UploadBackend(ZulipUploadBackend):\n    def __init__(self) -> None:\n        self.session = boto3.Session(settings.S3_KEY, settings.S3_SECRET_KEY)\n        self.avatar_bucket = get_bucket(settings.S3_AVATAR_BUCKET, self.session)\n        self.uploads_bucket = get_bucket(settings.S3_AUTH_UPLOADS_BUCKET, self.session)\n\n        self._boto_client: Optional[S3Client] = None\n        self.public_upload_url_base = self.construct_public_upload_url_base()\n\n    def construct_public_upload_url_base(self) -> str:\n        # Return the pattern for public URL for a key in the S3 Avatar bucket.\n        # For Amazon S3 itself, this will return the following:\n        #     f\"https://{self.avatar_bucket.name}.{network_location}/{key}\"\n        #\n        # However, we need this function to properly handle S3 style\n        # file upload backends that Zulip supports, which can have a\n        # different URL format. Configuring no signature and providing\n        # no access key makes `generate_presigned_url` just return the\n        # normal public URL for a key.\n        #\n        # It unfortunately takes 2ms per query to call\n        # generate_presigned_url, even with our cached boto\n        # client. Since we need to potentially compute hundreds of\n        # avatar URLs in single `GET /messages` request, we instead\n        # back-compute the URL pattern here.\n\n        DUMMY_KEY = \"dummy_key_ignored\"\n        foo_url = self.get_boto_client().generate_presigned_url(\n            ClientMethod=\"get_object\",\n            Params={\n                \"Bucket\": self.avatar_bucket.name,\n                \"Key\": DUMMY_KEY,\n            },\n            ExpiresIn=0,\n        )\n        split_url = urllib.parse.urlsplit(foo_url)\n        assert split_url.path.endswith(f\"/{DUMMY_KEY}\")\n\n        return urllib.parse.urlunsplit(\n            (split_url.scheme, split_url.netloc, split_url.path[: -len(DUMMY_KEY)], \"\", \"\")\n        )\n\n    def get_public_upload_url(\n        self,\n        key: str,\n    ) -> str:\n        assert not key.startswith(\"/\")\n        return urllib.parse.urljoin(self.public_upload_url_base, key)\n\n    def get_boto_client(self) -> S3Client:\n        \"\"\"\n        Creating the client takes a long time so we need to cache it.\n        \"\"\"\n        if self._boto_client is None:\n            config = Config(signature_version=botocore.UNSIGNED)\n            self._boto_client = self.session.client(\n                \"s3\",\n                region_name=settings.S3_REGION,\n                endpoint_url=settings.S3_ENDPOINT_URL,\n                config=config,\n            )\n        return self._boto_client\n\n    def delete_file_from_s3(self, path_id: str, bucket: Bucket) -> bool:\n        key = bucket.Object(path_id)\n\n        try:\n            key.load()\n        except botocore.exceptions.ClientError:\n            file_name = path_id.split(\"/\")[-1]\n            logging.warning(\n                \"%s does not exist. Its entry in the database will be removed.\", file_name\n            )\n            return False\n        key.delete()\n        return True\n\n    def get_public_upload_root_url(self) -> str:\n        return self.public_upload_url_base\n\n    def generate_message_upload_path(self, realm_id: str, uploaded_file_name: str) -> str:\n        return \"/\".join(\n            [\n                realm_id,\n                secrets.token_urlsafe(18),\n                sanitize_name(uploaded_file_name),\n            ]\n        )\n\n    def upload_message_file(\n        self,\n        uploaded_file_name: str,\n        uploaded_file_size: int,\n        content_type: Optional[str],\n        file_data: bytes,\n        user_profile: UserProfile,\n        target_realm: Optional[Realm] = None,\n    ) -> str:\n        if target_realm is None:\n            target_realm = user_profile.realm\n        s3_file_name = self.generate_message_upload_path(str(target_realm.id), uploaded_file_name)\n        url = f\"/user_uploads/{s3_file_name}\"\n\n        upload_image_to_s3(\n            self.uploads_bucket,\n            s3_file_name,\n            content_type,\n            user_profile,\n            file_data,\n        )\n\n        create_attachment(\n            uploaded_file_name, s3_file_name, user_profile, target_realm, uploaded_file_size\n        )\n        return url\n\n    def delete_message_image(self, path_id: str) -> bool:\n        return self.delete_file_from_s3(path_id, self.uploads_bucket)\n\n    def write_avatar_images(\n        self,\n        s3_file_name: str,\n        target_user_profile: UserProfile,\n        image_data: bytes,\n        content_type: Optional[str],\n    ) -> None:\n        upload_image_to_s3(\n            self.avatar_bucket,\n            s3_file_name + \".original\",\n            content_type,\n            target_user_profile,\n            image_data,\n        )\n\n        # custom 500px wide version\n        resized_medium = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)\n        upload_image_to_s3(\n            self.avatar_bucket,\n            s3_file_name + \"-medium.png\",\n            \"image/png\",\n            target_user_profile,\n            resized_medium,\n        )\n\n        resized_data = resize_avatar(image_data)\n        upload_image_to_s3(\n            self.avatar_bucket,\n            s3_file_name,\n            \"image/png\",\n            target_user_profile,\n            resized_data,\n        )\n        # See avatar_url in avatar.py for URL.  (That code also handles the case\n        # that users use gravatar.)\n\n    def upload_avatar_image(\n        self,\n        user_file: IO[bytes],\n        acting_user_profile: UserProfile,\n        target_user_profile: UserProfile,\n        content_type: Optional[str] = None,\n    ) -> None:\n        if content_type is None:\n            content_type = guess_type(user_file.name)[0]\n        s3_file_name = user_avatar_path(target_user_profile)\n\n        image_data = user_file.read()\n        self.write_avatar_images(s3_file_name, target_user_profile, image_data, content_type)\n\n    def delete_avatar_image(self, user: UserProfile) -> None:\n        path_id = user_avatar_path(user)\n\n        self.delete_file_from_s3(path_id + \".original\", self.avatar_bucket)\n        self.delete_file_from_s3(path_id + \"-medium.png\", self.avatar_bucket)\n        self.delete_file_from_s3(path_id, self.avatar_bucket)\n\n    def get_avatar_key(self, file_name: str) -> Object:\n        key = self.avatar_bucket.Object(file_name)\n        return key\n\n    def copy_avatar(self, source_profile: UserProfile, target_profile: UserProfile) -> None:\n        s3_source_file_name = user_avatar_path(source_profile)\n        s3_target_file_name = user_avatar_path(target_profile)\n\n        key = self.get_avatar_key(s3_source_file_name + \".original\")\n        image_data = key.get()[\"Body\"].read()\n        content_type = key.content_type\n\n        self.write_avatar_images(s3_target_file_name, target_profile, image_data, content_type)\n\n    def get_avatar_url(self, hash_key: str, medium: bool = False) -> str:\n        medium_suffix = \"-medium.png\" if medium else \"\"\n        return self.get_public_upload_url(f\"{hash_key}{medium_suffix}\")\n\n    def get_export_tarball_url(self, realm: Realm, export_path: str) -> str:\n        # export_path has a leading /\n        return self.get_public_upload_url(export_path[1:])\n\n    def realm_avatar_and_logo_path(self, realm: Realm) -> str:\n        return os.path.join(str(realm.id), \"realm\")\n\n    def upload_realm_icon_image(self, icon_file: IO[bytes], user_profile: UserProfile) -> None:\n        content_type = guess_type(icon_file.name)[0]\n        s3_file_name = os.path.join(self.realm_avatar_and_logo_path(user_profile.realm), \"icon\")\n\n        image_data = icon_file.read()\n        upload_image_to_s3(\n            self.avatar_bucket,\n            s3_file_name + \".original\",\n            content_type,\n            user_profile,\n            image_data,\n        )\n\n        resized_data = resize_avatar(image_data)\n        upload_image_to_s3(\n            self.avatar_bucket,\n            s3_file_name + \".png\",\n            \"image/png\",\n            user_profile,\n            resized_data,\n        )\n        # See avatar_url in avatar.py for URL.  (That code also handles the case\n        # that users use gravatar.)\n\n    def get_realm_icon_url(self, realm_id: int, version: int) -> str:\n        public_url = self.get_public_upload_url(f\"{realm_id}/realm/icon.png\")\n        return public_url + f\"?version={version}\"\n\n    def upload_realm_logo_image(\n        self, logo_file: IO[bytes], user_profile: UserProfile, night: bool\n    ) -> None:\n        content_type = guess_type(logo_file.name)[0]\n        if night:\n            basename = \"night_logo\"\n        else:\n            basename = \"logo\"\n        s3_file_name = os.path.join(self.realm_avatar_and_logo_path(user_profile.realm), basename)\n\n        image_data = logo_file.read()\n        upload_image_to_s3(\n            self.avatar_bucket,\n            s3_file_name + \".original\",\n            content_type,\n            user_profile,\n            image_data,\n        )\n\n        resized_data = resize_logo(image_data)\n        upload_image_to_s3(\n            self.avatar_bucket,\n            s3_file_name + \".png\",\n            \"image/png\",\n            user_profile,\n            resized_data,\n        )\n        # See avatar_url in avatar.py for URL.  (That code also handles the case\n        # that users use gravatar.)\n\n    def get_realm_logo_url(self, realm_id: int, version: int, night: bool) -> str:\n        if not night:\n            file_name = \"logo.png\"\n        else:\n            file_name = \"night_logo.png\"\n        public_url = self.get_public_upload_url(f\"{realm_id}/realm/{file_name}\")\n        return public_url + f\"?version={version}\"\n\n    def ensure_avatar_image(self, user_profile: UserProfile, is_medium: bool = False) -> None:\n        # BUG: The else case should be user_avatar_path(user_profile) + \".png\".\n        # See #12852 for details on this bug and how to migrate it.\n        file_extension = \"-medium.png\" if is_medium else \"\"\n        file_path = user_avatar_path(user_profile)\n        s3_file_name = file_path\n\n        key = self.avatar_bucket.Object(file_path + \".original\")\n        image_data = key.get()[\"Body\"].read()\n\n        if is_medium:\n            resized_avatar = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)\n        else:\n            resized_avatar = resize_avatar(image_data)\n        upload_image_to_s3(\n            self.avatar_bucket,\n            s3_file_name + file_extension,\n            \"image/png\",\n            user_profile,\n            resized_avatar,\n        )\n\n    def upload_emoji_image(\n        self, emoji_file: IO[bytes], emoji_file_name: str, user_profile: UserProfile\n    ) -> bool:\n        content_type = guess_type(emoji_file_name)[0]\n        emoji_path = RealmEmoji.PATH_ID_TEMPLATE.format(\n            realm_id=user_profile.realm_id,\n            emoji_file_name=emoji_file_name,\n        )\n\n        image_data = emoji_file.read()\n        upload_image_to_s3(\n            self.avatar_bucket,\n            \".\".join((emoji_path, \"original\")),\n            content_type,\n            user_profile,\n            image_data,\n        )\n\n        resized_image_data, is_animated, still_image_data = resize_emoji(image_data)\n        upload_image_to_s3(\n            self.avatar_bucket,\n            emoji_path,\n            content_type,\n            user_profile,\n            resized_image_data,\n        )\n        if is_animated:\n            still_path = RealmEmoji.STILL_PATH_ID_TEMPLATE.format(\n                realm_id=user_profile.realm_id,\n                emoji_filename_without_extension=os.path.splitext(emoji_file_name)[0],\n            )\n            assert still_image_data is not None\n            upload_image_to_s3(\n                self.avatar_bucket,\n                still_path,\n                \"image/png\",\n                user_profile,\n                still_image_data,\n            )\n\n        return is_animated\n\n    def get_emoji_url(self, emoji_file_name: str, realm_id: int, still: bool = False) -> str:\n        if still:\n            emoji_path = RealmEmoji.STILL_PATH_ID_TEMPLATE.format(\n                realm_id=realm_id,\n                emoji_filename_without_extension=os.path.splitext(emoji_file_name)[0],\n            )\n            return self.get_public_upload_url(emoji_path)\n        else:\n            emoji_path = RealmEmoji.PATH_ID_TEMPLATE.format(\n                realm_id=realm_id, emoji_file_name=emoji_file_name\n            )\n            return self.get_public_upload_url(emoji_path)\n\n    def upload_export_tarball(\n        self,\n        realm: Optional[Realm],\n        tarball_path: str,\n        percent_callback: Optional[Callable[[Any], None]] = None,\n    ) -> str:\n        # We use the avatar bucket, because it's world-readable.\n        key = self.avatar_bucket.Object(\n            os.path.join(\"exports\", secrets.token_hex(16), os.path.basename(tarball_path))\n        )\n\n        if percent_callback is None:\n            key.upload_file(Filename=tarball_path)\n        else:\n            key.upload_file(Filename=tarball_path, Callback=percent_callback)\n\n        public_url = self.get_public_upload_url(key.key)\n        return public_url\n\n    def delete_export_tarball(self, export_path: str) -> Optional[str]:\n        assert export_path.startswith(\"/\")\n        path_id = export_path[1:]\n        if self.delete_file_from_s3(path_id, self.avatar_bucket):\n            return export_path\n        return None\n\n\n### Local\n\n\ndef write_local_file(type: str, path: str, file_data: bytes) -> None:\n    file_path = os.path.join(assert_is_not_none(settings.LOCAL_UPLOADS_DIR), type, path)\n\n    os.makedirs(os.path.dirname(file_path), exist_ok=True)\n    with open(file_path, \"wb\") as f:\n        f.write(file_data)\n\n\ndef read_local_file(type: str, path: str) -> bytes:\n    file_path = os.path.join(assert_is_not_none(settings.LOCAL_UPLOADS_DIR), type, path)\n    with open(file_path, \"rb\") as f:\n        return f.read()\n\n\ndef delete_local_file(type: str, path: str) -> bool:\n    file_path = os.path.join(assert_is_not_none(settings.LOCAL_UPLOADS_DIR), type, path)\n    if os.path.isfile(file_path):\n        # This removes the file but the empty folders still remain.\n        os.remove(file_path)\n        return True\n    file_name = path.split(\"/\")[-1]\n    logging.warning(\"%s does not exist. Its entry in the database will be removed.\", file_name)\n    return False\n\n\ndef get_local_file_path(path_id: str) -> Optional[str]:\n    local_path = os.path.join(assert_is_not_none(settings.LOCAL_UPLOADS_DIR), \"files\", path_id)\n    if os.path.isfile(local_path):\n        return local_path\n    else:\n        return None\n\n\nLOCAL_FILE_ACCESS_TOKEN_SALT = \"local_file_\"\n\n\ndef generate_unauthed_file_access_url(path_id: str) -> str:\n    signed_data = TimestampSigner(salt=LOCAL_FILE_ACCESS_TOKEN_SALT).sign(path_id)\n    token = base64.b16encode(signed_data.encode()).decode()\n\n    filename = path_id.split(\"/\")[-1]\n    return reverse(\"local_file_unauthed\", args=[token, filename])\n\n\ndef get_local_file_path_id_from_token(token: str) -> Optional[str]:\n    signer = TimestampSigner(salt=LOCAL_FILE_ACCESS_TOKEN_SALT)\n    try:\n        signed_data = base64.b16decode(token).decode()\n        path_id = signer.unsign(signed_data, max_age=timedelta(seconds=60))\n    except (BadSignature, binascii.Error):\n        return None\n\n    return path_id\n\n\nclass LocalUploadBackend(ZulipUploadBackend):\n    def get_public_upload_root_url(self) -> str:\n        return \"/user_avatars/\"\n\n    def generate_message_upload_path(self, realm_id: str, uploaded_file_name: str) -> str:\n        # Split into 256 subdirectories to prevent directories from getting too big\n        return \"/\".join(\n            [\n                realm_id,\n                format(random.randint(0, 255), \"x\"),\n                secrets.token_urlsafe(18),\n                sanitize_name(uploaded_file_name),\n            ]\n        )\n\n    def upload_message_file(\n        self,\n        uploaded_file_name: str,\n        uploaded_file_size: int,\n        content_type: Optional[str],\n        file_data: bytes,\n        user_profile: UserProfile,\n        target_realm: Optional[Realm] = None,\n    ) -> str:\n        if target_realm is None:\n            target_realm = user_profile.realm\n\n        path = self.generate_message_upload_path(str(target_realm.id), uploaded_file_name)\n\n        write_local_file(\"files\", path, file_data)\n        create_attachment(uploaded_file_name, path, user_profile, target_realm, uploaded_file_size)\n        return \"/user_uploads/\" + path\n\n    def delete_message_image(self, path_id: str) -> bool:\n        return delete_local_file(\"files\", path_id)\n\n    def write_avatar_images(self, file_path: str, image_data: bytes) -> None:\n        write_local_file(\"avatars\", file_path + \".original\", image_data)\n\n        resized_data = resize_avatar(image_data)\n        write_local_file(\"avatars\", file_path + \".png\", resized_data)\n\n        resized_medium = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)\n        write_local_file(\"avatars\", file_path + \"-medium.png\", resized_medium)\n\n    def upload_avatar_image(\n        self,\n        user_file: IO[bytes],\n        acting_user_profile: UserProfile,\n        target_user_profile: UserProfile,\n        content_type: Optional[str] = None,\n    ) -> None:\n        file_path = user_avatar_path(target_user_profile)\n\n        image_data = user_file.read()\n        self.write_avatar_images(file_path, image_data)\n\n    def delete_avatar_image(self, user: UserProfile) -> None:\n        path_id = user_avatar_path(user)\n\n        delete_local_file(\"avatars\", path_id + \".original\")\n        delete_local_file(\"avatars\", path_id + \".png\")\n        delete_local_file(\"avatars\", path_id + \"-medium.png\")\n\n    def get_avatar_url(self, hash_key: str, medium: bool = False) -> str:\n        medium_suffix = \"-medium\" if medium else \"\"\n        return f\"/user_avatars/{hash_key}{medium_suffix}.png\"\n\n    def copy_avatar(self, source_profile: UserProfile, target_profile: UserProfile) -> None:\n        source_file_path = user_avatar_path(source_profile)\n        target_file_path = user_avatar_path(target_profile)\n\n        image_data = read_local_file(\"avatars\", source_file_path + \".original\")\n        self.write_avatar_images(target_file_path, image_data)\n\n    def realm_avatar_and_logo_path(self, realm: Realm) -> str:\n        return os.path.join(\"avatars\", str(realm.id), \"realm\")\n\n    def upload_realm_icon_image(self, icon_file: IO[bytes], user_profile: UserProfile) -> None:\n        upload_path = self.realm_avatar_and_logo_path(user_profile.realm)\n        image_data = icon_file.read()\n        write_local_file(upload_path, \"icon.original\", image_data)\n\n        resized_data = resize_avatar(image_data)\n        write_local_file(upload_path, \"icon.png\", resized_data)\n\n    def get_realm_icon_url(self, realm_id: int, version: int) -> str:\n        return f\"/user_avatars/{realm_id}/realm/icon.png?version={version}\"\n\n    def upload_realm_logo_image(\n        self, logo_file: IO[bytes], user_profile: UserProfile, night: bool\n    ) -> None:\n        upload_path = self.realm_avatar_and_logo_path(user_profile.realm)\n        if night:\n            original_file = \"night_logo.original\"\n            resized_file = \"night_logo.png\"\n        else:\n            original_file = \"logo.original\"\n            resized_file = \"logo.png\"\n        image_data = logo_file.read()\n        write_local_file(upload_path, original_file, image_data)\n\n        resized_data = resize_logo(image_data)\n        write_local_file(upload_path, resized_file, resized_data)\n\n    def get_realm_logo_url(self, realm_id: int, version: int, night: bool) -> str:\n        if night:\n            file_name = \"night_logo.png\"\n        else:\n            file_name = \"logo.png\"\n        return f\"/user_avatars/{realm_id}/realm/{file_name}?version={version}\"\n\n    def ensure_avatar_image(self, user_profile: UserProfile, is_medium: bool = False) -> None:\n        file_extension = \"-medium.png\" if is_medium else \".png\"\n        file_path = user_avatar_path(user_profile)\n\n        output_path = os.path.join(\n            assert_is_not_none(settings.LOCAL_UPLOADS_DIR),\n            \"avatars\",\n            file_path + file_extension,\n        )\n        if os.path.isfile(output_path):\n            return\n\n        image_path = os.path.join(\n            assert_is_not_none(settings.LOCAL_UPLOADS_DIR), \"avatars\", file_path + \".original\"\n        )\n        with open(image_path, \"rb\") as f:\n            image_data = f.read()\n        if is_medium:\n            resized_avatar = resize_avatar(image_data, MEDIUM_AVATAR_SIZE)\n        else:\n            resized_avatar = resize_avatar(image_data)\n        write_local_file(\"avatars\", file_path + file_extension, resized_avatar)\n\n    def upload_emoji_image(\n        self, emoji_file: IO[bytes], emoji_file_name: str, user_profile: UserProfile\n    ) -> bool:\n        emoji_path = RealmEmoji.PATH_ID_TEMPLATE.format(\n            realm_id=user_profile.realm_id,\n            emoji_file_name=emoji_file_name,\n        )\n\n        image_data = emoji_file.read()\n        write_local_file(\"avatars\", \".\".join((emoji_path, \"original\")), image_data)\n        resized_image_data, is_animated, still_image_data = resize_emoji(image_data)\n        write_local_file(\"avatars\", emoji_path, resized_image_data)\n        if is_animated:\n            assert still_image_data is not None\n            still_path = RealmEmoji.STILL_PATH_ID_TEMPLATE.format(\n                realm_id=user_profile.realm_id,\n                emoji_filename_without_extension=os.path.splitext(emoji_file_name)[0],\n            )\n            write_local_file(\"avatars\", still_path, still_image_data)\n        return is_animated\n\n    def get_emoji_url(self, emoji_file_name: str, realm_id: int, still: bool = False) -> str:\n        if still:\n            return os.path.join(\n                \"/user_avatars\",\n                RealmEmoji.STILL_PATH_ID_TEMPLATE.format(\n                    realm_id=realm_id,\n                    emoji_filename_without_extension=os.path.splitext(emoji_file_name)[0],\n                ),\n            )\n        else:\n            return os.path.join(\n                \"/user_avatars\",\n                RealmEmoji.PATH_ID_TEMPLATE.format(\n                    realm_id=realm_id, emoji_file_name=emoji_file_name\n                ),\n            )\n\n    def upload_export_tarball(\n        self,\n        realm: Realm,\n        tarball_path: str,\n        percent_callback: Optional[Callable[[Any], None]] = None,\n    ) -> str:\n        path = os.path.join(\n            \"exports\",\n            str(realm.id),\n            secrets.token_urlsafe(18),\n            os.path.basename(tarball_path),\n        )\n        abs_path = os.path.join(assert_is_not_none(settings.LOCAL_UPLOADS_DIR), \"avatars\", path)\n        os.makedirs(os.path.dirname(abs_path), exist_ok=True)\n        shutil.copy(tarball_path, abs_path)\n        public_url = realm.uri + \"/user_avatars/\" + path\n        return public_url\n\n    def delete_export_tarball(self, export_path: str) -> Optional[str]:\n        # Get the last element of a list in the form ['user_avatars', '<file_path>']\n        assert export_path.startswith(\"/\")\n        file_path = export_path[1:].split(\"/\", 1)[-1]\n        if delete_local_file(\"avatars\", file_path):\n            return export_path\n        return None\n\n    def get_export_tarball_url(self, realm: Realm, export_path: str) -> str:\n        # export_path has a leading `/`\n        return realm.uri + export_path\n\n\n# Common and wrappers\nif settings.LOCAL_UPLOADS_DIR is not None:\n    upload_backend: ZulipUploadBackend = LocalUploadBackend()\nelse:\n    upload_backend = S3UploadBackend()  # nocoverage\n\n\ndef get_public_upload_root_url() -> str:\n    return upload_backend.get_public_upload_root_url()\n\n\ndef delete_message_image(path_id: str) -> bool:\n    return upload_backend.delete_message_image(path_id)\n\n\ndef upload_avatar_image(\n    user_file: IO[bytes],\n    acting_user_profile: UserProfile,\n    target_user_profile: UserProfile,\n    content_type: Optional[str] = None,\n) -> None:\n    upload_backend.upload_avatar_image(\n        user_file, acting_user_profile, target_user_profile, content_type=content_type\n    )\n\n\ndef delete_avatar_image(user_profile: UserProfile) -> None:\n    upload_backend.delete_avatar_image(user_profile)\n\n\ndef copy_avatar(source_profile: UserProfile, target_profile: UserProfile) -> None:\n    upload_backend.copy_avatar(source_profile, target_profile)\n\n\ndef upload_icon_image(user_file: IO[bytes], user_profile: UserProfile) -> None:\n    upload_backend.upload_realm_icon_image(user_file, user_profile)\n\n\ndef upload_logo_image(user_file: IO[bytes], user_profile: UserProfile, night: bool) -> None:\n    upload_backend.upload_realm_logo_image(user_file, user_profile, night)\n\n\ndef upload_emoji_image(\n    emoji_file: IO[bytes], emoji_file_name: str, user_profile: UserProfile\n) -> bool:\n    return upload_backend.upload_emoji_image(emoji_file, emoji_file_name, user_profile)\n\n\ndef upload_message_file(\n    uploaded_file_name: str,\n    uploaded_file_size: int,\n    content_type: Optional[str],\n    file_data: bytes,\n    user_profile: UserProfile,\n    target_realm: Optional[Realm] = None,\n) -> str:\n    return upload_backend.upload_message_file(\n        uploaded_file_name,\n        uploaded_file_size,\n        content_type,\n        file_data,\n        user_profile,\n        target_realm=target_realm,\n    )\n\n\ndef claim_attachment(\n    user_profile: UserProfile,\n    path_id: str,\n    message: Message,\n    is_message_realm_public: bool,\n    is_message_web_public: bool = False,\n) -> Attachment:\n    attachment = Attachment.objects.get(path_id=path_id)\n    attachment.messages.add(message)\n    attachment.is_web_public = attachment.is_web_public or is_message_web_public\n    attachment.is_realm_public = attachment.is_realm_public or is_message_realm_public\n    attachment.save()\n    return attachment\n\n\ndef create_attachment(\n    file_name: str, path_id: str, user_profile: UserProfile, realm: Realm, file_size: int\n) -> bool:\n    assert (user_profile.realm_id == realm.id) or is_cross_realm_bot_email(\n        user_profile.delivery_email\n    )\n    attachment = Attachment.objects.create(\n        file_name=file_name,\n        path_id=path_id,\n        owner=user_profile,\n        realm=realm,\n        size=file_size,\n    )\n    from zerver.actions.uploads import notify_attachment_update\n\n    notify_attachment_update(user_profile, \"add\", attachment.to_dict())\n    return True\n\n\ndef upload_message_image_from_request(\n    request: HttpRequest, user_file: File, user_profile: UserProfile\n) -> str:\n    uploaded_file_name, uploaded_file_size, content_type = get_file_info(request, user_file)\n    return upload_message_file(\n        uploaded_file_name, uploaded_file_size, content_type, user_file.read(), user_profile\n    )\n\n\ndef upload_export_tarball(\n    realm: Realm, tarball_path: str, percent_callback: Optional[Callable[[Any], None]] = None\n) -> str:\n    return upload_backend.upload_export_tarball(\n        realm, tarball_path, percent_callback=percent_callback\n    )\n\n\ndef delete_export_tarball(export_path: str) -> Optional[str]:\n    return upload_backend.delete_export_tarball(export_path)\n\n\ndef get_emoji_file_content(\n    session: OutgoingSession, emoji_url: str, emoji_id: int, logger: logging.Logger\n) -> bytes:  # nocoverage\n    original_emoji_url = emoji_url + \".original\"\n\n    logger.info(\"Downloading %s\", original_emoji_url)\n    response = session.get(original_emoji_url)\n    if response.status_code == 200:\n        assert type(response.content) == bytes\n        return response.content\n\n    logger.info(\"Error fetching emoji from URL %s\", original_emoji_url)\n    logger.info(\"Trying %s instead\", emoji_url)\n    response = session.get(emoji_url)\n    if response.status_code == 200:\n        assert type(response.content) == bytes\n        return response.content\n    logger.info(\"Error fetching emoji from URL %s\", emoji_url)\n    logger.error(\"Could not fetch emoji %s\", emoji_id)\n    raise AssertionError(f\"Could not fetch emoji {emoji_id}\")\n\n\ndef handle_reupload_emojis_event(realm: Realm, logger: logging.Logger) -> None:  # nocoverage\n    from zerver.lib.emoji import get_emoji_url\n\n    session = OutgoingSession(role=\"reupload_emoji\", timeout=3, max_retries=3)\n\n    query = RealmEmoji.objects.filter(realm=realm).order_by(\"id\")\n\n    for realm_emoji in query:\n        logger.info(\"Processing emoji %s\", realm_emoji.id)\n        emoji_filename = realm_emoji.file_name\n        assert emoji_filename is not None\n        emoji_url = get_emoji_url(emoji_filename, realm_emoji.realm_id)\n        if emoji_url.startswith(\"/\"):\n            emoji_url = urljoin(realm_emoji.realm.uri, emoji_url)\n\n        emoji_file_content = get_emoji_file_content(session, emoji_url, realm_emoji.id, logger)\n\n        emoji_bytes_io = io.BytesIO(emoji_file_content)\n\n        user_profile = realm_emoji.author\n        # When this runs, emojis have already been migrated to always have .author set.\n        assert user_profile is not None\n\n        logger.info(\"Reuploading emoji %s\", realm_emoji.id)\n        realm_emoji.is_animated = upload_emoji_image(emoji_bytes_io, emoji_filename, user_profile)\n        realm_emoji.save(update_fields=[\"is_animated\"])\n"}}