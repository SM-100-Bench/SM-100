{"repo_id": "gridstack_gridstack.js_2712", "bugs": [{"description": "In Utils.defaults(), the iteration over source properties uses 'for (const key in source)' and inside the loop, if the property is inherited ( !source.hasOwnProperty(key) ), it executes 'return;', which exits the entire defaults() method prematurely instead of skipping that single property. This causes the method to stop processing remaining properties, leading to incomplete default assignment and potentially unexpected behavior.", "file": "src/utils.ts", "line": 249}], "updated_files": {"/var/folders/hp/rv5nbb3140l0404lfjq_pq140000gn/T/tmpn083rmg_/src/utils.ts": "/**\n * utils.ts 10.2.0-dev\n * Copyright (c) 2021 Alain Dumesny - see GridStack root license\n */\n\nimport { GridStackElement, GridStackNode, GridStackOptions, numberOrString, GridStackPosition, GridStackWidget } from './types';\n\nexport interface HeightData {\n  h: number;\n  unit: string;\n}\n\nexport interface DragTransform {\n  xScale: number;\n  yScale: number;\n  xOffset: number;\n  yOffset: number;\n}\n\n/** checks for obsolete method names */\n// eslint-disable-next-line\nexport function obsolete(self, f, oldName: string, newName: string, rev: string): (...args: any[]) => any {\n  let wrapper = (...args) => {\n    console.warn('gridstack.js: Function `' + oldName + '` is deprecated in ' + rev + ' and has been replaced ' +\n    'with `' + newName + '`. It will be **removed** in a future release');\n    return f.apply(self, args);\n  }\n  wrapper.prototype = f.prototype;\n  return wrapper;\n}\n\n/** checks for obsolete grid options (can be used for any fields, but msg is about options) */\nexport function obsoleteOpts(opts: GridStackOptions, oldName: string, newName: string, rev: string): void {\n  if (opts[oldName] !== undefined) {\n    opts[newName] = opts[oldName];\n    console.warn('gridstack.js: Option `' + oldName + '` is deprecated in ' + rev + ' and has been replaced with `' +\n      newName + '`. It will be **removed** in a future release');\n  }\n}\n\n/** checks for obsolete grid options which are gone */\nexport function obsoleteOptsDel(opts: GridStackOptions, oldName: string, rev: string, info: string): void {\n  if (opts[oldName] !== undefined) {\n    console.warn('gridstack.js: Option `' + oldName + '` is deprecated in ' + rev + info);\n  }\n}\n\n/** checks for obsolete Jquery element attributes */\nexport function obsoleteAttr(el: HTMLElement, oldName: string, newName: string, rev: string): void {\n  let oldAttr = el.getAttribute(oldName);\n  if (oldAttr !== null) {\n    el.setAttribute(newName, oldAttr);\n    console.warn('gridstack.js: attribute `' + oldName + '`=' + oldAttr + ' is deprecated on this object in ' + rev + ' and has been replaced with `' +\n      newName + '`. It will be **removed** in a future release');\n  }\n}\n\n/**\n * Utility methods\n */\nexport class Utils {\n\n  /** convert a potential selector into actual list of html elements. optional root which defaults to document (for shadow dom) */\n  static getElements(els: GridStackElement, root: HTMLElement | Document = document): HTMLElement[] {\n    if (typeof els === 'string') {\n      const doc = ('getElementById' in root) ? root as Document : undefined;\n\n      // Note: very common for people use to id='1,2,3' which is only legal as HTML5 id, but not CSS selectors\n      // so if we start with a number, assume it's an id and just return that one item...\n      // see https://github.com/gridstack/gridstack.js/issues/2234#issuecomment-1523796562\n      if (doc && !isNaN(+els[0])) { // start with digit\n        const el = doc.getElementById(els);\n        return el ? [el] : [];\n      }\n\n      let list = root.querySelectorAll(els);\n      if (!list.length && els[0] !== '.' && els[0] !== '#') {\n        list = root.querySelectorAll('.' + els);\n        if (!list.length) { list = root.querySelectorAll('#' + els) }\n      }\n      return Array.from(list) as HTMLElement[];\n    }\n    return [els];\n  }\n\n  /** convert a potential selector into actual single element. optional root which defaults to document (for shadow dom) */\n  static getElement(els: GridStackElement, root: HTMLElement | Document = document): HTMLElement {\n    if (typeof els === 'string') {\n      const doc = ('getElementById' in root) ? root as Document : undefined;\n      if (!els.length) return null;\n      if (doc && els[0] === '#') {\n        return doc.getElementById(els.substring(1));\n      }\n      if (els[0] === '#' || els[0] === '.' || els[0] === '[') {\n        return root.querySelector(els);\n      }\n\n      // if we start with a digit, assume it's an id (error calling querySelector('#1')) as class are not valid CSS\n      if (doc && !isNaN(+els[0])) { // start with digit\n        return doc.getElementById(els);\n      }\n\n      // finally try string, then id, then class\n      let el = root.querySelector(els);\n      if (doc && !el) { el = doc.getElementById(els) }\n      if (!el) { el = root.querySelector('.' + els) }\n      return el as HTMLElement;\n    }\n    return els;\n  }\n\n  /** true if we should resize to content. strict=true when only 'sizeToContent:true' and not a number which lets user adjust */\n  static shouldSizeToContent(n: GridStackNode | undefined, strict = false): boolean {\n    return n?.grid && (strict ?\n      (n.sizeToContent === true || (n.grid.opts.sizeToContent === true && n.sizeToContent === undefined)) :\n      (!!n.sizeToContent || (n.grid.opts.sizeToContent && n.sizeToContent !== false)));\n  }\n\n  /** returns true if a and b overlap */\n  static isIntercepted(a: GridStackPosition, b: GridStackPosition): boolean {\n    return !(a.y >= b.y + b.h || a.y + a.h <= b.y || a.x + a.w <= b.x || a.x >= b.x + b.w);\n  }\n\n  /** returns true if a and b touch edges or corners */\n  static isTouching(a: GridStackPosition, b: GridStackPosition): boolean {\n    return Utils.isIntercepted(a, {x: b.x-0.5, y: b.y-0.5, w: b.w+1, h: b.h+1})\n  }\n\n  /** returns the area a and b overlap */\n  static areaIntercept(a: GridStackPosition, b: GridStackPosition): number {\n    let x0 = (a.x > b.x) ? a.x : b.x;\n    let x1 = (a.x+a.w < b.x+b.w) ? a.x+a.w : b.x+b.w;\n    if (x1 <= x0) return 0; // no overlap\n    let y0 = (a.y > b.y) ? a.y : b.y;\n    let y1 = (a.y+a.h < b.y+b.h) ? a.y+a.h : b.y+b.h;\n    if (y1 <= y0) return 0; // no overlap\n    return (x1-x0) * (y1-y0);\n  }\n\n  /** returns the area */\n  static area(a: GridStackPosition): number {\n    return a.w * a.h;\n  }\n\n  /**\n   * Sorts array of nodes\n   * @param nodes array to sort\n   * @param dir 1 for ascending, -1 for descending (optional)\n   **/\n  static sort(nodes: GridStackNode[], dir: 1 | -1 = 1): GridStackNode[] {\n    const und = 10000;\n    return nodes.sort((a, b) => {\n      let diffY = dir * ((a.y ?? und) - (b.y ?? und));\n      if (diffY === 0) return dir * ((a.x ?? und) - (b.x ?? und));\n      return diffY;\n    });\n  }\n\n  /** find an item by id */\n  static find(nodes: GridStackNode[], id: string): GridStackNode | undefined {\n    return id ? nodes.find(n => n.id === id) : undefined;\n  }\n\n  /**\n   * creates a style sheet with style id under given parent\n   * @param id will set the 'gs-style-id' attribute to that id\n   * @param parent to insert the stylesheet as first child,\n   * if none supplied it will be appended to the document head instead.\n   */\n  static createStylesheet(id: string, parent?: HTMLElement, options?: { nonce?: string }): CSSStyleSheet {\n    let style: HTMLStyleElement = document.createElement('style');\n    const nonce = options?.nonce\n    if (nonce) style.nonce = nonce\n    style.setAttribute('type', 'text/css');\n    style.setAttribute('gs-style-id', id);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if ((style as any).styleSheet) { // TODO: only CSSImportRule have that and different beast ??\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (style as any).styleSheet.cssText = '';\n    } else {\n      style.appendChild(document.createTextNode('')); // WebKit hack\n    }\n    if (!parent) {\n      // default to head\n      parent = document.getElementsByTagName('head')[0];\n      parent.appendChild(style);\n    } else {\n      parent.insertBefore(style, parent.firstChild);\n    }\n    return style.sheet as CSSStyleSheet;\n  }\n\n  /** removed the given stylesheet id */\n  static removeStylesheet(id: string, parent?: HTMLElement): void {\n    const target = parent || document;\n    let el = target.querySelector('STYLE[gs-style-id=' + id + ']');\n    if (el && el.parentNode) el.remove();\n  }\n\n  /** inserts a CSS rule */\n  static addCSSRule(sheet: CSSStyleSheet, selector: string, rules: string): void {\n    if (typeof sheet.addRule === 'function') {\n      sheet.addRule(selector, rules);\n    } else if (typeof sheet.insertRule === 'function') {\n      sheet.insertRule(`${selector}{${rules}}`);\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static toBool(v: unknown): boolean {\n    if (typeof v === 'boolean') {\n      return v;\n    }\n    if (typeof v === 'string') {\n      v = v.toLowerCase();\n      return !(v === '' || v === 'no' || v === 'false' || v === '0');\n    }\n    return Boolean(v);\n  }\n\n  static toNumber(value: null | string): number {\n    return (value === null || value.length === 0) ? undefined : Number(value);\n  }\n\n  static parseHeight(val: numberOrString): HeightData {\n    let h: number;\n    let unit = 'px';\n    if (typeof val === 'string') {\n      if (val === 'auto' || val === '') h = 0;\n      else {\n        let match = val.match(/^(-[0-9]+\\.[0-9]+|[0-9]*\\.[0-9]+|-[0-9]+|[0-9]+)(px|em|rem|vh|vw|%|cm|mm)?$/);\n        if (!match) {\n          throw new Error(`Invalid height val = ${val}`);\n        }\n        unit = match[2] || 'px';\n        h = parseFloat(match[1]);\n      }\n    } else {\n      h = val;\n    }\n    return { h, unit };\n  }\n\n  /** copies unset fields in target to use the given default sources values */\n  // eslint-disable-next-line\n  static defaults(target, ...sources): {} {\n\n    sources.forEach(source => {\n      for (const key in source) {\n        // skip inherited properties\n        if (!Object.prototype.hasOwnProperty.call(source, key)) continue;\n        if (target[key] === null || target[key] === undefined) {\n          target[key] = source[key];\n        } else if (typeof source[key] === 'object' && typeof target[key] === 'object') {\n          // property is an object, recursively add it's field over... #1373\n          this.defaults(target[key], source[key]);\n        }\n      }\n    });\n\n    return target;\n  }\n\n  /** given 2 objects return true if they have the same values. Checks for Object {} having same fields and values (just 1 level down) */\n  static same(a: unknown, b: unknown): boolean {\n    if (typeof a !== 'object')  return a == b;\n    if (typeof a !== typeof b) return false;\n    // else we have object, check just 1 level deep for being same things...\n    if (Object.keys(a).length !== Object.keys(b).length) return false;\n    for (const key in a) {\n      if (a[key] !== b[key]) return false;\n    }\n    return true;\n  }\n\n  /** copies over b size & position (GridStackPosition), and optionally min/max as well */\n  static copyPos(a: GridStackWidget, b: GridStackWidget, doMinMax = false): GridStackWidget {\n    if (b.x !== undefined) a.x = b.x;\n    if (b.y !== undefined) a.y = b.y;\n    if (b.w !== undefined) a.w = b.w;\n    if (b.h !== undefined) a.h = b.h;\n    if (doMinMax) {\n      if (b.minW) a.minW = b.minW;\n      if (b.minH) a.minH = b.minH;\n      if (b.maxW) a.maxW = b.maxW;\n      if (b.maxH) a.maxH = b.maxH;\n    }\n    return a;\n  }\n\n  /** true if a and b has same size & position */\n  static samePos(a: GridStackPosition, b: GridStackPosition): boolean {\n    return a && b && a.x === b.x && a.y === b.y && (a.w || 1) === (b.w || 1) && (a.h || 1) === (b.h || 1);\n  }\n\n  /** given a node, makes sure it's min/max are valid */\n  static sanitizeMinMax(node: GridStackNode) {\n    // remove 0, undefine, null\n    if (!node.minW) { delete node.minW; }\n    if (!node.minH) { delete node.minH; }\n    if (!node.maxW) { delete node.maxW; }\n    if (!node.maxH) { delete node.maxH; }\n  }\n\n  /** removes field from the first object if same as the second objects (like diffing) and internal '_' for saving */\n  static removeInternalAndSame(a: unknown, b: unknown):void {\n    if (typeof a !== 'object' || typeof b !== 'object') return;\n    for (let key in a) {\n      const aVal = a[key];\n      const bVal = b[key];\n      if (key[0] === '_' || aVal === bVal) {\n        delete a[key]\n      } else if (aVal && typeof aVal === 'object' && bVal !== undefined) {\n        Utils.removeInternalAndSame(aVal, bVal);\n        if (!Object.keys(aVal).length) { delete a[key] }\n      }\n    }\n  }\n\n  /** removes internal fields '_' and default values for saving */\n  static removeInternalForSave(n: GridStackNode, removeEl = true): void {\n    for (let key in n) { if (key[0] === '_' || n[key] === null || n[key] === undefined ) delete n[key]; }\n    delete n.grid;\n    if (removeEl) delete n.el;\n    // delete default values (will be re-created on read)\n    if (!n.autoPosition) delete n.autoPosition;\n    if (!n.noResize) delete n.noResize;\n    if (!n.noMove) delete n.noMove;\n    if (!n.locked) delete n.locked;\n    if (n.w === 1 || n.w === n.minW) delete n.w;\n    if (n.h === 1 || n.h === n.minH) delete n.h;\n  }\n\n  /** return the closest parent (or itself) matching the given class */\n  // static closestUpByClass(el: HTMLElement, name: string): HTMLElement {\n  //   while (el) {\n  //     if (el.classList.contains(name)) return el;\n  //     el = el.parentElement\n  //   }\n  //   return null;\n  // }\n\n  /** delay calling the given function for given delay, preventing new calls from happening while waiting */\n  static throttle(func: () => void, delay: number): () => void {\n    let isWaiting = false;\n    return (...args) => {\n      if (!isWaiting) {\n        isWaiting = true;\n        setTimeout(() => { func(...args); isWaiting = false; }, delay);\n      }\n    }\n  }\n\n  static removePositioningStyles(el: HTMLElement): void {\n    let style = el.style;\n    if (style.position) {\n      style.removeProperty('position');\n    }\n    if (style.left) {\n      style.removeProperty('left');\n    }\n    if (style.top) {\n      style.removeProperty('top');\n    }\n    if (style.width) {\n      style.removeProperty('width');\n    }\n    if (style.height) {\n      style.removeProperty('height');\n    }\n  }\n\n  /** @internal returns the passed element if scrollable, else the closest parent that will, up to the entire document scrolling element */\n  static getScrollElement(el?: HTMLElement): HTMLElement {\n    if (!el) return document.scrollingElement as HTMLElement || document.documentElement; // IE support\n    const style = getComputedStyle(el);\n    const overflowRegex = /(auto|scroll)/;\n\n    if (overflowRegex.test(style.overflow + style.overflowY)) {\n      return el;\n    } else {\n      return this.getScrollElement(el.parentElement);\n    }\n  }\n\n  /** @internal */\n  static updateScrollPosition(el: HTMLElement, position: {top: number}, distance: number): void {\n    // is widget in view?\n    let rect = el.getBoundingClientRect();\n    let innerHeightOrClientHeight = (window.innerHeight || document.documentElement.clientHeight);\n    if (rect.top < 0 ||\n      rect.bottom > innerHeightOrClientHeight\n    ) {\n      // set scrollTop of first parent that scrolls\n      // if parent is larger than el, set as low as possible\n      // to get entire widget on screen\n      let offsetDiffDown = rect.bottom - innerHeightOrClientHeight;\n      let offsetDiffUp = rect.top;\n      let scrollEl = this.getScrollElement(el);\n      if (scrollEl !== null) {\n        let prevScroll = scrollEl.scrollTop;\n        if (rect.top < 0 && distance < 0) {\n          // moving up\n          if (el.offsetHeight > innerHeightOrClientHeight) {\n            scrollEl.scrollTop += distance;\n          } else {\n            scrollEl.scrollTop += Math.abs(offsetDiffUp) > Math.abs(distance) ? distance : offsetDiffUp;\n          }\n        } else if (distance > 0) {\n          // moving down\n          if (el.offsetHeight > innerHeightOrClientHeight) {\n            scrollEl.scrollTop += distance;\n          } else {\n            scrollEl.scrollTop += offsetDiffDown > distance ? distance : offsetDiffDown;\n          }\n        }\n        // move widget y by amount scrolled\n        position.top += scrollEl.scrollTop - prevScroll;\n      }\n    }\n  }\n\n  /**\n   * @internal Function used to scroll the page.\n   *\n   * @param event `MouseEvent` that triggers the resize\n   * @param el `HTMLElement` that's being resized\n   * @param distance Distance from the V edges to start scrolling\n   */\n  static updateScrollResize(event: MouseEvent, el: HTMLElement, distance: number): void {\n    const scrollEl = this.getScrollElement(el);\n    const height = scrollEl.clientHeight;\n    // #1727 event.clientY is relative to viewport, so must compare this against position of scrollEl getBoundingClientRect().top\n    // #1745 Special situation if scrollEl is document 'html': here browser spec states that\n    // clientHeight is height of viewport, but getBoundingClientRect() is rectangle of html element;\n    // this discrepancy arises because in reality scrollbar is attached to viewport, not html element itself.\n    const offsetTop = (scrollEl === this.getScrollElement()) ? 0 : scrollEl.getBoundingClientRect().top;\n    const pointerPosY = event.clientY - offsetTop;\n    const top = pointerPosY < distance;\n    const bottom = pointerPosY > height - distance;\n\n    if (top) {\n      // This also can be done with a timeout to keep scrolling while the mouse is\n      // in the scrolling zone. (will have smoother behavior)\n      scrollEl.scrollBy({ behavior: 'smooth', top: pointerPosY - distance});\n    } else if (bottom) {\n      scrollEl.scrollBy({ behavior: 'smooth', top: distance - (height - pointerPosY)});\n    }\n  }\n\n  /** single level clone, returning a new object with same top fields. This will share sub objects and arrays */\n  static clone<T>(obj: T): T {\n    if (obj === null || obj === undefined || typeof(obj) !== 'object') {\n      return obj;\n    }\n    // return Object.assign({}, obj);\n    if (obj instanceof Array) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return [...obj] as any;\n    }\n    return {...obj};\n  }\n\n  /**\n   * Recursive clone version that returns a full copy, checking for nested objects and arrays ONLY.\n   * Note: this will use as-is any key starting with double __ (and not copy inside) some lib have circular dependencies.\n   */\n  static cloneDeep<T>(obj: T): T {\n    // list of fields we will skip during cloneDeep (nested objects, other internal)\n    const skipFields = ['parentGrid', 'el', 'grid', 'subGrid', 'engine'];\n    // return JSON.parse(JSON.stringify(obj)); // doesn't work with date format ?\n    const ret = Utils.clone(obj);\n    for (const key in ret) {\n      // NOTE: we don't support function/circular dependencies so skip those properties for now...\n      if (ret.hasOwnProperty(key) && typeof(ret[key]) === 'object' && key.substring(0, 2) !== '__' && !skipFields.find(k => k === key)) {\n        ret[key] = Utils.cloneDeep(obj[key]);\n      }\n    }\n    return ret;\n  }\n\n  /** deep clone the given HTML node, removing teh unique id field */\n  public static cloneNode(el: HTMLElement): HTMLElement {\n    const node = el.cloneNode(true) as HTMLElement;\n    node.removeAttribute('id');\n    return node;\n  }\n\n  public static appendTo(el: HTMLElement, parent: string | HTMLElement): void {\n    let parentNode: HTMLElement;\n    if (typeof parent === 'string') {\n      parentNode = Utils.getElement(parent);\n    } else {\n      parentNode = parent;\n    }\n    if (parentNode) {\n      parentNode.appendChild(el);\n    }\n  }\n\n  // public static setPositionRelative(el: HTMLElement): void {\n  //   if (!(/^(?:r|a|f)/).test(getComputedStyle(el).position)) {\n  //     el.style.position = \"relative\";\n  //   }\n  // }\n\n  public static addElStyles(el: HTMLElement, styles: { [prop: string]: string | string[] }): void {\n    if (styles instanceof Object) {\n      for (const s in styles) {\n        if (styles.hasOwnProperty(s)) {\n          if (Array.isArray(styles[s])) {\n            // support fallback value\n            (styles[s] as string[]).forEach(val => {\n              el.style[s] = val;\n            });\n          } else {\n            el.style[s] = styles[s];\n          }\n        }\n      }\n    }\n  }\n\n  public static initEvent<T>(e: DragEvent | MouseEvent, info: { type: string; target?: EventTarget }): T {\n    const evt = { type: info.type };\n    const obj = {\n      button: 0,\n      which: 0,\n      buttons: 1,\n      bubbles: true,\n      cancelable: true,\n      target: info.target ? info.target : e.target\n    };\n    // don't check for `instanceof DragEvent` as Safari use MouseEvent #1540\n    if ((e as DragEvent).dataTransfer) {\n      evt['dataTransfer'] = (e as DragEvent).dataTransfer; // workaround 'readonly' field.\n    }\n    ['altKey','ctrlKey','metaKey','shiftKey'].forEach(p => evt[p] = e[p]); // keys\n    ['pageX','pageY','clientX','clientY','screenX','screenY'].forEach(p => evt[p] = e[p]); // point info\n    return {...evt, ...obj} as unknown as T;\n  }\n\n  /** copies the MouseEvent properties and sends it as another event to the given target */\n  public static simulateMouseEvent(e: MouseEvent, simulatedType: string, target?: EventTarget): void {\n    const simulatedEvent = document.createEvent('MouseEvents');\n    simulatedEvent.initMouseEvent(\n      simulatedType, // type\n      true,         // bubbles\n      true,         // cancelable\n      window,       // view\n      1,            // detail\n      e.screenX,    // screenX\n      e.screenY,    // screenY\n      e.clientX,    // clientX\n      e.clientY,    // clientY\n      e.ctrlKey,    // ctrlKey\n      e.altKey,     // altKey\n      e.shiftKey,   // shiftKey\n      e.metaKey,    // metaKey\n      0,            // button\n      e.target      // relatedTarget\n    );\n    (target || e.target).dispatchEvent(simulatedEvent);\n  }\n\n  /**\n   * defines an element that is used to get the offset and scale from grid transforms\n   * returns the scale and offsets from said element\n  */\n  public static getValuesFromTransformedElement(parent: HTMLElement): DragTransform {\n    const transformReference = document.createElement('div');\n    Utils.addElStyles(transformReference, {\n      opacity: '0',\n      position: 'fixed',\n      top: 0 + 'px',\n      left: 0 + 'px',\n      width: '1px',\n      height: '1px',\n      zIndex: '-999999',\n    });\n    parent.appendChild(transformReference);\n    const transformValues = transformReference.getBoundingClientRect();\n    parent.removeChild(transformReference);\n    transformReference.remove();\n    return {\n      xScale: 1 / transformValues.width,\n      yScale: 1 / transformValues.height,\n      xOffset: transformValues.left,\n      yOffset: transformValues.top,\n    }\n  }\n\n  /** swap the given object 2 field values */\n  public static swap(o: unknown, a: string, b: string): void { const tmp = o[a]; o[a] = o[b]; o[b] = tmp; }\n\n  /** returns true if event is inside the given element rectangle */\n  // Note: Safari Mac has null event.relatedTarget which causes #1684 so check if DragEvent is inside the coordinates instead\n  //    this.el.contains(event.relatedTarget as HTMLElement)\n  // public static inside(e: MouseEvent, el: HTMLElement): boolean {\n  //   // srcElement, toElement, target: all set to placeholder when leaving simple grid, so we can't use that (Chrome)\n  //   let target: HTMLElement = e.relatedTarget || (e as any).fromElement;\n  //   if (!target) {\n  //     const { bottom, left, right, top } = el.getBoundingClientRect();\n  //     return (e.x < right && e.x > left && e.y < bottom && e.y > top);\n  //   }\n  //   return el.contains(target);\n  // }\n\n  /** true if the item can be rotated (checking for prop, not space available) */\n  public static canBeRotated(n: GridStackNode): boolean {\n    return !(!n || n.w === n.h || n.locked || n.noResize || n.grid?.opts.disableResize || (n.minW && n.minW === n.maxW) || (n.minH && n.minH === n.maxH));\n  }\n}"}}