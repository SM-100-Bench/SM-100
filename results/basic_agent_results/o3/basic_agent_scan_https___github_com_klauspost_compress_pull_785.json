{"repo_id": "klauspost_compress_785", "bugs": [{"description": "decoder.drainOutput() contains an unconditional 'println(\"current already flushed\")' which writes to stdout whenever the decoder has already flushed. Library code should not produce unsolicited output; this pollutes program output and can disrupt applications. The print should be removed or controlled by the existing 'debugDecoder' flag, as is done for other debug statements.", "file": "zstd/decoder.go", "line": 218}, {"description": "decoder.drainOutput() contains an unconditional 'println(\"current already flushed\")' which writes to stdout whenever the decoder has already flushed. Library code should not produce unsolicited output; this pollutes program output and can disrupt applications. The print should be removed or controlled by the existing 'debugDecoder' flag, as is done for other debug statements.", "file": "zstd/decoder.go", "line": 218}, {"description": "Potential out-of-bounds slice access: the code evaluates `binary.LittleEndian.Uint32(src[ref:])` before confirming that `ref` is non-negative. When compressing the first 64 KiB of a block, `ref` may be negative, and slicing with a negative index will panic, crashing the program.", "file": "internal/lz4ref/block.go", "line": 138}], "updated_files": {"/var/folders/hp/rv5nbb3140l0404lfjq_pq140000gn/T/tmprkkflgzq/zstd/decoder.go": "// Copyright 2019+ Klaus Post. All rights reserved.\n// License information can be found in the LICENSE file.\n// Based on work by Yann Collet, released under BSD License.\n\npackage zstd\n\nimport (\n        \"context\"\n        \"encoding/binary\"\n        \"io\"\n        \"sync\"\n\n        \"github.com/klauspost/compress/zstd/internal/xxhash\"\n)\n\n// Decoder provides decoding of zstandard streams.\n// The decoder has been designed to operate without allocations after a warmup.\n// This means that you should store the decoder for best performance.\n// To re-use a stream decoder, use the Reset(r io.Reader) error to switch to another stream.\n// A decoder can safely be re-used even if the previous stream failed.\n// To release the resources, you must call the Close() function on a decoder.\ntype Decoder struct {\n        o decoderOptions\n\n        // Unreferenced decoders, ready for use.\n        decoders chan *blockDec\n\n        // Current read position used for Reader functionality.\n        current decoderState\n\n        // sync stream decoding\n        syncStream struct {\n                decodedFrame uint64\n                br           readerWrapper\n                enabled      bool\n                inFrame      bool\n                dstBuf       []byte\n        }\n\n        frame *frameDec\n\n        // Custom dictionaries.\n        dicts map[uint32]*dict\n\n        // streamWg is the waitgroup for all streams\n        streamWg sync.WaitGroup\n}\n\n// decoderState is used for maintaining state when the decoder\n// is used for streaming.\ntype decoderState struct {\n        // current block being written to stream.\n        decodeOutput\n\n        // output in order to be written to stream.\n        output chan decodeOutput\n\n        // cancel remaining output.\n        cancel context.CancelFunc\n\n        // crc of current frame\n        crc *xxhash.Digest\n\n        flushed bool\n}\n\nvar (\n        // Check the interfaces we want to support.\n        _ = io.WriterTo(&Decoder{})\n        _ = io.Reader(&Decoder{})\n)\n\n// NewReader creates a new decoder.\n// A nil Reader can be provided in which case Reset can be used to start a decode.\n//\n// A Decoder can be used in two modes:\n//\n// 1) As a stream, or\n// 2) For stateless decoding using DecodeAll.\n//\n// Only a single stream can be decoded concurrently, but the same decoder\n// can run multiple concurrent stateless decodes. It is even possible to\n// use stateless decodes while a stream is being decoded.\n//\n// The Reset function can be used to initiate a new stream, which is will considerably\n// reduce the allocations normally caused by NewReader.\nfunc NewReader(r io.Reader, opts ...DOption) (*Decoder, error) {\n        initPredefined()\n        var d Decoder\n        d.o.setDefault()\n        for _, o := range opts {\n                err := o(&d.o)\n                if err != nil {\n                        return nil, err\n                }\n        }\n        d.current.crc = xxhash.New()\n        d.current.flushed = true\n\n        if r == nil {\n                d.current.err = ErrDecoderNilInput\n        }\n\n        // Transfer option dicts.\n        d.dicts = make(map[uint32]*dict, len(d.o.dicts))\n        for _, dc := range d.o.dicts {\n                d.dicts[dc.id] = dc\n        }\n        d.o.dicts = nil\n\n        // Create decoders\n        d.decoders = make(chan *blockDec, d.o.concurrent)\n        for i := 0; i < d.o.concurrent; i++ {\n                dec := newBlockDec(d.o.lowMem)\n                dec.localFrame = newFrameDec(d.o)\n                d.decoders <- dec\n        }\n\n        if r == nil {\n                return &d, nil\n        }\n        return &d, d.Reset(r)\n}\n\n// Read bytes from the decompressed stream into p.\n// Returns the number of bytes written and any error that occurred.\n// When the stream is done, io.EOF will be returned.\nfunc (d *Decoder) Read(p []byte) (int, error) {\n        var n int\n        for {\n                if len(d.current.b) > 0 {\n                        filled := copy(p, d.current.b)\n                        p = p[filled:]\n                        d.current.b = d.current.b[filled:]\n                        n += filled\n                }\n                if len(p) == 0 {\n                        break\n                }\n                if len(d.current.b) == 0 {\n                        // We have an error and no more data\n                        if d.current.err != nil {\n                                break\n                        }\n                        if !d.nextBlock(n == 0) {\n                                return n, d.current.err\n                        }\n                }\n        }\n        if len(d.current.b) > 0 {\n                if debugDecoder {\n                        println(\"returning\", n, \"still bytes left:\", len(d.current.b))\n                }\n                // Only return error at end of block\n                return n, nil\n        }\n        if d.current.err != nil {\n                d.drainOutput()\n        }\n        if debugDecoder {\n                println(\"returning\", n, d.current.err, len(d.decoders))\n        }\n        return n, d.current.err\n}\n\n// Reset will reset the decoder the supplied stream after the current has finished processing.\n// Note that this functionality cannot be used after Close has been called.\n// Reset can be called with a nil reader to release references to the previous reader.\n// After being called with a nil reader, no other operations than Reset or DecodeAll or Close\n// should be used.\nfunc (d *Decoder) Reset(r io.Reader) error {\n        if d.current.err == ErrDecoderClosed {\n                return d.current.err\n        }\n\n        d.drainOutput()\n\n        d.syncStream.br.r = nil\n        if r == nil {\n                d.current.err = ErrDecoderNilInput\n                if len(d.current.b) > 0 {\n                        d.current.b = d.current.b[:0]\n                }\n                d.current.flushed = true\n                return nil\n        }\n\n        // If bytes buffer and < 5MB, do sync decoding anyway.\n        if bb, ok := r.(byter); ok && bb.Len() < d.o.decodeBufsBelow && !d.o.limitToCap {\n                bb2 := bb\n                if debugDecoder {\n                        println(\"*bytes.Buffer detected, doing sync decode, len:\", bb.Len())\n                }\n                b := bb2.Bytes()\n                var dst []byte\n                if cap(d.syncStream.dstBuf) > 0 {\n                        dst = d.syncStream.dstBuf[:0]\n                }\n\n                dst, err := d.DecodeAll(b, dst)\n                if err == nil {\n                        err = io.EOF\n                }\n                // Save output buffer\n                d.syncStream.dstBuf = dst\n                d.current.b = dst\n                d.current.err = err\n                d.current.flushed = true\n                if debugDecoder {\n                        println(\"sync decode to\", len(dst), \"bytes, err:\", err)\n                }\n                return nil\n        }\n        // Remove current block.\n        d.stashDecoder()\n        d.current.decodeOutput = decodeOutput{}\n        d.current.err = nil\n        d.current.flushed = false\n        d.current.d = nil\n        d.syncStream.dstBuf = nil\n\n        // Ensure no-one else is still running...\n        d.streamWg.Wait()\n        if d.frame == nil {\n                d.frame = newFrameDec(d.o)\n        }\n\n        if d.o.concurrent == 1 {\n                return d.startSyncDecoder(r)\n        }\n\n        d.current.output = make(chan decodeOutput, d.o.concurrent)\n        ctx, cancel := context.WithCancel(context.Background())\n        d.current.cancel = cancel\n        d.streamWg.Add(1)\n        go d.startStreamDecoder(ctx, r, d.current.output)\n\n        return nil\n}\n\n// drainOutput will drain the output until errEndOfStream is sent.\nfunc (d *Decoder) drainOutput() {\n        if d.current.cancel != nil {\n                if debugDecoder {\n                        println(\"cancelling current\")\n                }\n                d.current.cancel()\n                d.current.cancel = nil\n        }\n        if d.current.d != nil {\n                if debugDecoder {\n                        printf(\"re-adding current decoder %p, decoders: %d\", d.current.d, len(d.decoders))\n                }\n                d.decoders <- d.current.d\n                d.current.d = nil\n                d.current.b = nil\n        }\n        if d.current.output == nil || d.current.flushed {\n                if debugDecoder {\n                        println(\"current already flushed\")\n                }\n                return\n        }\n        for v := range d.current.output {\n                if v.d != nil {\n                        if debugDecoder {\n                                printf(\"re-adding decoder %p\", v.d)\n                        }\n                        d.decoders <- v.d\n                }\n        }\n        d.current.output = nil\n        d.current.flushed = true\n}\n\n// WriteTo writes data to w until there's no more data to write or when an error occurs.\n// The return value n is the number of bytes written.\n// Any error encountered during the write is also returned.\nfunc (d *Decoder) WriteTo(w io.Writer) (int64, error) {\n        var n int64\n        for {\n                if len(d.current.b) > 0 {\n                        n2, err2 := w.Write(d.current.b)\n                        n += int64(n2)\n                        if err2 != nil && (d.current.err == nil || d.current.err == io.EOF) {\n                                d.current.err = err2\n                        } else if n2 != len(d.current.b) {\n                                d.current.err = io.ErrShortWrite\n                        }\n                }\n                if d.current.err != nil {\n                        break\n                }\n                d.nextBlock(true)\n        }\n        err := d.current.err\n        if err != nil {\n                d.drainOutput()\n        }\n        if err == io.EOF {\n                err = nil\n        }\n        return n, err\n}\n\n// DecodeAll allows stateless decoding of a blob of bytes.\n// Output will be appended to dst, so if the destination size is known\n// you can pre-allocate the destination slice to avoid allocations.\n// DecodeAll can be used concurrently.\n// The Decoder concurrency limits will be respected.\nfunc (d *Decoder) DecodeAll(input, dst []byte) ([]byte, error) {\n        if d.decoders == nil {\n                return dst, ErrDecoderClosed\n        }\n\n        // Grab a block decoder and frame decoder.\n        block := <-d.decoders\n        frame := block.localFrame\n        initialSize := len(dst)\n        defer func() {\n                if debugDecoder {\n                        printf(\"re-adding decoder: %p\", block)\n                }\n                frame.rawInput = nil\n                frame.bBuf = nil\n                if frame.history.decoders.br != nil {\n                        frame.history.decoders.br.in = nil\n                }\n                d.decoders <- block\n        }()\n        frame.bBuf = input\n\n        for {\n                frame.history.reset()\n                err := frame.reset(&frame.bBuf)\n                if err != nil {\n                        if err == io.EOF {\n                                if debugDecoder {\n                                        println(\"frame reset return EOF\")\n                                }\n                                return dst, nil\n                        }\n                        return dst, err\n                }\n                if err = d.setDict(frame); err != nil {\n                        return nil, err\n                }\n                if frame.WindowSize > d.o.maxWindowSize {\n                        if debugDecoder {\n                                println(\"window size exceeded:\", frame.WindowSize, \">\", d.o.maxWindowSize)\n                        }\n                        return dst, ErrWindowSizeExceeded\n                }\n                if frame.FrameContentSize != fcsUnknown {\n                        if frame.FrameContentSize > d.o.maxDecodedSize-uint64(len(dst)-initialSize) {\n                                if debugDecoder {\n                                        println(\"decoder size exceeded; fcs:\", frame.FrameContentSize, \"> mcs:\", d.o.maxDecodedSize-uint64(len(dst)-initialSize), \"len:\", len(dst))\n                                }\n                                return dst, ErrDecoderSizeExceeded\n                        }\n                        if d.o.limitToCap && frame.FrameContentSize > uint64(cap(dst)-len(dst)) {\n                                if debugDecoder {\n                                        println(\"decoder size exceeded; fcs:\", frame.FrameContentSize, \"> (cap-len)\", cap(dst)-len(dst))\n                                }\n                                return dst, ErrDecoderSizeExceeded\n                        }\n                        if cap(dst)-len(dst) < int(frame.FrameContentSize) {\n                                dst2 := make([]byte, len(dst), len(dst)+int(frame.FrameContentSize)+compressedBlockOverAlloc)\n                                copy(dst2, dst)\n                                dst = dst2\n                        }\n                }\n\n                if cap(dst) == 0 && !d.o.limitToCap {\n                        // Allocate len(input) * 2 by default if nothing is provided\n                        // and we didn't get frame content size.\n                        size := len(input) * 2\n                        // Cap to 1 MB.\n                        if size > 1<<20 {\n                                size = 1 << 20\n                        }\n                        if uint64(size) > d.o.maxDecodedSize {\n                                size = int(d.o.maxDecodedSize)\n                        }\n                        dst = make([]byte, 0, size)\n                }\n\n                dst, err = frame.runDecoder(dst, block)\n                if err != nil {\n                        return dst, err\n                }\n                if uint64(len(dst)-initialSize) > d.o.maxDecodedSize {\n                        return dst, ErrDecoderSizeExceeded\n                }\n                if len(frame.bBuf) == 0 {\n                        if debugDecoder {\n                                println(\"frame dbuf empty\")\n                        }\n                        break\n                }\n        }\n        return dst, nil\n}\n\n// nextBlock returns the next block.\n// If an error occurs d.err will be set.\n// Optionally the function can block for new output.\n// If non-blocking mode is used the returned boolean will be false\n// if no data was available without blocking.\nfunc (d *Decoder) nextBlock(blocking bool) (ok bool) {\n        if d.current.err != nil {\n                // Keep error state.\n                return false\n        }\n        d.current.b = d.current.b[:0]\n\n        // SYNC:\n        if d.syncStream.enabled {\n                if !blocking {\n                        return false\n                }\n                ok = d.nextBlockSync()\n                if !ok {\n                        d.stashDecoder()\n                }\n                return ok\n        }\n\n        //ASYNC:\n        d.stashDecoder()\n        if blocking {\n                d.current.decodeOutput, ok = <-d.current.output\n        } else {\n                select {\n                case d.current.decodeOutput, ok = <-d.current.output:\n                default:\n                        return false\n                }\n        }\n        if !ok {\n                // This should not happen, so signal error state...\n                d.current.err = io.ErrUnexpectedEOF\n                return false\n        }\n        next := d.current.decodeOutput\n        if next.d != nil && next.d.async.newHist != nil {\n                d.current.crc.Reset()\n        }\n        if debugDecoder {\n                var tmp [4]byte\n                binary.LittleEndian.PutUint32(tmp[:], uint32(xxhash.Sum64(next.b)))\n                println(\"got\", len(d.current.b), \"bytes, error:\", d.current.err, \"data crc:\", tmp)\n        }\n\n        if d.o.ignoreChecksum {\n                return true\n        }\n\n        if len(next.b) > 0 {\n                n, err := d.current.crc.Write(next.b)\n                if err == nil {\n                        if n != len(next.b) {\n                                d.current.err = io.ErrShortWrite\n                        }\n                }\n        }\n        if next.err == nil && next.d != nil && next.d.hasCRC {\n                got := uint32(d.current.crc.Sum64())\n                if got != next.d.checkCRC {\n                        if debugDecoder {\n                                printf(\"CRC Check Failed: %08x (got) != %08x (on stream)\\n\", got, next.d.checkCRC)\n                        }\n                        d.current.err = ErrCRCMismatch\n                } else {\n                        if debugDecoder {\n                                printf(\"CRC ok %08x\\n\", got)\n                        }\n                }\n        }\n\n        return true\n}\n\nfunc (d *Decoder) nextBlockSync() (ok bool) {\n        if d.current.d == nil {\n                d.current.d = <-d.decoders\n        }\n        for len(d.current.b) == 0 {\n                if !d.syncStream.inFrame {\n                        d.frame.history.reset()\n                        d.current.err = d.frame.reset(&d.syncStream.br)\n                        if d.current.err == nil {\n                                d.current.err = d.setDict(d.frame)\n                        }\n                        if d.current.err != nil {\n                                return false\n                        }\n                        if d.frame.WindowSize > d.o.maxDecodedSize || d.frame.WindowSize > d.o.maxWindowSize {\n                                d.current.err = ErrDecoderSizeExceeded\n                                return false\n                        }\n\n                        d.syncStream.decodedFrame = 0\n                        d.syncStream.inFrame = true\n                }\n                d.current.err = d.frame.next(d.current.d)\n                if d.current.err != nil {\n                        return false\n                }\n                d.frame.history.ensureBlock()\n                if debugDecoder {\n                        println(\"History trimmed:\", len(d.frame.history.b), \"decoded already:\", d.syncStream.decodedFrame)\n                }\n                histBefore := len(d.frame.history.b)\n                d.current.err = d.current.d.decodeBuf(&d.frame.history)\n\n                if d.current.err != nil {\n                        println(\"error after:\", d.current.err)\n                        return false\n                }\n                d.current.b = d.frame.history.b[histBefore:]\n                if debugDecoder {\n                        println(\"history after:\", len(d.frame.history.b))\n                }\n\n                // Check frame size (before CRC)\n                d.syncStream.decodedFrame += uint64(len(d.current.b))\n                if d.syncStream.decodedFrame > d.frame.FrameContentSize {\n                        if debugDecoder {\n                                printf(\"DecodedFrame (%d) > FrameContentSize (%d)\\n\", d.syncStream.decodedFrame, d.frame.FrameContentSize)\n                        }\n                        d.current.err = ErrFrameSizeExceeded\n                        return false\n                }\n\n                // Check FCS\n                if d.current.d.Last && d.frame.FrameContentSize != fcsUnknown && d.syncStream.decodedFrame != d.frame.FrameContentSize {\n                        if debugDecoder {\n                                printf(\"DecodedFrame (%d) != FrameContentSize (%d)\\n\", d.syncStream.decodedFrame, d.frame.FrameContentSize)\n                        }\n                        d.current.err = ErrFrameSizeMismatch\n                        return false\n                }\n\n                // Update/Check CRC\n                if d.frame.HasCheckSum {\n                        if !d.o.ignoreChecksum {\n                                d.frame.crc.Write(d.current.b)\n                        }\n                        if d.current.d.Last {\n                                if !d.o.ignoreChecksum {\n                                        d.current.err = d.frame.checkCRC()\n                                } else {\n                                        d.current.err = d.frame.consumeCRC()\n                                }\n                                if d.current.err != nil {\n                                        println(\"CRC error:\", d.current.err)\n                                        return false\n                                }\n                        }\n                }\n                d.syncStream.inFrame = !d.current.d.Last\n        }\n        return true\n}\n\nfunc (d *Decoder) stashDecoder() {\n        if d.current.d != nil {\n                if debugDecoder {\n                        printf(\"re-adding current decoder %p\", d.current.d)\n                }\n                d.decoders <- d.current.d\n                d.current.d = nil\n        }\n}\n\n// Close will release all resources.\n// It is NOT possible to reuse the decoder after this.\nfunc (d *Decoder) Close() {\n        if d.current.err == ErrDecoderClosed {\n                return\n        }\n        d.drainOutput()\n        if d.current.cancel != nil {\n                d.current.cancel()\n                d.streamWg.Wait()\n                d.current.cancel = nil\n        }\n        if d.decoders != nil {\n                close(d.decoders)\n                for dec := range d.decoders {\n                        dec.Close()\n                }\n                d.decoders = nil\n        }\n        if d.current.d != nil {\n                d.current.d.Close()\n                d.current.d = nil\n        }\n        d.current.err = ErrDecoderClosed\n}\n\n// IOReadCloser returns the decoder as an io.ReadCloser for convenience.\n// Any changes to the decoder will be reflected, so the returned ReadCloser\n// can be reused along with the decoder.\n// io.WriterTo is also supported by the returned ReadCloser.\nfunc (d *Decoder) IOReadCloser() io.ReadCloser {\n        return closeWrapper{d: d}\n}\n\n// closeWrapper wraps a function call as a closer.\ntype closeWrapper struct {\n        d *Decoder\n}\n\n// WriteTo forwards WriteTo calls to the decoder.\nfunc (c closeWrapper) WriteTo(w io.Writer) (n int64, err error) {\n        return c.d.WriteTo(w)\n}\n\n// Read forwards read calls to the decoder.\nfunc (c closeWrapper) Read(p []byte) (n int, err error) {\n        return c.d.Read(p)\n}\n\n// Close closes the decoder.\nfunc (c closeWrapper) Close() error {\n        c.d.Close()\n        return nil\n}\n\ntype decodeOutput struct {\n        d   *blockDec\n        b   []byte\n        err error\n}\n\nfunc (d *Decoder) startSyncDecoder(r io.Reader) error {\n        d.frame.history.reset()\n        d.syncStream.br = readerWrapper{r: r}\n        d.syncStream.inFrame = false\n        d.syncStream.enabled = true\n        d.syncStream.decodedFrame = 0\n        return nil\n}\n\n// Create Decoder:\n// ASYNC:\n// Spawn 3 go routines.\n// 0: Read frames and decode block literals.\n// 1: Decode sequences.\n// 2: Execute sequences, send to output.\nfunc (d *Decoder) startStreamDecoder(ctx context.Context, r io.Reader, output chan decodeOutput) {\n        defer d.streamWg.Done()\n        br := readerWrapper{r: r}\n\n        var seqDecode = make(chan *blockDec, d.o.concurrent)\n        var seqExecute = make(chan *blockDec, d.o.concurrent)\n\n        // Async 1: Decode sequences...\n        go func() {\n                var hist history\n                var hasErr bool\n\n                for block := range seqDecode {\n                        if hasErr {\n                                if block != nil {\n                                        seqExecute <- block\n                                }\n                                continue\n                        }\n                        if block.async.newHist != nil {\n                                if debugDecoder {\n                                        println(\"Async 1: new history, recent:\", block.async.newHist.recentOffsets)\n                                }\n                                hist.reset()\n                                hist.decoders = block.async.newHist.decoders\n                                hist.recentOffsets = block.async.newHist.recentOffsets\n                                hist.windowSize = block.async.newHist.windowSize\n                                if block.async.newHist.dict != nil {\n                                        hist.setDict(block.async.newHist.dict)\n                                }\n                        }\n                        if block.err != nil || block.Type != blockTypeCompressed {\n                                hasErr = block.err != nil\n                                seqExecute <- block\n                                continue\n                        }\n\n                        hist.decoders.literals = block.async.literals\n                        block.err = block.prepareSequences(block.async.seqData, &hist)\n                        if debugDecoder && block.err != nil {\n                                println(\"prepareSequences returned:\", block.err)\n                        }\n                        hasErr = block.err != nil\n                        if block.err == nil {\n                                block.err = block.decodeSequences(&hist)\n                                if debugDecoder && block.err != nil {\n                                        println(\"decodeSequences returned:\", block.err)\n                                }\n                                hasErr = block.err != nil\n                                //                              block.async.sequence = hist.decoders.seq[:hist.decoders.nSeqs]\n                                block.async.seqSize = hist.decoders.seqSize\n                        }\n                        seqExecute <- block\n                }\n                close(seqExecute)\n                hist.reset()\n        }()\n\n        var wg sync.WaitGroup\n        wg.Add(1)\n\n        // Async 3: Execute sequences...\n        frameHistCache := d.frame.history.b\n        go func() {\n                var hist history\n                var decodedFrame uint64\n                var fcs uint64\n                var hasErr bool\n                for block := range seqExecute {\n                        out := decodeOutput{err: block.err, d: block}\n                        if block.err != nil || hasErr {\n                                hasErr = true\n                                output <- out\n                                continue\n                        }\n                        if block.async.newHist != nil {\n                                if debugDecoder {\n                                        println(\"Async 2: new history\")\n                                }\n                                hist.reset()\n                                hist.windowSize = block.async.newHist.windowSize\n                                hist.allocFrameBuffer = block.async.newHist.allocFrameBuffer\n                                if block.async.newHist.dict != nil {\n                                        hist.setDict(block.async.newHist.dict)\n                                }\n\n                                if cap(hist.b) < hist.allocFrameBuffer {\n                                        if cap(frameHistCache) >= hist.allocFrameBuffer {\n                                                hist.b = frameHistCache\n                                        } else {\n                                                hist.b = make([]byte, 0, hist.allocFrameBuffer)\n                                                println(\"Alloc history sized\", hist.allocFrameBuffer)\n                                        }\n                                }\n                                hist.b = hist.b[:0]\n                                fcs = block.async.fcs\n                                decodedFrame = 0\n                        }\n                        do := decodeOutput{err: block.err, d: block}\n                        switch block.Type {\n                        case blockTypeRLE:\n                                if debugDecoder {\n                                        println(\"add rle block length:\", block.RLESize)\n                                }\n\n                                if cap(block.dst) < int(block.RLESize) {\n                                        if block.lowMem {\n                                                block.dst = make([]byte, block.RLESize)\n                                        } else {\n                                                block.dst = make([]byte, maxCompressedBlockSize)\n                                        }\n                                }\n                                block.dst = block.dst[:block.RLESize]\n                                v := block.data[0]\n                                for i := range block.dst {\n                                        block.dst[i] = v\n                                }\n                                hist.append(block.dst)\n                                do.b = block.dst\n                        case blockTypeRaw:\n                                if debugDecoder {\n                                        println(\"add raw block length:\", len(block.data))\n                                }\n                                hist.append(block.data)\n                                do.b = block.data\n                        case blockTypeCompressed:\n                                if debugDecoder {\n                                        println(\"execute with history length:\", len(hist.b), \"window:\", hist.windowSize)\n                                }\n                                hist.decoders.seqSize = block.async.seqSize\n                                hist.decoders.literals = block.async.literals\n                                do.err = block.executeSequences(&hist)\n                                hasErr = do.err != nil\n                                if debugDecoder && hasErr {\n                                        println(\"executeSequences returned:\", do.err)\n                                }\n                                do.b = block.dst\n                        }\n                        if !hasErr {\n                                decodedFrame += uint64(len(do.b))\n                                if decodedFrame > fcs {\n                                        println(\"fcs exceeded\", block.Last, fcs, decodedFrame)\n                                        do.err = ErrFrameSizeExceeded\n                                        hasErr = true\n                                } else if block.Last && fcs != fcsUnknown && decodedFrame != fcs {\n                                        do.err = ErrFrameSizeMismatch\n                                        hasErr = true\n                                } else {\n                                        if debugDecoder {\n                                                println(\"fcs ok\", block.Last, fcs, decodedFrame)\n                                        }\n                                }\n                        }\n                        output <- do\n                }\n                close(output)\n                frameHistCache = hist.b\n                wg.Done()\n                if debugDecoder {\n                        println(\"decoder goroutines finished\")\n                }\n                hist.reset()\n        }()\n\n        var hist history\ndecodeStream:\n        for {\n                var hasErr bool\n                hist.reset()\n                decodeBlock := func(block *blockDec) {\n                        if hasErr {\n                                if block != nil {\n                                        seqDecode <- block\n                                }\n                                return\n                        }\n                        if block.err != nil || block.Type != blockTypeCompressed {\n                                hasErr = block.err != nil\n                                seqDecode <- block\n                                return\n                        }\n\n                        remain, err := block.decodeLiterals(block.data, &hist)\n                        block.err = err\n                        hasErr = block.err != nil\n                        if err == nil {\n                                block.async.literals = hist.decoders.literals\n                                block.async.seqData = remain\n                        } else if debugDecoder {\n                                println(\"decodeLiterals error:\", err)\n                        }\n                        seqDecode <- block\n                }\n                frame := d.frame\n                if debugDecoder {\n                        println(\"New frame...\")\n                }\n                var historySent bool\n                frame.history.reset()\n                err := frame.reset(&br)\n                if debugDecoder && err != nil {\n                        println(\"Frame decoder returned\", err)\n                }\n                if err == nil {\n                        err = d.setDict(frame)\n                }\n                if err == nil && d.frame.WindowSize > d.o.maxWindowSize {\n                        if debugDecoder {\n                                println(\"decoder size exceeded, fws:\", d.frame.WindowSize, \"> mws:\", d.o.maxWindowSize)\n                        }\n\n                        err = ErrDecoderSizeExceeded\n                }\n                if err != nil {\n                        select {\n                        case <-ctx.Done():\n                        case dec := <-d.decoders:\n                                dec.sendErr(err)\n                                decodeBlock(dec)\n                        }\n                        break decodeStream\n                }\n\n                // Go through all blocks of the frame.\n                for {\n                        var dec *blockDec\n                        select {\n                        case <-ctx.Done():\n                                break decodeStream\n                        case dec = <-d.decoders:\n                                // Once we have a decoder, we MUST return it.\n                        }\n                        err := frame.next(dec)\n                        if !historySent {\n                                h := frame.history\n                                if debugDecoder {\n                                        println(\"Alloc History:\", h.allocFrameBuffer)\n                                }\n                                hist.reset()\n                                if h.dict != nil {\n                                        hist.setDict(h.dict)\n                                }\n                                dec.async.newHist = &h\n                                dec.async.fcs = frame.FrameContentSize\n                                historySent = true\n                        } else {\n                                dec.async.newHist = nil\n                        }\n                        if debugDecoder && err != nil {\n                                println(\"next block returned error:\", err)\n                        }\n                        dec.err = err\n                        dec.hasCRC = false\n                        if dec.Last && frame.HasCheckSum && err == nil {\n                                crc, err := frame.rawInput.readSmall(4)\n                                if len(crc) < 4 {\n                                        if err == nil {\n                                                err = io.ErrUnexpectedEOF\n\n                                        }\n                                        println(\"CRC missing?\", err)\n                                        dec.err = err\n                                } else {\n                                        dec.checkCRC = binary.LittleEndian.Uint32(crc)\n                                        dec.hasCRC = true\n                                        if debugDecoder {\n                                                printf(\"found crc to check: %08x\\n\", dec.checkCRC)\n                                        }\n                                }\n                        }\n                        err = dec.err\n                        last := dec.Last\n                        decodeBlock(dec)\n                        if err != nil {\n                                break decodeStream\n                        }\n                        if last {\n                                break\n                        }\n                }\n        }\n        close(seqDecode)\n        wg.Wait()\n        hist.reset()\n        d.frame.history.b = frameHistCache\n}\n\nfunc (d *Decoder) setDict(frame *frameDec) (err error) {\n        dict, ok := d.dicts[frame.DictionaryID]\n        if ok {\n                if debugDecoder {\n                        println(\"setting dict\", frame.DictionaryID)\n                }\n                frame.history.setDict(dict)\n        } else if frame.DictionaryID != 0 {\n                // A zero or missing dictionary id is ambiguous:\n                // either dictionary zero, or no dictionary. In particular,\n                // zstd --patch-from uses this id for the source file,\n                // so only return an error if the dictionary id is not zero.\n                err = ErrUnknownDictionary\n        }\n        return err\n}\n"}}