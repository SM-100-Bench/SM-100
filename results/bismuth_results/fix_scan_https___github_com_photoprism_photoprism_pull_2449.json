{"scanned_subsystems":[{"name":"Media Processing","files":["internal/crop/area.go","internal/crop/cache.go","internal/crop/crop.go","internal/crop/errors.go","internal/crop/image.go","internal/crop/names.go","internal/crop/request.go","internal/crop/sizes.go","internal/ffmpeg/convert.go","internal/ffmpeg/encoders.go","internal/ffmpeg/ffmpeg.go","internal/meta/codec.go","internal/meta/data.go","internal/meta/data_report.go","internal/meta/docs.go","internal/meta/duration.go","internal/meta/exif.go","internal/meta/exif_parser.go","internal/meta/gps.go","internal/meta/iptc/2021.1.json","internal/meta/iptc/2021.1.yml","internal/meta/json.go","internal/meta/json_exiftool.go","internal/meta/json_gphotos.go","internal/meta/keywords.go","internal/meta/meta.go","internal/meta/sanitize.go","internal/meta/testdata/GOPR0533.json","internal/meta/testdata/Iceland-P3-n.json","internal/meta/testdata/Iceland-P3.json","internal/meta/testdata/Iceland-sRGB.json","internal/meta/testdata/NOTICE.md","internal/meta/testdata/P7250006.json","internal/meta/testdata/P9150300.json","internal/meta/testdata/README.md","internal/meta/testdata/berlin-landscape.json","internal/meta/testdata/canon_eos_6d.json","internal/meta/testdata/cr2_num_off.json","internal/meta/testdata/cr2_num_on.json","internal/meta/testdata/date-creation.mov.json","internal/meta/testdata/date-iphone8.mov.json","internal/meta/testdata/date-iphonex.mov.json","internal/meta/testdata/date.mov.json","internal/meta/testdata/digikam.json","internal/meta/testdata/example.gif.json","internal/meta/testdata/gif.json","internal/meta/testdata/gopher-original.json","internal/meta/testdata/gopher-telegram.json","internal/meta/testdata/gphotos-1.json","internal/meta/testdata/gphotos-2.json","internal/meta/testdata/gphotos-3.json","internal/meta/testdata/gphotos-4.json","internal/meta/testdata/gphotos-album.json","internal/meta/testdata/gps-2000.json","internal/meta/testdata/iphone-mov.json","internal/meta/testdata/iphone_7.json","internal/meta/testdata/iptc-fields-500.json","internal/meta/testdata/keywords.json","internal/meta/testdata/ladybug.json","internal/meta/testdata/mp4.json","internal/meta/testdata/newline.json","internal/meta/testdata/orientation.json","internal/meta/testdata/panorama360.json","internal/meta/testdata/photoshop.json","internal/meta/testdata/pxl-mp4.json","internal/meta/testdata/pythagoras.json","internal/meta/testdata/quicktimeutc_off.json","internal/meta/testdata/quicktimeutc_on.json","internal/meta/testdata/smallFiji.json","internal/meta/testdata/snow.json","internal/meta/testdata/sony_mp4_exiftool.json","internal/meta/testdata/subject-1.json","internal/meta/testdata/subject-2.json","internal/meta/testdata/uuid-copy.json","internal/meta/testdata/uuid-imagemagick.json","internal/meta/testdata/uuid-original.json","internal/meta/testdata/video_num_on.json","internal/meta/xmp.go","internal/meta/xmp_document.go","internal/thumb/create.go","internal/thumb/errors.go","internal/thumb/jpeg.go","internal/thumb/names.go","internal/thumb/open.go","internal/thumb/open_jpeg.go","internal/thumb/quality.go","internal/thumb/resample.go","internal/thumb/resample_filters.go","internal/thumb/resample_options.go","internal/thumb/rotate.go","internal/thumb/sizes.go","internal/thumb/thumb.go"]}],"changesets":[{"title":"Fix Media Processing Subsystem Bugs and Security Vulnerabilities","body":"## Bug Fixes and Security Improvements\n\n### Time Handling Bugs\n1. Fixed immutable time handling in `Exif` and `Exiftool` methods:\n   - Corrected nanosecond addition by properly assigning results back to `data.TakenAt` and `data.TakenAtLocal`\n   - Prevents silent failures when attempting to modify time values\n\n### Duration Parsing Bug\n2. Fixed `StringToDuration` function in `internal/meta/duration.go`:\n   - Added proper error checking before assigning parsed duration\n   - Prevents returning zero duration on parsing errors\n\n### Security Vulnerabilities\n3. Added path traversal protection:\n   - Implemented checks in file handling functions to prevent directory traversal attacks\n   - Added validation for file paths in multiple methods across the media processing subsystem\n\n4. Resource Exhaustion Prevention:\n   - Added file size limits to prevent processing of excessively large files\n   - Implemented maximum size checks in file reading and image processing functions\n   - Added protection against large JSON array parsing\n\n### Nil Safety Improvements\n5. Added nil checks in image processing functions:\n   - Prevent panics in `Resample` and `Rotate` functions when handling nil images\n   - Improved robustness of image processing methods\n\n### Division by Zero Protection\n6. Added division by zero protection:\n   - In `FileWidth` methods of `Area` struct\n   - In crop-related functions to prevent potential runtime errors\n\n### Detailed Changes\n- Updated file handling in multiple packages\n- Added input validation for file paths and sizes\n- Improved error handling and logging\n- Enhanced security of file processing methods\n\n### Recommended Review\nPlease carefully review the changes, paying special attention to:\n- Time manipulation logic\n- File path handling\n- Resource limit implementations\n- Error handling mechanisms\n\n**Note:** These changes address multiple security and reliability issues in the media processing subsystem.","commits":[{"message":"Fix the bug in the (Data) Exif method in internal/meta/exif.go where the code adds nanoseconds to the calculated UTC and local time (lines 296-301). The function calls Add(ns) on the result of Truncate(time.Second).UTC() and Truncate(time.Second), but these calls don't modify the original time.Time values because time.Time is immutable in Go. The results of these calls are discarded. The results should be assigned back to data.TakenAt and data.TakenAtLocal.","diff":"diff --git a/internal/meta/exif.go b/internal/meta/exif.go\nindex de0456a..41ae101 100644\n--- a/internal/meta/exif.go\n+++ b/internal/meta/exif.go\n@@ -296,8 +296,8 @@ func (data *Data) Exif(fileName string, fileFormat fs.Type, bruteForce bool) (er\n \t// Add nanoseconds to the calculated UTC and local time.\n \tif data.TakenAt.Nanosecond() == 0 {\n \t\tif ns := time.Duration(data.TakenNs); ns > 0 && ns <= time.Second {\n-\t\t\tdata.TakenAt.Truncate(time.Second).UTC().Add(ns)\n-\t\t\tdata.TakenAtLocal.Truncate(time.Second).Add(ns)\n+\t\t\tdata.TakenAt = data.TakenAt.Truncate(time.Second).UTC().Add(ns)\n+\t\t\tdata.TakenAtLocal = data.TakenAtLocal.Truncate(time.Second).Add(ns)\n \t\t}\n \t}\n "},{"message":"Fix the bug in the (Data) Exiftool method in internal/meta/json_exiftool.go where the code adds nanoseconds to the calculated UTC and local time (lines 236-241). The function calls Add(ns) on the result of Truncate(time.Second).UTC() and Truncate(time.Second), but these calls don't modify the original time.Time values because time.Time is immutable in Go. The results of these calls are discarded. The results should be assigned back to data.TakenAt and data.TakenAtLocal.","diff":"diff --git a/internal/meta/json_exiftool.go b/internal/meta/json_exiftool.go\nindex 75ba45f..fa7cd8c 100644\n--- a/internal/meta/json_exiftool.go\n+++ b/internal/meta/json_exiftool.go\n@@ -236,8 +236,8 @@ func (data *Data) Exiftool(jsonData []byte, originalName string) (err error) {\n \t// Add nanoseconds to the calculated UTC and local time.\n \tif data.TakenAt.Nanosecond() == 0 {\n \t\tif ns := time.Duration(data.TakenNs); ns > 0 && ns <= time.Second {\n-\t\t\tdata.TakenAt.Truncate(time.Second).UTC().Add(ns)\n-\t\t\tdata.TakenAtLocal.Truncate(time.Second).Add(ns)\n+\t\t\tdata.TakenAt = data.TakenAt.Truncate(time.Second).UTC().Add(ns)\n+\t\t\tdata.TakenAtLocal = data.TakenAtLocal.Truncate(time.Second).Add(ns)\n \t\t}\n \t}\n \ndiff --git a/internal/meta/json_test.go b/internal/meta/json_test.go\nindex 0e8fc35..fd9786b 100644\n--- a/internal/meta/json_test.go\n+++ b/internal/meta/json_test.go\n@@ -153,8 +153,8 @@ func TestJSON(t *testing.T) {\n \t\tassert.Equal(t, \"0s\", data.Duration.String())\n \t\tassert.Equal(t, float32(52.45969), data.Lat)\n \t\tassert.Equal(t, float32(13.321831), data.Lng)\n-\t\tassert.Equal(t, \"2020-01-01 16:28:23 +0000 UTC\", data.TakenAt.String())\n-\t\tassert.Equal(t, \"2020-01-01 17:28:23 +0000 UTC\", data.TakenAtLocal.String())\n+\t\tassert.Equal(t, \"2020-01-01 16:28:23.899614 +0000 UTC\", data.TakenAt.String())\n+\t\tassert.Equal(t, \"2020-01-01 17:28:23.899614 +0000 UTC\", data.TakenAtLocal.String())\n \t\tassert.Equal(t, 899614000, data.TakenNs)\n \t\tassert.Equal(t, \"Europe/Berlin\", data.TimeZone)\n \t\tassert.Equal(t, \"Night Shift / Berlin / 2020\", data.Title)\n@@ -264,8 +264,8 @@ func TestJSON(t *testing.T) {\n \t\tassert.Equal(t, \"\", data.InstanceID)\n \t\tassert.Equal(t, CodecJpeg, data.Codec)\n \t\tassert.Equal(t, \"0s\", data.Duration.String())\n-\t\tassert.Equal(t, \"2018-12-06 12:32:26 +0000 UTC\", data.TakenAtLocal.String())\n-\t\tassert.Equal(t, \"2018-12-06 11:32:26 +0000 UTC\", data.TakenAt.String())\n+\t\tassert.Equal(t, \"2018-12-06 12:32:26.6 +0000 UTC\", data.TakenAtLocal.String())\n+\t\tassert.Equal(t, \"2018-12-06 11:32:26.6 +0000 UTC\", data.TakenAt.String())\n \t\tassert.Equal(t, \"Europe/Berlin\", data.TimeZone)\n \t\tassert.Equal(t, 3024, data.Width)\n \t\tassert.Equal(t, 4032, data.Height)\n@@ -290,8 +290,8 @@ func TestJSON(t *testing.T) {\n \t\tassert.Equal(t, \"dafbfeb8-a129-4e7c-9cf0-e7996a701cdb\", data.InstanceID)\n \t\tassert.Equal(t, CodecJpeg, data.Codec)\n \t\tassert.Equal(t, \"0s\", data.Duration.String())\n-\t\tassert.Equal(t, \"2018-12-06 12:32:26 +0000 UTC\", data.TakenAtLocal.String())\n-\t\tassert.Equal(t, \"2018-12-06 11:32:26 +0000 UTC\", data.TakenAt.String())\n+\t\tassert.Equal(t, \"2018-12-06 12:32:26.6 +0000 UTC\", data.TakenAtLocal.String())\n+\t\tassert.Equal(t, \"2018-12-06 11:32:26.6 +0000 UTC\", data.TakenAt.String())\n \t\tassert.Equal(t, \"Europe/Berlin\", data.TimeZone)\n \t\tassert.Equal(t, 1024, data.Width)\n \t\tassert.Equal(t, 1365, data.Height)\n@@ -316,8 +316,8 @@ func TestJSON(t *testing.T) {\n \t\tassert.Equal(t, \"\", data.InstanceID)\n \t\tassert.Equal(t, CodecJpeg, data.Codec)\n \t\tassert.Equal(t, \"0s\", data.Duration.String())\n-\t\tassert.Equal(t, \"2018-12-06 12:32:26 +0000 UTC\", data.TakenAtLocal.String())\n-\t\tassert.Equal(t, \"2018-12-06 11:32:26 +0000 UTC\", data.TakenAt.String())\n+\t\tassert.Equal(t, \"2018-12-06 12:32:26.6 +0000 UTC\", data.TakenAtLocal.String())\n+\t\tassert.Equal(t, \"2018-12-06 11:32:26.6 +0000 UTC\", data.TakenAt.String())\n \t\tassert.Equal(t, \"Europe/Berlin\", data.TimeZone)\n \t\tassert.Equal(t, 1125, data.Width)\n \t\tassert.Equal(t, 1500, data.Height)"},{"message":"Fix the bug in the StringToDuration function in internal/meta/duration.go. In the time.ParseDuration branch, if there's an error, it still assigns the result to d, which will be zero. The function should be checking if err == nil before assigning the result to d.","diff":"diff --git a/internal/meta/duration.go b/internal/meta/duration.go\nindex 7120240..83625e7 100644\n--- a/internal/meta/duration.go\n+++ b/internal/meta/duration.go\n@@ -27,7 +27,7 @@ func StringToDuration(s string) (d time.Duration) {\n \t\ts, _ := strconv.Atoi(n[2])\n \n \t\td = time.Duration(h)*time.Hour + time.Duration(m)*time.Minute + time.Duration(s)*time.Second\n-\t} else if pd, err := time.ParseDuration(s); err != nil {\n+\t} else if pd, err := time.ParseDuration(s); err == nil {\n \t\td = pd\n \t}\n "},{"message":"Fix the bugs in the media processing subsystem:\n\n1. Fix the bug in the (Data) Exif method in internal/meta/exif.go where the code adds nanoseconds to the calculated UTC and local time (lines 296-301). The function calls Add(ns) on the result of Truncate(time.Second).UTC() and Truncate(time.Second), but these calls don't modify the original time.Time values because time.Time is immutable in Go. The results of these calls are discarded. The results should be assigned back to data.TakenAt and data.TakenAtLocal.\n\n2. Fix the bug in the (Data) Exiftool method in internal/meta/json_exiftool.go where the code adds nanoseconds to the calculated UTC and local time (lines 236-241). The function calls Add(ns) on the result of Truncate(time.Second).UTC() and Truncate(time.Second), but these calls don't modify the original time.Time values because time.Time is immutable in Go. The results of these calls are discarded. The results should be assigned back to data.TakenAt and data.TakenAtLocal.\n\n3. Fix the bug in the StringToDuration function in internal/meta/duration.go. In the time.ParseDuration branch, if there's an error, it still assigns the result to d, which will be zero. It should be checking if err == nil before assigning the result to d.\n\n4. Add nil checks to the Resample function in internal/thumb/resample.go to prevent panics if a nil image is passed to the function.\n\n5. Add nil checks to the Rotate function in internal/thumb/rotate.go to prevent panics if a nil image is passed to the function.","diff":"diff --git a/internal/meta/duration.go b/internal/meta/duration.go\nindex 83625e7..c46c79b 100644\n--- a/internal/meta/duration.go\n+++ b/internal/meta/duration.go\n@@ -27,8 +27,10 @@ func StringToDuration(s string) (d time.Duration) {\n \t\ts, _ := strconv.Atoi(n[2])\n \n \t\td = time.Duration(h)*time.Hour + time.Duration(m)*time.Minute + time.Duration(s)*time.Second\n-\t} else if pd, err := time.ParseDuration(s); err == nil {\n-\t\td = pd\n+\t} else {\n+\t\tif pd, err := time.ParseDuration(s); err == nil {\n+\t\t\td = pd\n+\t\t}\n \t}\n \n \treturn d\ndiff --git a/internal/thumb/resample.go b/internal/thumb/resample.go\nindex 410853b..f45bd14 100644\n--- a/internal/thumb/resample.go\n+++ b/internal/thumb/resample.go\n@@ -8,6 +8,11 @@ import (\n \n // Resample downscales an image and returns it.\n func Resample(img image.Image, width, height int, opts ...ResampleOption) image.Image {\n+\t// Return nil if input image is nil to prevent panic\n+\tif img == nil {\n+\t\treturn nil\n+\t}\n+\t\n \tvar resImg image.Image\n \n \tmethod, filter, _ := ResampleOptions(opts...)\ndiff --git a/internal/thumb/rotate.go b/internal/thumb/rotate.go\nindex b6a8cf6..fd35866 100644\n--- a/internal/thumb/rotate.go\n+++ b/internal/thumb/rotate.go\n@@ -20,6 +20,11 @@ const (\n \n // Rotate rotates an image based on the Exif orientation.\n func Rotate(img image.Image, o int) image.Image {\n+\t// Return nil if input image is nil to prevent panic\n+\tif img == nil {\n+\t\treturn nil\n+\t}\n+\t\n \tswitch o {\n \tcase OrientationUnspecified:\n \t\t// Do nothing."},{"message":"Fix the remaining bugs in the media processing subsystem:\n\n1. Add division by zero protection in the FileWidth method of the Area struct in internal/crop/area.go. While NewArea ensures values are clipped to be at least 0, if a.W is exactly 0, this could cause a division by zero error.\n\n2. Add division by zero protection in the FileWidth function in internal/crop/image.go. There's no check if area.W is 0, which could lead to a division by zero error.\n\n3. Add validation for the srcFilename and jpgFilename parameters in the Jpeg function in internal/thumb/jpeg.go to prevent empty string parameters from causing unexpected behavior.\n\n4. Add validation of the width and height parameters in the Resample function in internal/thumb/resample.go to prevent unexpected behavior or resource exhaustion if these are negative or extremely large.\n\n5. Add path traversal protection for file paths in the FromRequest function in internal/crop/request.go, the FileName function in internal/crop/cache.go, and other file handling functions to prevent path traversal vulnerabilities.\n\n6. Add size limits when reading files with os.ReadFile in various functions to prevent resource exhaustion when processing large files.","diff":"diff --git a/internal/crop/area.go b/internal/crop/area.go\nindex c2b2163..54fb9f3 100644\n--- a/internal/crop/area.go\n+++ b/internal/crop/area.go\n@@ -58,6 +58,9 @@ func (a Area) Bounds(img image.Image) (min, max image.Point, dim int) {\n \n // FileWidth returns the ideal file width based on the crop size.\n func (a Area) FileWidth(size Size) int {\n+\tif a.W <= 0 {\n+\t\treturn size.Width\n+\t}\n \treturn int(float32(size.Width) / a.W)\n }\n \ndiff --git a/internal/crop/cache.go b/internal/crop/cache.go\nindex 0bfe22a..2289602 100644\n--- a/internal/crop/cache.go\n+++ b/internal/crop/cache.go\n@@ -3,8 +3,8 @@ package crop\n import (\n \t\"fmt\"\n \t\"path/filepath\"\n-\n \t\"path\"\n+\t\"strings\"\n \n \t\"github.com/photoprism/photoprism/pkg/clean\"\n \t\"github.com/photoprism/photoprism/pkg/fs\"\n@@ -30,10 +30,23 @@ func FileName(hash, area string, width, height int, thumbPath string) (fileName\n \tif len(hash) < 4 {\n \t\treturn \"\", fmt.Errorf(\"crop: invalid file hash %s\", clean.Log(hash))\n \t}\n+\t\n+\t// Check for path traversal attempts\n+\tif filepath.Clean(hash) != hash || filepath.IsAbs(hash) || \n+\t   strings.Contains(hash, \"..\") || strings.Contains(hash, \"/\") || strings.Contains(hash, \"\\\\\") {\n+\t\treturn \"\", fmt.Errorf(\"crop: invalid hash format: %s\", clean.Log(hash))\n+\t}\n \n \tif len(thumbPath) < 1 {\n \t\treturn \"\", fmt.Errorf(\"crop: cache path missing\")\n \t}\n+\t\n+\t// Ensure thumbPath is absolute\n+\tabsThumbPath, err := filepath.Abs(thumbPath)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"crop: invalid thumb path: %s\", err)\n+\t}\n+\tthumbPath = absThumbPath\n \n \tif width < 1 || height < 1 || width > 2048 || height > 2048 {\n \t\treturn \"\", fmt.Errorf(\"crop: invalid size %dx%d\", width, height)\ndiff --git a/internal/crop/image.go b/internal/crop/image.go\nindex e53ce3d..852dee2 100644\n--- a/internal/crop/image.go\n+++ b/internal/crop/image.go\n@@ -118,6 +118,9 @@ func ThumbFileName(hash string, area Area, size Size, thumbPath string) (string,\n \n // FileWidth returns the minimal thumbnail width based on crop area and size.\n func FileWidth(area Area, size Size) int {\n+\tif area.W <= 0 {\n+\t\treturn size.Width\n+\t}\n \treturn int(float32(size.Width) / area.W)\n }\n \ndiff --git a/internal/crop/request.go b/internal/crop/request.go\nindex c00e353..611f6a3 100644\n--- a/internal/crop/request.go\n+++ b/internal/crop/request.go\n@@ -6,6 +6,7 @@ import (\n \t\"image\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"strings\"\n \n \t\"github.com/disintegration/imaging\"\n \t\"github.com/photoprism/photoprism/internal/thumb\"\n@@ -14,6 +15,29 @@ import (\n \n // FromRequest returns the crop file name for an image hash, and creates it if needed.\n func FromRequest(hash, area string, size Size, thumbPath string) (fileName string, err error) {\n+\t// Validate hash to prevent path traversal\n+\tif hash == \"\" {\n+\t\treturn \"\", fmt.Errorf(\"empty hash\")\n+\t}\n+\t\n+\t// Check for path traversal attempts\n+\tif filepath.Clean(hash) != hash || filepath.IsAbs(hash) || \n+\t   strings.Contains(hash, \"..\") || strings.Contains(hash, \"/\") || strings.Contains(hash, \"\\\\\") {\n+\t\treturn \"\", fmt.Errorf(\"invalid hash format: %s\", hash)\n+\t}\n+\t\n+\t// Validate thumbPath\n+\tif thumbPath == \"\" {\n+\t\treturn \"\", fmt.Errorf(\"empty thumb path\")\n+\t}\n+\t\n+\t// Ensure thumbPath is absolute\n+\tabsThumbPath, err := filepath.Abs(thumbPath)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"invalid thumb path: %s\", err)\n+\t}\n+\tthumbPath = absThumbPath\n+\t\n \tif fileName, err = FromCache(hash, area, size, thumbPath); err == nil {\n \t\treturn fileName, err\n \t}\n@@ -30,8 +54,20 @@ func FromRequest(hash, area string, size Size, thumbPath string) (fileName strin\n \tcropBase := fmt.Sprintf(\"%s_%dx%d_crop_%s%s\", hash, size.Width, size.Height, area, fs.ExtJPEG)\n \tcropName := filepath.Join(filepath.Dir(thumbName), cropBase)\n \n-\timageBuffer, err := os.ReadFile(thumbName)\n+\t// Check file size before reading to prevent resource exhaustion\n+\tconst maxFileSize = 100 * 1024 * 1024 // 100MB limit\n+\t\n+\tfileInfo, err := os.Stat(thumbName)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\t\n+\tif fileInfo.Size() > maxFileSize {\n+\t\treturn \"\", fmt.Errorf(\"file too large: %s (size: %d bytes, max: %d bytes)\", \n+\t\t\tfilepath.Base(thumbName), fileInfo.Size(), maxFileSize)\n+\t}\n \n+\timageBuffer, err := os.ReadFile(thumbName)\n \tif err != nil {\n \t\treturn \"\", err\n \t}\ndiff --git a/internal/thumb/jpeg.go b/internal/thumb/jpeg.go\nindex bddabd1..8a6b7ba 100644\n--- a/internal/thumb/jpeg.go\n+++ b/internal/thumb/jpeg.go\n@@ -1,6 +1,7 @@\n package thumb\n \n import (\n+\t\"fmt\"\n \t\"image\"\n \t\"path/filepath\"\n \n@@ -9,6 +10,15 @@ import (\n )\n \n func Jpeg(srcFilename, jpgFilename string, orientation int) (img image.Image, err error) {\n+\t// Validate input parameters\n+\tif srcFilename == \"\" {\n+\t\treturn nil, fmt.Errorf(\"source filename is empty\")\n+\t}\n+\t\n+\tif jpgFilename == \"\" {\n+\t\treturn nil, fmt.Errorf(\"destination filename is empty\")\n+\t}\n+\t\n \timg, err = imaging.Open(srcFilename)\n \n \tif err != nil {\ndiff --git a/internal/thumb/resample.go b/internal/thumb/resample.go\nindex f45bd14..00c673c 100644\n--- a/internal/thumb/resample.go\n+++ b/internal/thumb/resample.go\n@@ -13,6 +13,27 @@ func Resample(img image.Image, width, height int, opts ...ResampleOption) image.\n \t\treturn nil\n \t}\n \t\n+\t// Validate width and height parameters\n+\tconst maxDimension = 16384 // Common maximum texture size\n+\t\n+\tif width <= 0 || height <= 0 {\n+\t\t// Invalid dimensions, return original image\n+\t\treturn img\n+\t}\n+\t\n+\tif width > maxDimension || height > maxDimension {\n+\t\t// Dimensions too large, could cause resource exhaustion\n+\t\t// Scale down to maximum allowed\n+\t\tif width > maxDimension {\n+\t\t\theight = height * maxDimension / width\n+\t\t\twidth = maxDimension\n+\t\t}\n+\t\tif height > maxDimension {\n+\t\t\twidth = width * maxDimension / height\n+\t\t\theight = maxDimension\n+\t\t}\n+\t}\n+\t\n \tvar resImg image.Image\n \n \tmethod, filter, _ := ResampleOptions(opts...)"},{"message":"Analyze and answer the remaining questions about the media processing subsystem:\n\n1. In the SanitizeMeta function in internal/meta/sanitize.go, is there any protection against resource exhaustion when parsing potentially large JSON arrays with json.Unmarshal?\n\n2. In the RawExif function in internal/meta/exif_parser.go, is there any validation that the fileName parameter is safe or within allowed directories?\n\n3. Does the RawExif function in internal/meta/exif_parser.go implement any size limits when processing files?\n\n4. In the (Data) JSON method in internal/meta/json.go, is there any validation that the jsonName parameter is safe or within allowed directories?\n\n5. Does the (Data) JSON method in internal/meta/json.go implement any size limits when reading files with os.ReadFile?\n\n6. In the (Data) XMP method in internal/meta/xmp.go, is there any validation that the fileName parameter is safe or within allowed directories?\n\n7. Does the XmpDocument.Load() method called in (Data) XMP implement any size limits when reading files?\n\n8. In the (XmpDocument) Load method in internal/meta/xmp_document.go, is there any validation that the filename parameter is safe or within allowed directories?\n\n9. Does the (XmpDocument) Load method in internal/meta/xmp_document.go implement any size limits when reading files with os.ReadFile or when parsing XML with xml.Unmarshal?\n\n10. In the FileName, FromCache, FromFile, and Create functions in internal/thumb/create.go, is there any validation that the thumbPath or fileName parameters are safe or within allowed directories?\n\n11. Does the FromFile function in internal/thumb/create.go implement any size limits when loading images with the Open function?\n\n12. In the Open function in internal/thumb/open.go, is there any validation that the fileName parameter is safe or within allowed directories?\n\n13. Does the Open function in internal/thumb/open.go implement any size limits when loading images with imaging.Open or OpenJpeg?\n\n14. In the OpenJpeg function in internal/thumb/open_jpeg.go, is there any validation that the fileName parameter is safe or within allowed directories?\n\n15. Does the OpenJpeg function in internal/thumb/open_jpeg.go implement any size limits when reading files?\n\n16. In the Jpeg function in internal/thumb/jpeg.go, is there any validation that the srcFilename and jpgFilename parameters are safe or within allowed directories?\n\n17. Does the Jpeg function in internal/thumb/jpeg.go implement any size limits when loading images with imaging.Open?","diff":""},{"message":"Fix the security vulnerabilities in the media processing subsystem:\n\n1. Add path traversal protection for file paths in the RawExif function in internal/meta/exif_parser.go.\n\n2. Add path traversal protection for file paths in the (Data) JSON method in internal/meta/json.go.\n\n3. Add path traversal protection for file paths in the (Data) XMP method in internal/meta/xmp.go.\n\n4. Add path traversal protection for file paths in the (XmpDocument) Load method in internal/meta/xmp_document.go.\n\n5. Add path traversal protection for file paths in the FileName, FromCache, FromFile, and Create functions in internal/thumb/create.go.\n\n6. Add path traversal protection for file paths in the Open function in internal/thumb/open.go.\n\n7. Add path traversal protection for file paths in the OpenJpeg function in internal/thumb/open_jpeg.go.\n\n8. Add path traversal protection for file paths in the Jpeg function in internal/thumb/jpeg.go.\n\n9. Add size limits when reading files with os.ReadFile in the RawExif function in internal/meta/exif_parser.go.\n\n10. Add size limits when reading files with os.ReadFile in the (Data) JSON method in internal/meta/json.go.\n\n11. Add size limits when reading files with os.ReadFile in the (XmpDocument) Load method in internal/meta/xmp_document.go.\n\n12. Add size limits when loading images in the FromFile function in internal/thumb/create.go.\n\n13. Add size limits when loading images in the Open function in internal/thumb/open.go.\n\n14. Add size limits when reading files in the OpenJpeg function in internal/thumb/open_jpeg.go.\n\n15. Add size limits when loading images in the Jpeg function in internal/thumb/jpeg.go.\n\n16. Add protection against resource exhaustion when parsing potentially large JSON arrays with json.Unmarshal in the SanitizeMeta function in internal/meta/sanitize.go.","diff":"diff --git a/internal/meta/exif_parser.go b/internal/meta/exif_parser.go\nindex 72223f6..0ecf457 100644\n--- a/internal/meta/exif_parser.go\n+++ b/internal/meta/exif_parser.go\n@@ -2,6 +2,7 @@ package meta\n \n import (\n \t\"fmt\"\n+\t\"os\"\n \t\"path/filepath\"\n \t\"runtime/debug\"\n \t\"strings\"\n@@ -16,6 +17,10 @@ import (\n \t\"github.com/photoprism/photoprism/pkg/fs\"\n )\n \n+// MaxFileSize represents the maximum file size in bytes that can be processed\n+// to prevent resource exhaustion (50MB)\n+const MaxFileSize = 50 * 1024 * 1024\n+\n func RawExif(fileName string, fileFormat fs.Type, bruteForce bool) (rawExif []byte, err error) {\n \tdefer func() {\n \t\tif e := recover(); e != nil {\n@@ -23,6 +28,21 @@ func RawExif(fileName string, fileFormat fs.Type, bruteForce bool) (rawExif []by\n \t\t}\n \t}()\n \n+\t// Check for path traversal attempts\n+\tif strings.Contains(fileName, \"../\") || strings.Contains(fileName, \"..\\\\\") {\n+\t\treturn nil, fmt.Errorf(\"path traversal attempt detected in file path: %s\", clean.Log(filepath.Base(fileName)))\n+\t}\n+\n+\t// Check file size to prevent resource exhaustion\n+\tfileInfo, err := os.Stat(fileName)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to get file info: %s\", err)\n+\t}\n+\t\n+\tif fileInfo.Size() > MaxFileSize {\n+\t\treturn nil, fmt.Errorf(\"file size exceeds maximum allowed size (%d bytes): %s\", MaxFileSize, clean.Log(filepath.Base(fileName)))\n+\t}\n+\n \t// Extract raw Exif block.\n \tvar parsed bool\n \ndiff --git a/internal/meta/json.go b/internal/meta/json.go\nindex 3750a7e..c53d76c 100644\n--- a/internal/meta/json.go\n+++ b/internal/meta/json.go\n@@ -6,6 +6,7 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \t\"runtime/debug\"\n+\t\"strings\"\n \n \t\"github.com/photoprism/photoprism/pkg/clean\"\n \t\"github.com/photoprism/photoprism/pkg/fs\"\n@@ -26,12 +27,27 @@ func (data *Data) JSON(jsonName, originalName string) (err error) {\n \t\t}\n \t}()\n \n+\t// Check for path traversal attempts\n+\tif strings.Contains(jsonName, \"../\") || strings.Contains(jsonName, \"..\\\\\") {\n+\t\treturn fmt.Errorf(\"path traversal attempt detected in file path: %s\", clean.Log(filepath.Base(jsonName)))\n+\t}\n+\n \tquotedName := clean.Log(filepath.Base(jsonName))\n \n \tif !fs.FileExists(jsonName) {\n \t\treturn fmt.Errorf(\"metadata: %s not found\", quotedName)\n \t}\n \n+\t// Check file size to prevent resource exhaustion\n+\tfileInfo, err := os.Stat(jsonName)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to get file info: %s\", err)\n+\t}\n+\t\n+\tif fileInfo.Size() > MaxFileSize {\n+\t\treturn fmt.Errorf(\"file size exceeds maximum allowed size (%d bytes): %s\", MaxFileSize, quotedName)\n+\t}\n+\n \tjsonData, err := os.ReadFile(jsonName)\n \n \tif err != nil {\ndiff --git a/internal/meta/sanitize.go b/internal/meta/sanitize.go\nindex 6dd72c0..0a06f2d 100644\n--- a/internal/meta/sanitize.go\n+++ b/internal/meta/sanitize.go\n@@ -123,17 +123,38 @@ func SanitizeDescription(s string) string {\n \treturn s\n }\n \n+// MaxJSONArraySize represents the maximum size of a JSON array that can be processed\n+// to prevent resource exhaustion (1MB)\n+const MaxJSONArraySize = 1 * 1024 * 1024\n+\n // SanitizeMeta normalizes metadata fields that may contain JSON arrays like keywords and subject.\n func SanitizeMeta(s string) string {\n \tif s == \"\" {\n \t\treturn \"\"\n \t} else if strings.HasPrefix(s, \"[\") && strings.HasSuffix(s, \"]\") {\n+\t\t// Check if the JSON array is too large to prevent resource exhaustion\n+\t\tif len(s) > MaxJSONArraySize {\n+\t\t\tlog.Warnf(\"sanitize: JSON array too large (%d bytes), skipping unmarshal\", len(s))\n+\t\t\treturn SanitizeString(s)\n+\t\t}\n+\n \t\tvar words []string\n \n-\t\tif err := json.Unmarshal([]byte(s), &words); err != nil {\n+\t\t// Limit the number of elements in the array to prevent resource exhaustion\n+\t\tdecoder := json.NewDecoder(strings.NewReader(s))\n+\t\tdecoder.UseNumber() // To prevent large numbers from using too much memory\n+\n+\t\tif err := decoder.Decode(&words); err != nil {\n \t\t\treturn s\n \t\t}\n \n+\t\t// Limit the number of elements to process\n+\t\tconst maxElements = 1000\n+\t\tif len(words) > maxElements {\n+\t\t\tlog.Warnf(\"sanitize: JSON array has too many elements (%d), truncating to %d\", len(words), maxElements)\n+\t\t\twords = words[:maxElements]\n+\t\t}\n+\n \t\ts = strings.Join(words, \", \")\n \t} else {\n \t\ts = SanitizeString(s)\ndiff --git a/internal/meta/xmp.go b/internal/meta/xmp.go\nindex 6cf6156..79837de 100644\n--- a/internal/meta/xmp.go\n+++ b/internal/meta/xmp.go\n@@ -4,6 +4,7 @@ import (\n \t\"fmt\"\n \t\"path/filepath\"\n \t\"runtime/debug\"\n+\t\"strings\"\n \n \t\"github.com/photoprism/photoprism/pkg/clean\"\n )\n@@ -23,6 +24,11 @@ func (data *Data) XMP(fileName string) (err error) {\n \t\t}\n \t}()\n \n+\t// Check for path traversal attempts\n+\tif strings.Contains(fileName, \"../\") || strings.Contains(fileName, \"..\\\\\") {\n+\t\treturn fmt.Errorf(\"path traversal attempt detected in file path: %s\", clean.Log(filepath.Base(fileName)))\n+\t}\n+\n \tdoc := XmpDocument{}\n \n \tif err := doc.Load(fileName); err != nil {\ndiff --git a/internal/meta/xmp_document.go b/internal/meta/xmp_document.go\nindex 93ab95a..1f15959 100644\n--- a/internal/meta/xmp_document.go\n+++ b/internal/meta/xmp_document.go\n@@ -2,7 +2,9 @@ package meta\n \n import (\n \t\"encoding/xml\"\n+\t\"fmt\"\n \t\"os\"\n+\t\"path/filepath\"\n \t\"strings\"\n \t\"time\"\n )\n@@ -200,6 +202,21 @@ type XmpDocument struct {\n \n // Load parses an XMP file and populates document values with its contents.\n func (doc *XmpDocument) Load(filename string) error {\n+\t// Check for path traversal attempts\n+\tif strings.Contains(filename, \"../\") || strings.Contains(filename, \"..\\\\\") {\n+\t\treturn fmt.Errorf(\"path traversal attempt detected in file path: %s\", filepath.Base(filename))\n+\t}\n+\n+\t// Check file size to prevent resource exhaustion\n+\tfileInfo, err := os.Stat(filename)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to get file info: %s\", err)\n+\t}\n+\t\n+\tif fileInfo.Size() > MaxFileSize {\n+\t\treturn fmt.Errorf(\"file size exceeds maximum allowed size (%d bytes): %s\", MaxFileSize, filepath.Base(filename))\n+\t}\n+\n \tdata, err := os.ReadFile(filename)\n \n \tif err != nil {\ndiff --git a/internal/thumb/create.go b/internal/thumb/create.go\nindex 53e884d..b407a6f 100644\n--- a/internal/thumb/create.go\n+++ b/internal/thumb/create.go\n@@ -8,6 +8,7 @@ import (\n \t\"os\"\n \t\"path\"\n \t\"path/filepath\"\n+\t\"strings\"\n \n \t\"github.com/disintegration/imaging\"\n \n@@ -41,6 +42,16 @@ func FileName(hash string, thumbPath string, width, height int, opts ...Resample\n \tif len(thumbPath) == 0 {\n \t\treturn \"\", errors.New(\"resample: folder is empty\")\n \t}\n+\t\n+\t// Check for path traversal attempts in hash\n+\tif strings.Contains(hash, \"../\") || strings.Contains(hash, \"..\\\\\") || strings.Contains(hash, \"/\") || strings.Contains(hash, \"\\\\\") {\n+\t\treturn \"\", fmt.Errorf(\"resample: hash contains invalid characters (%s)\", clean.Log(hash))\n+\t}\n+\t\n+\t// Check for path traversal attempts in thumbPath\n+\tif strings.Contains(thumbPath, \"../\") || strings.Contains(thumbPath, \"..\\\\\") {\n+\t\treturn \"\", fmt.Errorf(\"resample: path traversal attempt detected in thumb path: %s\", clean.Log(thumbPath))\n+\t}\n \n \tsuffix := Suffix(width, height, opts...)\n \tp := path.Join(thumbPath, hash[0:1], hash[1:2], hash[2:3])\n@@ -80,6 +91,11 @@ func FromCache(imageFilename, hash, thumbPath string, width, height int, opts ..\n \n // FromFile returns the thumb cache file name for an image, and creates it if needed.\n func FromFile(imageFilename, hash, thumbPath string, width, height, orientation int, opts ...ResampleOption) (fileName string, err error) {\n+\t// Check for path traversal attempts in imageFilename\n+\tif strings.Contains(imageFilename, \"../\") || strings.Contains(imageFilename, \"..\\\\\") {\n+\t\treturn \"\", fmt.Errorf(\"resample: path traversal attempt detected in image filename: %s\", clean.Log(filepath.Base(imageFilename)))\n+\t}\n+\n \tif fileName, err := FromCache(imageFilename, hash, thumbPath, width, height, opts...); err == nil {\n \t\treturn fileName, err\n \t} else if err != ErrThumbNotCached {\n@@ -94,6 +110,16 @@ func FromFile(imageFilename, hash, thumbPath string, width, height, orientation\n \t\treturn \"\", err\n \t}\n \n+\t// Check file size to prevent resource exhaustion\n+\tfileInfo, err := os.Stat(imageFilename)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"failed to get file info: %s\", err)\n+\t}\n+\t\n+\tif fileInfo.Size() > MaxFileSize {\n+\t\treturn \"\", fmt.Errorf(\"file size exceeds maximum allowed size (%d bytes): %s\", MaxFileSize, clean.Log(filepath.Base(imageFilename)))\n+\t}\n+\n \t// Load image from storage.\n \timg, err := Open(imageFilename, orientation)\n \n@@ -119,6 +145,11 @@ func Create(img image.Image, fileName string, width, height int, opts ...Resampl\n \tif InvalidSize(height) {\n \t\treturn img, fmt.Errorf(\"resample: height has an invalid value (%d)\", height)\n \t}\n+\t\n+\t// Check for path traversal attempts in fileName\n+\tif strings.Contains(fileName, \"../\") || strings.Contains(fileName, \"..\\\\\") {\n+\t\treturn img, fmt.Errorf(\"resample: path traversal attempt detected in file name: %s\", clean.Log(filepath.Base(fileName)))\n+\t}\n \n \tresult = Resample(img, width, height, opts...)\n \ndiff --git a/internal/thumb/jpeg.go b/internal/thumb/jpeg.go\nindex 8a6b7ba..07d2136 100644\n--- a/internal/thumb/jpeg.go\n+++ b/internal/thumb/jpeg.go\n@@ -3,7 +3,9 @@ package thumb\n import (\n \t\"fmt\"\n \t\"image\"\n+\t\"os\"\n \t\"path/filepath\"\n+\t\"strings\"\n \n \t\"github.com/disintegration/imaging\"\n \t\"github.com/photoprism/photoprism/pkg/clean\"\n@@ -19,6 +21,26 @@ func Jpeg(srcFilename, jpgFilename string, orientation int) (img image.Image, er\n \t\treturn nil, fmt.Errorf(\"destination filename is empty\")\n \t}\n \t\n+\t// Check for path traversal attempts in source filename\n+\tif strings.Contains(srcFilename, \"../\") || strings.Contains(srcFilename, \"..\\\\\") {\n+\t\treturn nil, fmt.Errorf(\"path traversal attempt detected in source file path: %s\", filepath.Base(srcFilename))\n+\t}\n+\t\n+\t// Check for path traversal attempts in destination filename\n+\tif strings.Contains(jpgFilename, \"../\") || strings.Contains(jpgFilename, \"..\\\\\") {\n+\t\treturn nil, fmt.Errorf(\"path traversal attempt detected in destination file path: %s\", filepath.Base(jpgFilename))\n+\t}\n+\t\n+\t// Check file size to prevent resource exhaustion\n+\tfileInfo, err := os.Stat(srcFilename)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to get file info: %s\", err)\n+\t}\n+\t\n+\tif fileInfo.Size() > MaxFileSize {\n+\t\treturn nil, fmt.Errorf(\"file size exceeds maximum allowed size (%d bytes): %s\", MaxFileSize, filepath.Base(srcFilename))\n+\t}\n+\t\n \timg, err = imaging.Open(srcFilename)\n \n \tif err != nil {\ndiff --git a/internal/thumb/open_jpeg.go b/internal/thumb/open_jpeg.go\nindex 85c3301..2038b13 100644\n--- a/internal/thumb/open_jpeg.go\n+++ b/internal/thumb/open_jpeg.go\n@@ -5,6 +5,7 @@ import (\n \t\"image\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"strings\"\n \n \t\"github.com/disintegration/imaging\"\n \t\"github.com/mandykoh/prism/meta/autometa\"\n@@ -13,12 +14,31 @@ import (\n \t\"github.com/photoprism/photoprism/pkg/colors\"\n )\n \n+// MaxFileSize represents the maximum file size in bytes that can be processed\n+// to prevent resource exhaustion (50MB)\n+const MaxFileSize = 50 * 1024 * 1024\n+\n // OpenJpeg loads a JPEG image from disk, rotates it, and converts the color profile if necessary.\n func OpenJpeg(fileName string, orientation int) (result image.Image, err error) {\n \tif fileName == \"\" {\n \t\treturn result, fmt.Errorf(\"filename missing\")\n \t}\n \n+\t// Check for path traversal attempts\n+\tif strings.Contains(fileName, \"../\") || strings.Contains(fileName, \"..\\\\\") {\n+\t\treturn result, fmt.Errorf(\"path traversal attempt detected in file path: %s\", filepath.Base(fileName))\n+\t}\n+\n+\t// Check file size to prevent resource exhaustion\n+\tfileInfo, err := os.Stat(fileName)\n+\tif err != nil {\n+\t\treturn result, fmt.Errorf(\"failed to get file info: %s\", err)\n+\t}\n+\t\n+\tif fileInfo.Size() > MaxFileSize {\n+\t\treturn result, fmt.Errorf(\"file size exceeds maximum allowed size (%d bytes): %s\", MaxFileSize, filepath.Base(fileName))\n+\t}\n+\n \tlogName := clean.Log(filepath.Base(fileName))\n \n \t// Open file."}]}]}