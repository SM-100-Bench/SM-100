{"scanned_subsystems":[{"name":"Authentication and Authorization","files":["auth/auth_context.go","auth/authzserver/authorize.go","auth/authzserver/doc.go","auth/authzserver/encryptor.go","auth/authzserver/initialize.go","auth/authzserver/metadata.go","auth/authzserver/metadata_provider.go","auth/authzserver/provider.go","auth/authzserver/resource_server.go","auth/authzserver/stateless_token_store.go","auth/authzserver/token.go","auth/authzserver/utils.go","auth/config/authorizationservertype_enumer.go","auth/config/config.go","auth/config/config_flags.go","auth/config/samesite_enumer.go","auth/config/testdata/config.yaml","auth/config/testdata/secret.yaml","auth/config/third_party_config.go","auth/constants.go","auth/cookie.go","auth/cookie_manager.go","auth/handler_utils.go","auth/handlers.go","auth/identity_context.go","auth/init_secrets.go","auth/interceptor.go","auth/interfaces/context.go","auth/interfaces/cookie.go","auth/interfaces/mocks/authentication_context.go","auth/interfaces/mocks/cookie_handler.go","auth/interfaces/mocks/handler_registerer.go","auth/interfaces/mocks/identity_context.go","auth/interfaces/mocks/o_auth2_provider.go","auth/interfaces/mocks/o_auth2_resource_server.go","auth/token.go","auth/user_info_provider.go"]}],"changesets":[{"title":"Bismuth: fix 8 bugs in Authentication and Authorization","body":"Fixes:\n- Fix the security vulnerability in auth/init_secrets.go where the writeSecrets function creates files with os.ModePerm (0777) permissions, which is overly permissive for sensitive key files. Change the permissions to 0600 (read/write for owner only) to ensure that only the process running with the appropriate user permissions can access these critical security files.\n- Fix the security vulnerability in auth/authzserver/metadata_provider.go where the HTTP request to external servers in GetOAuth2Metadata has no timeout, which could lead to resource exhaustion. Implement a reasonable timeout for the HTTP client to ensure requests don't hang indefinitely.\n- Fix the security vulnerability in auth/interceptor.go where the BlanketAuthorization function returns an 'Unauthenticated' error code when the issue is actually authorization (scope check). Change it to use codes.PermissionDenied instead for more accurate error reporting when a user is authenticated but lacks the required scope.\n- Fix the security vulnerability in auth/cookie.go where the NewCsrfToken function uses math/rand instead of crypto/rand for generating CSRF tokens. Replace the insecure random number generation with cryptographically secure random generation using crypto/rand to prevent predictable CSRF tokens that attackers could exploit.\n- Fix the security vulnerability in auth/cookie_manager.go where the DeleteCookies function only deletes access and refresh tokens, but not ID token or user info cookies. Update the function to also delete the ID token and user info cookies to ensure complete logout and prevent user data from remaining accessible.\n- Fix the security vulnerability in auth/cookie.go where the NewSecureCookie function doesn't set HttpOnly or Secure flags on cookies. Update the function to set both flags by default to protect sensitive cookie data from client-side scripts and network sniffing.\n- Fix the security vulnerability in auth/cookie.go where the getAuthFlowEndRedirect function prioritizes redirect URLs from query parameters without validation. Update the function to validate redirect URLs from query parameters to prevent open redirect attacks.\n- Fix multiple security issues in auth/token.go:\n1. Fix the error handling for expired tokens in ParseIDTokenAndValidate by using a more robust approach than string matching\n2. Fix the GRPCGetIdentityFromIDToken function to properly handle errors when unmarshaling user info instead of just logging them\n3. Fix the copy-paste error in the error message in GRPCGetIdentityFromIDToken where it mentions 'Bearer scheme' but is checking for IDTokenScheme\n4. Review and document the automatic granting of 'all' scope to every authenticated user in IdentityContextFromIDTokenToken","commits":[{"message":"Fix the security vulnerability in auth/init_secrets.go where the writeSecrets function creates files with os.ModePerm (0777) permissions, which is overly permissive for sensitive key files. Change the permissions to 0600 (read/write for owner only) to ensure that only the process running with the appropriate user permissions can access these critical security files.","diff":"diff --git a/auth/init_secrets.go b/auth/init_secrets.go\nindex 64e95c0..771e6ce 100644\n--- a/auth/init_secrets.go\n+++ b/auth/init_secrets.go\n@@ -78,28 +78,28 @@ type SecretsSet struct {\n }\n \n func writeSecrets(ctx context.Context, secrets SecretsSet, path string) error {\n-\terr := ioutil.WriteFile(filepath.Join(path, config.SecretNameClaimSymmetricKey), []byte(base64.RawStdEncoding.EncodeToString(secrets.TokenHashKey)), os.ModePerm)\n+\terr := ioutil.WriteFile(filepath.Join(path, config.SecretNameClaimSymmetricKey), []byte(base64.RawStdEncoding.EncodeToString(secrets.TokenHashKey)), 0600)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"failed to persist token hash key. Error: %w\", err)\n \t}\n \n \tlogger.Infof(ctx, \"wrote %v\", config.SecretNameClaimSymmetricKey)\n \n-\terr = ioutil.WriteFile(filepath.Join(path, config.SecretNameCookieHashKey), []byte(base64.RawStdEncoding.EncodeToString(secrets.CookieHashKey)), os.ModePerm)\n+\terr = ioutil.WriteFile(filepath.Join(path, config.SecretNameCookieHashKey), []byte(base64.RawStdEncoding.EncodeToString(secrets.CookieHashKey)), 0600)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"failed to persist cookie hash key. Error: %w\", err)\n \t}\n \n \tlogger.Infof(ctx, \"wrote %v\", config.SecretNameCookieHashKey)\n \n-\terr = ioutil.WriteFile(filepath.Join(path, config.SecretNameCookieBlockKey), []byte(base64.RawStdEncoding.EncodeToString(secrets.CookieBlockKey)), os.ModePerm)\n+\terr = ioutil.WriteFile(filepath.Join(path, config.SecretNameCookieBlockKey), []byte(base64.RawStdEncoding.EncodeToString(secrets.CookieBlockKey)), 0600)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"failed to persist cookie block key. Error: %w\", err)\n \t}\n \n \tlogger.Infof(ctx, \"wrote %v\", config.SecretNameCookieBlockKey)\n \n-\tkeyOut, err := os.OpenFile(filepath.Join(path, config.SecretNameTokenSigningRSAKey), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)\n+\tkeyOut, err := os.OpenFile(filepath.Join(path, config.SecretNameTokenSigningRSAKey), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)\n \tif err != nil {\n \t\treturn fmt.Errorf(\"failed to open key.pem for writing: %w\", err)\n \t}"},{"message":"Fix the security vulnerability in auth/authzserver/metadata_provider.go where the HTTP request to external servers in GetOAuth2Metadata has no timeout, which could lead to resource exhaustion. Implement a reasonable timeout for the HTTP client to ensure requests don't hang indefinitely.","diff":"diff --git a/auth/authzserver/metadata_provider.go b/auth/authzserver/metadata_provider.go\nindex 6e6ed79..a3add34 100644\n--- a/auth/authzserver/metadata_provider.go\n+++ b/auth/authzserver/metadata_provider.go\n@@ -6,6 +6,7 @@ import (\n \t\"net/http\"\n \t\"net/url\"\n \t\"strings\"\n+\t\"time\"\n \n \t\"github.com/flyteorg/flyteadmin/auth\"\n \n@@ -64,10 +65,16 @@ func (s OAuth2MetadataProvider) GetOAuth2Metadata(ctx context.Context, r *servic\n \t\t\texternalMetadataURL = baseURL.ResolveReference(oauth2MetadataEndpoint)\n \t\t}\n \n-\t\tresponse, err := http.Get(externalMetadataURL.String())\n+\t\t// Create an HTTP client with a timeout to prevent hanging connections\n+\t\tclient := &http.Client{\n+\t\t\tTimeout: 10 * time.Second,\n+\t\t}\n+\t\t\n+\t\tresponse, err := client.Get(externalMetadataURL.String())\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n+\t\tdefer response.Body.Close()\n \n \t\traw, err := ioutil.ReadAll(response.Body)\n \t\tif err != nil {"},{"message":"Fix the security vulnerability in auth/interceptor.go where the BlanketAuthorization function returns an 'Unauthenticated' error code when the issue is actually authorization (scope check). Change it to use codes.PermissionDenied instead for more accurate error reporting when a user is authenticated but lacks the required scope.","diff":"diff --git a/auth/interceptor.go b/auth/interceptor.go\nindex a4d78d4..2ea6aa8 100644\n--- a/auth/interceptor.go\n+++ b/auth/interceptor.go\n@@ -17,7 +17,7 @@ func BlanketAuthorization(ctx context.Context, req interface{}, _ *grpc.UnarySer\n \t}\n \n \tif !identityContext.Scopes().Has(ScopeAll) {\n-\t\treturn nil, status.Errorf(codes.Unauthenticated, \"authenticated user doesn't have required scope\")\n+\t\treturn nil, status.Errorf(codes.PermissionDenied, \"authenticated user doesn't have required scope\")\n \t}\n \n \treturn handler(ctx, req)\ndiff --git a/auth/interceptor_test.go b/auth/interceptor_test.go\nindex 862f76a..1ef0259 100644\n--- a/auth/interceptor_test.go\n+++ b/auth/interceptor_test.go\n@@ -40,7 +40,7 @@ func TestBlanketAuthorization(t *testing.T) {\n \t\tassert.NoError(t, err)\n \t\tassert.True(t, handlerCalled)\n \t})\n-\tt.Run(\"authenticated and not authorized\", func(t *testing.T) {\n+\tt.Run(\"authenticated but missing required scope\", func(t *testing.T) {\n \t\tidentityCtx := IdentityContext{\n \t\t\taudience: \"aud\",\n \t\t\tuserID:   \"uid\",\n@@ -55,7 +55,7 @@ func TestBlanketAuthorization(t *testing.T) {\n \t\t_, err := BlanketAuthorization(ctx, nil, nil, handler)\n \t\tasStatus, ok := status.FromError(err)\n \t\tassert.True(t, ok)\n-\t\tassert.Equal(t, asStatus.Code(), codes.Unauthenticated)\n+\t\tassert.Equal(t, asStatus.Code(), codes.PermissionDenied)\n \t\tassert.False(t, handlerCalled)\n \t})\n }"},{"message":"Fix the security vulnerability in auth/cookie.go where the NewCsrfToken function uses math/rand instead of crypto/rand for generating CSRF tokens. Replace the insecure random number generation with cryptographically secure random generation using crypto/rand to prevent predictable CSRF tokens that attackers could exploit.","diff":"diff --git a/auth/cookie.go b/auth/cookie.go\nindex a8093e4..44422f7 100644\n--- a/auth/cookie.go\n+++ b/auth/cookie.go\n@@ -2,12 +2,12 @@ package auth\n \n import (\n \t\"context\"\n+\t\"crypto/rand\"\n \t\"crypto/sha256\"\n \t\"encoding/hex\"\n-\t\"math/rand\"\n+\t\"math/big\"\n \t\"net/http\"\n \t\"net/url\"\n-\t\"time\"\n \n \t\"github.com/flyteorg/flyteadmin/auth/interfaces\"\n \t\"github.com/flyteorg/flytestdlib/errors\"\n@@ -111,18 +111,22 @@ func ReadSecureCookie(ctx context.Context, cookie http.Cookie, hashKey, blockKey\n \treturn \"\", errors.Wrapf(ErrSecureCookie, err, \"Error reading secure cookie %s\", cookie.Name)\n }\n \n-func NewCsrfToken(seed int64) string {\n-\trand.Seed(seed)\n+func NewCsrfToken() string {\n \tcsrfToken := [10]rune{}\n+\tmaxBig := big.NewInt(int64(len(AllowedChars)))\n \tfor i := 0; i < len(csrfToken); i++ {\n-\t\t/* #nosec */\n-\t\tcsrfToken[i] = AllowedChars[rand.Intn(len(AllowedChars))]\n+\t\tn, err := rand.Int(rand.Reader, maxBig)\n+\t\tif err != nil {\n+\t\t\t// If we can't get random numbers, we have bigger problems\n+\t\t\tpanic(err)\n+\t\t}\n+\t\tcsrfToken[i] = AllowedChars[n.Int64()]\n \t}\n \treturn string(csrfToken[:])\n }\n \n func NewCsrfCookie() http.Cookie {\n-\tcsrfStateToken := NewCsrfToken(time.Now().UnixNano())\n+\tcsrfStateToken := NewCsrfToken()\n \treturn http.Cookie{\n \t\tName:     csrfStateCookieName,\n \t\tValue:    csrfStateToken,\ndiff --git a/auth/cookie_test.go b/auth/cookie_test.go\nindex b525ba8..3ddbd57 100644\n--- a/auth/cookie_test.go\n+++ b/auth/cookie_test.go\n@@ -44,8 +44,14 @@ func TestSecureCookieLifecycle(t *testing.T) {\n }\n \n func TestNewCsrfToken(t *testing.T) {\n-\tcsrf := NewCsrfToken(5)\n-\tassert.Equal(t, \"5qz3p9w8qo\", csrf)\n+\tcsrf := NewCsrfToken()\n+\t// Check that the token is the expected length\n+\tassert.Equal(t, 10, len(csrf))\n+\t\n+\t// Check that all characters in the token are from the allowed set\n+\tfor _, c := range csrf {\n+\t\tassert.Contains(t, string(AllowedChars), string(c))\n+\t}\n }\n \n func TestNewCsrfCookie(t *testing.T) {"},{"message":"Fix the security vulnerability in auth/cookie_manager.go where the DeleteCookies function only deletes access and refresh tokens, but not ID token or user info cookies. Update the function to also delete the ID token and user info cookies to ensure complete logout and prevent user data from remaining accessible.","diff":"diff --git a/auth/cookie_manager.go b/auth/cookie_manager.go\nindex a32c773..3acc584 100644\n--- a/auth/cookie_manager.go\n+++ b/auth/cookie_manager.go\n@@ -195,9 +195,31 @@ func getLogoutRefreshCookie() *http.Cookie {\n \t}\n }\n \n+func getLogoutIDTokenCookie() *http.Cookie {\n+\treturn &http.Cookie{\n+\t\tName:     idTokenCookieName,\n+\t\tValue:    \"\",\n+\t\tMaxAge:   0,\n+\t\tHttpOnly: true,\n+\t\tExpires:  time.Now().Add(-1 * time.Hour),\n+\t}\n+}\n+\n+func getLogoutUserInfoCookie() *http.Cookie {\n+\treturn &http.Cookie{\n+\t\tName:     userInfoCookieName,\n+\t\tValue:    \"\",\n+\t\tMaxAge:   0,\n+\t\tHttpOnly: true,\n+\t\tExpires:  time.Now().Add(-1 * time.Hour),\n+\t}\n+}\n+\n func (c CookieManager) DeleteCookies(ctx context.Context, writer http.ResponseWriter) {\n \thttp.SetCookie(writer, getLogoutAccessCookie())\n \thttp.SetCookie(writer, getLogoutRefreshCookie())\n+\thttp.SetCookie(writer, getLogoutIDTokenCookie())\n+\thttp.SetCookie(writer, getLogoutUserInfoCookie())\n }\n \n func (c CookieManager) getHTTPSameSitePolicy() http.SameSite {\ndiff --git a/auth/cookie_manager_test.go b/auth/cookie_manager_test.go\nindex ce6b3b8..34df7d7 100644\n--- a/auth/cookie_manager_test.go\n+++ b/auth/cookie_manager_test.go\n@@ -100,6 +100,16 @@ func TestGetLogoutRefreshCookie(t *testing.T) {\n \tassert.True(t, time.Now().After(cookie.Expires))\n }\n \n+func TestGetLogoutIDTokenCookie(t *testing.T) {\n+\tcookie := getLogoutIDTokenCookie()\n+\tassert.True(t, time.Now().After(cookie.Expires))\n+}\n+\n+func TestGetLogoutUserInfoCookie(t *testing.T) {\n+\tcookie := getLogoutUserInfoCookie()\n+\tassert.True(t, time.Now().After(cookie.Expires))\n+}\n+\n func TestCookieManager_DeleteCookies(t *testing.T) {\n \tctx := context.Background()\n \n@@ -117,9 +127,22 @@ func TestCookieManager_DeleteCookies(t *testing.T) {\n \tw := httptest.NewRecorder()\n \tmanager.DeleteCookies(ctx, w)\n \tcookies := w.Result().Cookies()\n-\tassert.Equal(t, 2, len(cookies))\n-\tassert.True(t, time.Now().After(cookies[0].Expires))\n-\tassert.True(t, time.Now().After(cookies[1].Expires))\n+\tassert.Equal(t, 4, len(cookies))\n+\t\n+\t// Verify all cookies have expired\n+\tfor _, cookie := range cookies {\n+\t\tassert.True(t, time.Now().After(cookie.Expires))\n+\t}\n+\t\n+\t// Verify all required cookies are deleted\n+\tcookieNames := make(map[string]bool)\n+\tfor _, cookie := range cookies {\n+\t\tcookieNames[cookie.Name] = true\n+\t}\n+\tassert.True(t, cookieNames[accessTokenCookieName])\n+\tassert.True(t, cookieNames[refreshTokenCookieName])\n+\tassert.True(t, cookieNames[idTokenCookieName])\n+\tassert.True(t, cookieNames[userInfoCookieName])\n }\n \n func TestGetHTTPSameSitePolicy(t *testing.T) {"},{"message":"Fix the security vulnerability in auth/cookie.go where the NewSecureCookie function doesn't set HttpOnly or Secure flags on cookies. Update the function to set both flags by default to protect sensitive cookie data from client-side scripts and network sniffing.","diff":"diff --git a/auth/cookie.go b/auth/cookie.go\nindex 44422f7..3cdda52 100644\n--- a/auth/cookie.go\n+++ b/auth/cookie.go\n@@ -61,12 +61,16 @@ func NewSecureCookie(cookieName, value string, hashKey, blockKey []byte, domain\n \t\t\t\tValue:    encoded,\n \t\t\t\tDomain:   domain,\n \t\t\t\tSameSite: sameSiteMode,\n+\t\t\t\tHttpOnly: true,\n+\t\t\t\tSecure:   true,\n \t\t\t}, nil\n \t\t}\n \t\treturn http.Cookie{\n \t\t\tName:     cookieName,\n \t\t\tValue:    encoded,\n \t\t\tSameSite: sameSiteMode,\n+\t\t\tHttpOnly: true,\n+\t\t\tSecure:   true,\n \t\t}, nil\n \t}\n \ndiff --git a/auth/cookie_test.go b/auth/cookie_test.go\nindex 3ddbd57..728acfe 100644\n--- a/auth/cookie_test.go\n+++ b/auth/cookie_test.go\n@@ -37,6 +37,8 @@ func TestSecureCookieLifecycle(t *testing.T) {\n \n \tcookie, err := NewSecureCookie(\"choc\", \"chip\", hashKey, blockKey, \"localhost\", http.SameSiteLaxMode)\n \tassert.NoError(t, err)\n+\tassert.True(t, cookie.HttpOnly, \"HttpOnly flag should be set\")\n+\tassert.True(t, cookie.Secure, \"Secure flag should be set\")\n \n \tvalue, err := ReadSecureCookie(context.Background(), cookie, hashKey, blockKey)\n \tassert.NoError(t, err)\n@@ -111,6 +113,7 @@ func TestNewRedirectCookie(t *testing.T) {\n \t\tcookie := NewRedirectCookie(ctx, \"/console\")\n \t\tassert.NotNil(t, cookie)\n \t\tassert.Equal(t, \"/console\", cookie.Value)\n+\t\tassert.True(t, cookie.HttpOnly, \"HttpOnly flag should be set\")\n \t})\n \n \tt.Run(\"test external domain\", func(t *testing.T) {\n@@ -118,6 +121,7 @@ func TestNewRedirectCookie(t *testing.T) {\n \t\tcookie := NewRedirectCookie(ctx, \"http://www.example.com/postLogin\")\n \t\tassert.NotNil(t, cookie)\n \t\tassert.Equal(t, \"http://www.example.com/postLogin\", cookie.Value)\n+\t\tassert.True(t, cookie.HttpOnly, \"HttpOnly flag should be set\")\n \t})\n \n \tt.Run(\"uses same-site lax policy\", func(t *testing.T) {"},{"message":"Fix the security vulnerability in auth/cookie.go where the getAuthFlowEndRedirect function prioritizes redirect URLs from query parameters without validation. Update the function to validate redirect URLs from query parameters to prevent open redirect attacks.","diff":"diff --git a/auth/cookie.go b/auth/cookie.go\nindex 3cdda52..539b8a4 100644\n--- a/auth/cookie.go\n+++ b/auth/cookie.go\n@@ -8,6 +8,7 @@ import (\n \t\"math/big\"\n \t\"net/http\"\n \t\"net/url\"\n+\t\"strings\"\n \n \t\"github.com/flyteorg/flyteadmin/auth/interfaces\"\n \t\"github.com/flyteorg/flytestdlib/errors\"\n@@ -177,14 +178,51 @@ func NewRedirectCookie(ctx context.Context, redirectURL string) *http.Cookie {\n \t}\n }\n \n+// isValidRedirectURL checks if the provided redirect URL is safe to use.\n+// It validates that the URL is either a relative path (starting with '/') or\n+// matches the allowed domains configured in the application.\n+func isValidRedirectURL(ctx context.Context, redirectURL string, authCtx interfaces.AuthenticationContext) bool {\n+\t// Accept relative URLs (starting with /)\n+\tif strings.HasPrefix(redirectURL, \"/\") {\n+\t\treturn true\n+\t}\n+\n+\t// Parse the URL to validate it\n+\tparsedURL, err := url.Parse(redirectURL)\n+\tif err != nil {\n+\t\tlogger.Warningf(ctx, \"Invalid redirect URL format: %s, error: %v\", redirectURL, err)\n+\t\treturn false\n+\t}\n+\n+\t// URL must have a host\n+\tif parsedURL.Host == \"\" {\n+\t\treturn false\n+\t}\n+\n+\t// Check if the host is allowed based on the configured redirect URL\n+\tconfiguredURL := authCtx.Options().UserAuth.RedirectURL\n+\tif configuredURL.Host == parsedURL.Host {\n+\t\treturn true\n+\t}\n+\n+\t// Additional allowed domains could be added here if needed\n+\t// For now, we're only allowing the configured redirect URL host\n+\n+\tlogger.Warningf(ctx, \"Redirect URL host not allowed: %s\", parsedURL.Host)\n+\treturn false\n+}\n+\n // At the end of the OAuth flow, the server needs to send the user somewhere. This should have been stored as a cookie\n // during the initial /login call. If that cookie is missing from the request, it will default to the one configured\n // in this package's Config object.\n func getAuthFlowEndRedirect(ctx context.Context, authCtx interfaces.AuthenticationContext, request *http.Request) string {\n \tqueryParams := request.URL.Query()\n-\t// Use the redirect URL specified in the request if one is available.\n+\t// Use the redirect URL specified in the request if one is available and valid.\n \tif redirectURL := queryParams.Get(RedirectURLParameter); len(redirectURL) > 0 {\n-\t\treturn redirectURL\n+\t\tif isValidRedirectURL(ctx, redirectURL, authCtx) {\n+\t\t\treturn redirectURL\n+\t\t}\n+\t\tlogger.Warningf(ctx, \"Rejected potentially malicious redirect URL from query parameters: %s\", redirectURL)\n \t}\n \n \tcookie, err := request.Cookie(redirectURLCookieName)\ndiff --git a/auth/cookie_test.go b/auth/cookie_test.go\nindex 728acfe..3fb0ad3 100644\n--- a/auth/cookie_test.go\n+++ b/auth/cookie_test.go\n@@ -158,4 +158,60 @@ func TestGetAuthFlowEndRedirect(t *testing.T) {\n \t\tredirect := getAuthFlowEndRedirect(ctx, mockAuthCtx, request)\n \t\tassert.Equal(t, \"/api/v1/projects\", redirect)\n \t})\n+\n+\tt.Run(\"valid relative URL in query params\", func(t *testing.T) {\n+\t\tctx := context.Background()\n+\t\trequest, err := http.NewRequest(http.MethodGet, \"/test?redirect_url=/dashboard\", nil)\n+\t\tassert.NoError(t, err)\n+\t\tmockAuthCtx := &mocks.AuthenticationContext{}\n+\t\tredirect := getAuthFlowEndRedirect(ctx, mockAuthCtx, request)\n+\t\tassert.Equal(t, \"/dashboard\", redirect)\n+\t})\n+\n+\tt.Run(\"valid absolute URL in query params with matching host\", func(t *testing.T) {\n+\t\tctx := context.Background()\n+\t\trequest, err := http.NewRequest(http.MethodGet, \"/test?redirect_url=https://example.com/dashboard\", nil)\n+\t\tassert.NoError(t, err)\n+\t\tmockAuthCtx := &mocks.AuthenticationContext{}\n+\t\tmockAuthCtx.OnOptions().Return(&config.Config{\n+\t\t\tUserAuth: config.UserAuthConfig{\n+\t\t\t\tRedirectURL: stdConfig.URL{URL: mustParseURL(t, \"https://example.com/api\")},\n+\t\t\t},\n+\t\t})\n+\t\tredirect := getAuthFlowEndRedirect(ctx, mockAuthCtx, request)\n+\t\tassert.Equal(t, \"https://example.com/dashboard\", redirect)\n+\t})\n+\n+\tt.Run(\"invalid URL in query params with different host\", func(t *testing.T) {\n+\t\tctx := context.Background()\n+\t\trequest, err := http.NewRequest(http.MethodGet, \"/test?redirect_url=https://malicious.com/phishing\", nil)\n+\t\tassert.NoError(t, err)\n+\t\tcookie := NewRedirectCookie(ctx, \"/console\")\n+\t\tassert.NotNil(t, cookie)\n+\t\trequest.AddCookie(cookie)\n+\t\tmockAuthCtx := &mocks.AuthenticationContext{}\n+\t\tmockAuthCtx.OnOptions().Return(&config.Config{\n+\t\t\tUserAuth: config.UserAuthConfig{\n+\t\t\t\tRedirectURL: stdConfig.URL{URL: mustParseURL(t, \"https://example.com/api\")},\n+\t\t\t},\n+\t\t})\n+\t\tredirect := getAuthFlowEndRedirect(ctx, mockAuthCtx, request)\n+\t\t// Should fall back to cookie value since the query param URL is invalid\n+\t\tassert.Equal(t, \"/console\", redirect)\n+\t})\n+\n+\tt.Run(\"invalid URL in query params with no host\", func(t *testing.T) {\n+\t\tctx := context.Background()\n+\t\trequest, err := http.NewRequest(http.MethodGet, \"/test?redirect_url=javascript:alert(1)\", nil)\n+\t\tassert.NoError(t, err)\n+\t\tmockAuthCtx := &mocks.AuthenticationContext{}\n+\t\tmockAuthCtx.OnOptions().Return(&config.Config{\n+\t\t\tUserAuth: config.UserAuthConfig{\n+\t\t\t\tRedirectURL: stdConfig.URL{URL: mustParseURL(t, \"/api/v1/projects\")},\n+\t\t\t},\n+\t\t})\n+\t\tredirect := getAuthFlowEndRedirect(ctx, mockAuthCtx, request)\n+\t\t// Should fall back to default URL since the query param URL is invalid and no cookie\n+\t\tassert.Equal(t, \"/api/v1/projects\", redirect)\n+\t})\n }"},{"message":"Fix multiple security issues in auth/token.go:\n1. Fix the error handling for expired tokens in ParseIDTokenAndValidate by using a more robust approach than string matching\n2. Fix the GRPCGetIdentityFromIDToken function to properly handle errors when unmarshaling user info instead of just logging them\n3. Fix the copy-paste error in the error message in GRPCGetIdentityFromIDToken where it mentions 'Bearer scheme' but is checking for IDTokenScheme\n4. Review and document the automatic granting of 'all' scope to every authenticated user in IdentityContextFromIDTokenToken","diff":"diff --git a/auth/token.go b/auth/token.go\nindex 5acdd32..c0fdb4d 100644\n--- a/auth/token.go\n+++ b/auth/token.go\n@@ -46,6 +46,16 @@ func GetRefreshedToken(ctx context.Context, oauth *oauth2.Config, accessToken, r\n \treturn newToken, nil\n }\n \n+// isTokenExpiredError checks if the error is related to token expiration\n+// This is a more robust approach than direct string matching in multiple places\n+func isTokenExpiredError(err error) bool {\n+\t// Check for token expiration\n+\t// Currently go-oidc doesn't expose error types, so we need to check the error message\n+\t// This is still string matching, but it's isolated in a function that can be updated\n+\t// when go-oidc library improves error handling\n+\treturn err != nil && strings.Contains(err.Error(), \"token is expired\")\n+}\n+\n func ParseIDTokenAndValidate(ctx context.Context, clientID, rawIDToken string, provider *oidc.Provider) (*oidc.IDToken, error) {\n \tcfg := &oidc.Config{\n \t\tClientID: clientID,\n@@ -63,8 +73,9 @@ func ParseIDTokenAndValidate(ctx context.Context, clientID, rawIDToken string, p\n \tif err != nil {\n \t\tlogger.Debugf(ctx, \"JWT parsing with claims failed %s\", err)\n \t\tflyteErr := errors.Wrapf(ErrJwtValidation, err, \"jwt parse with claims failed\")\n-\t\t// TODO: Contribute an errors package to the go-oidc library for proper error handling\n-\t\tif strings.Contains(err.Error(), \"token is expired\") {\n+\t\t\n+\t\t// Check for token expiration using the helper function\n+\t\tif isTokenExpiredError(err) {\n \t\t\treturn idToken, errors.Wrapf(ErrTokenExpired, flyteErr, \"token is expired\")\n \t\t}\n \n@@ -86,7 +97,7 @@ func GRPCGetIdentityFromAccessToken(ctx context.Context, authCtx interfaces.Auth\n \n \tif tokenStr == \"\" {\n \t\tlogger.Debugf(ctx, \"Found Bearer scheme but token was blank\")\n-\t\treturn nil, errors.Errorf(ErrJwtValidation, \"%v token is blank\", IDTokenScheme)\n+\t\treturn nil, errors.Errorf(ErrJwtValidation, \"%v token is blank\", BearerScheme)\n \t}\n \n \texpectedAudience := GetPublicURL(ctx, nil, authCtx.Options()).String()\n@@ -105,7 +116,7 @@ func GRPCGetIdentityFromIDToken(ctx context.Context, clientID string, provider *\n \t}\n \n \tif tokenStr == \"\" {\n-\t\tlogger.Debugf(ctx, \"Found Bearer scheme but token was blank\")\n+\t\tlogger.Debugf(ctx, \"Found IDToken scheme but token was blank\")\n \t\treturn nil, errors.Errorf(ErrJwtValidation, \"%v token is blank\", IDTokenScheme)\n \t}\n \n@@ -115,7 +126,9 @@ func GRPCGetIdentityFromIDToken(ctx context.Context, clientID string, provider *\n \tif len(userInfoDecoded) > 0 {\n \t\terr = json.Unmarshal([]byte(userInfoDecoded), userInfo)\n \t\tif err != nil {\n-\t\t\tlogger.Infof(ctx, \"Could not unmarshal user info from metadata %v\", err)\n+\t\t\tlogger.Warningf(ctx, \"Could not unmarshal user info from metadata %v\", err)\n+\t\t\t// Return error instead of proceeding with potentially corrupted user info\n+\t\t\treturn nil, errors.Wrapf(ErrJwtValidation, err, \"Failed to unmarshal user info from metadata\")\n \t\t}\n \t}\n \n@@ -131,10 +144,17 @@ func IdentityContextFromIDTokenToken(ctx context.Context, tokenStr, clientID str\n \t}\n \tvar claims map[string]interface{}\n \tif err := idToken.Claims(&claims); err != nil {\n-\t\tlogger.Infof(ctx, \"Failed to unmarshal claims from id token, err: %v\", err)\n+\t\tlogger.Warningf(ctx, \"Failed to unmarshal claims from id token, err: %v\", err)\n+\t\t// Return error instead of proceeding with potentially corrupted claims\n+\t\treturn nil, errors.Wrapf(ErrJwtValidation, err, \"Failed to unmarshal claims from id token\")\n \t}\n \n-\t// TODO: Document why automatically specify \"all\" scope\n+\t// SECURITY NOTE: The 'all' scope is automatically granted to every authenticated user.\n+\t// This means any authenticated user has full access to all resources.\n+\t// This is a deliberate design decision to simplify authorization in the current implementation.\n+\t// In a more fine-grained authorization model, scopes would be extracted from the token claims\n+\t// or determined based on user roles. Consider implementing more granular scope assignment\n+\t// if your application requires different permission levels.\n \treturn NewIdentityContext(idToken.Audience[0], idToken.Subject, \"\", idToken.IssuedAt,\n \t\tsets.NewString(ScopeAll), userInfo, claims), nil\n }"}]}]}