{"scanned_subsystems":[{"name":"Socket.IO","files":["src/socket.io/admin.js","src/socket.io/admin/analytics.js","src/socket.io/admin/cache.js","src/socket.io/admin/categories.js","src/socket.io/admin/config.js","src/socket.io/admin/digest.js","src/socket.io/admin/email.js","src/socket.io/admin/errors.js","src/socket.io/admin/logs.js","src/socket.io/admin/navigation.js","src/socket.io/admin/plugins.js","src/socket.io/admin/rewards.js","src/socket.io/admin/rooms.js","src/socket.io/admin/settings.js","src/socket.io/admin/social.js","src/socket.io/admin/tags.js","src/socket.io/admin/themes.js","src/socket.io/admin/user.js","src/socket.io/admin/widgets.js","src/socket.io/blacklist.js","src/socket.io/categories.js","src/socket.io/categories/search.js","src/socket.io/groups.js","src/socket.io/helpers.js","src/socket.io/index.js","src/socket.io/meta.js","src/socket.io/modules.js","src/socket.io/notifications.js","src/socket.io/plugins.js","src/socket.io/posts.js","src/socket.io/posts/tools.js","src/socket.io/posts/votes.js","src/socket.io/topics.js","src/socket.io/topics/infinitescroll.js","src/socket.io/topics/merge.js","src/socket.io/topics/move.js","src/socket.io/topics/tags.js","src/socket.io/topics/tools.js","src/socket.io/topics/unread.js","src/socket.io/uploads.js","src/socket.io/user.js","src/socket.io/user/picture.js","src/socket.io/user/profile.js","src/socket.io/user/registration.js","src/socket.io/user/status.js"]}],"changesets":[{"title":"Bismuth: fix 16 bugs in Socket.IO","body":"Fixes:\n- Fix the potential infinite loop vulnerability in the ignoreOrWatch function in src/socket.io/categories.js. The do-while loop at lines 133-138 doesn't have cycle detection for circular references in the category hierarchy, which could lead to an infinite loop. Implement a solution that prevents this by tracking already processed categories.\n- Fix the security vulnerability in SocketNotifs.get in src/socket.io/notifications.js. Currently, there's no verification if the user has permission to view the specified notifications (data.nids). If data.nids contains notification IDs that belong to other users, this could potentially allow users to view notifications they shouldn't have access to. Implement a solution that ensures users can only access their own notifications.\n- Fix the security vulnerability in SocketNotifs.markRead and SocketNotifs.markUnread in src/socket.io/notifications.js. Currently, there's no check if the user has permission to mark the specified notification. If the underlying functions don't properly check permissions, this could allow users to mark notifications they shouldn't have access to. Implement a solution that ensures users can only mark their own notifications as read or unread.\n- Fix the security vulnerability in SocketTopics.bookmark in src/socket.io/topics.js. Currently, there's no check to verify if the user has permission to read the topic before setting a bookmark. This could allow users to bookmark topics they don't have access to. Implement a solution that ensures users can only bookmark topics they have permission to read.\n- Fix the security vulnerability in SocketTopics.isFollowed in src/socket.io/topics.js. Currently, there's no check to verify if the user has permission to view the topic before checking if they're following it. This could allow users to determine if they're following topics they shouldn't have access to. Implement a solution that ensures users can only check if they're following topics they have permission to read.\n- Fix the security vulnerability in SocketTopics.isModerator in src/socket.io/topics.js. Currently, there's no check to verify if the user has permission to view the topic before checking if they're a moderator of its category. This could allow users to determine the category of topics they shouldn't have access to. Implement a solution that ensures users can only check if they're a moderator for topics they have permission to read.\n- Fix the security vulnerability in SocketTopics.getMyNextPostIndex in src/socket.io/topics.js. Currently, there's no check to verify if the user has permission to view the topic before getting their next post index. This could allow users to gather information about topics they shouldn't have access to. Implement a solution that ensures users can only get their next post index for topics they have permission to read.\n- Fix the security vulnerability in SocketTopics.getPostCountInTopic in src/socket.io/topics.js. Currently, there's no check to verify if the user has permission to view the topic before getting their post count in the topic. This could allow users to gather information about topics they shouldn't have access to. Implement a solution that ensures users can only get their post count for topics they have permission to read.\n- Fix the potential stack overflow vulnerability in SocketTopics.getMyNextPostIndex in src/socket.io/topics.js. The function currently uses recursion when wrapping around to the beginning of a topic, which could lead to a stack overflow if there's a logic error. Modify the function to use an iterative approach instead of recursion, or add a recursion depth counter to limit the number of recursive calls.\n- Fix the security vulnerability in SocketCategories.getRecentReplies and SocketCategories.getTopicCount in src/socket.io/categories.js by adding permission checks to ensure users can only access information about categories they have permission to view. Add a check using privileges.categories.can('read', cid, socket.uid) before retrieving any category data.\n- Fix the security vulnerability in SocketGroups.issueMassInvite in src/socket.io/groups.js by adding a reasonable limit on the number of usernames that can be processed in a single request. Add a constant MAX_USERS_PER_INVITE (set to 100) and throw an error if the number of usernames exceeds this limit.\n- Fix the security vulnerability in SocketGroups.loadMore in src/socket.io/groups.js by adding permission checks to ensure users can only view groups they have permission to access. Add a check using privileges.global.can('view:groups', socket.uid) before retrieving group data, and filter hidden groups for non-administrators.\n- Fix the security vulnerability in the rate limiting mechanism in src/socket.io/index.js by implementing rate limiting for admin events. Currently, the rate limiting in onMessage only applies to non-admin events (line 145), which could be abused if an attacker gains admin credentials. Modify the code to implement separate, higher rate limits for admin events rather than bypassing them entirely.\n- Fix the IP extraction logic in onConnection in src/socket.io/index.js to make it more secure against spoofing. The current implementation takes the first IP from x-forwarded-for headers without validation, which could be manipulated if the proxy configuration isn't secure. Implement a more robust approach that validates the IP format and considers the specific proxy configuration.\n- Fix the Socket.io configuration in src/socket.io/index.js to add explicit limits on connections and message sizes to prevent resource exhaustion attacks. Add configurations for maximum message size, ping timeout, ping interval, and connection timeout. Also implement a mechanism to limit the number of concurrent connections per IP or user.\n- Fix the uploads module in src/socket.io/uploads.js to address three security vulnerabilities: 1) Add a limit on the number of concurrent uploads per user to prevent memory exhaustion, 2) Add proper authorization checks to the clear function to prevent unauthorized clearing of other users' uploads, and 3) Add a limit on the total size of uploads in the inProgress global variable.","commits":[{"message":"Fix the potential infinite loop vulnerability in the ignoreOrWatch function in src/socket.io/categories.js. The do-while loop at lines 133-138 doesn't have cycle detection for circular references in the category hierarchy, which could lead to an infinite loop. Implement a solution that prevents this by tracking already processed categories.","diff":"diff --git a/src/socket.io/categories.js b/src/socket.io/categories.js\nindex 0a90698..7aceb75 100644\n--- a/src/socket.io/categories.js\n+++ b/src/socket.io/categories.js\n@@ -130,11 +130,15 @@ async function ignoreOrWatch(fn, socket, data) {\n \tconst categoryData = await categories.getCategoriesFields(allCids, ['cid', 'parentCid']);\n \n \t// filter to subcategories of cid\n+\t// Track processed categories to prevent infinite loops from circular references\n+\tconst processedCids = new Set();\n \tlet cat;\n \tdo {\n-\t\tcat = categoryData.find(c => !cids.includes(c.cid) && cids.includes(c.parentCid));\n+\t\t// Find categories whose parent is in cids but the category itself is not yet included\n+\t\tcat = categoryData.find(c => !cids.includes(c.cid) && cids.includes(c.parentCid) && !processedCids.has(c.cid));\n \t\tif (cat) {\n \t\t\tcids.push(cat.cid);\n+\t\t\tprocessedCids.add(cat.cid);\n \t\t}\n \t} while (cat);\n "},{"message":"Fix the security vulnerability in SocketNotifs.get in src/socket.io/notifications.js. Currently, there's no verification if the user has permission to view the specified notifications (data.nids). If data.nids contains notification IDs that belong to other users, this could potentially allow users to view notifications they shouldn't have access to. Implement a solution that ensures users can only access their own notifications.","diff":"diff --git a/src/socket.io/notifications.js b/src/socket.io/notifications.js\nindex 2b0df88..3ae6def 100644\n--- a/src/socket.io/notifications.js\n+++ b/src/socket.io/notifications.js\n@@ -7,7 +7,14 @@ const SocketNotifs = module.exports;\n \n SocketNotifs.get = async function (socket, data) {\n \tif (data && Array.isArray(data.nids) && socket.uid) {\n-\t\treturn await user.notifications.getNotifications(data.nids, socket.uid);\n+\t\t// Get all notification IDs that belong to this user\n+\t\tconst userNotifIds = await user.notifications.getAll(socket.uid);\n+\t\t\n+\t\t// Filter the requested nids to only include those that belong to the user\n+\t\tconst authorizedNids = data.nids.filter(nid => userNotifIds.includes(nid));\n+\t\t\n+\t\t// Only retrieve notifications that the user owns\n+\t\treturn await user.notifications.getNotifications(authorizedNids, socket.uid);\n \t}\n \treturn await user.notifications.get(socket.uid);\n };"},{"message":"Fix the security vulnerability in SocketNotifs.markRead and SocketNotifs.markUnread in src/socket.io/notifications.js. Currently, there's no check if the user has permission to mark the specified notification. If the underlying functions don't properly check permissions, this could allow users to mark notifications they shouldn't have access to. Implement a solution that ensures users can only mark their own notifications as read or unread.","diff":"diff --git a/src/socket.io/notifications.js b/src/socket.io/notifications.js\nindex 3ae6def..fa72e27 100644\n--- a/src/socket.io/notifications.js\n+++ b/src/socket.io/notifications.js\n@@ -32,16 +32,44 @@ SocketNotifs.deleteAll = async function (socket) {\n };\n \n SocketNotifs.markRead = async function (socket, nid) {\n+\tif (!socket.uid) {\n+\t\tthrow new Error('[[error:no-privileges]]');\n+\t}\n+\t\n+\t// Get all notification IDs that belong to this user\n+\tconst userNotifIds = await user.notifications.getAll(socket.uid);\n+\t\n+\t// Check if the notification belongs to the user\n+\tif (!userNotifIds.includes(nid)) {\n+\t\tthrow new Error('[[error:no-privileges]]');\n+\t}\n+\t\n \tawait notifications.markRead(nid, socket.uid);\n \tuser.notifications.pushCount(socket.uid);\n };\n \n SocketNotifs.markUnread = async function (socket, nid) {\n+\tif (!socket.uid) {\n+\t\tthrow new Error('[[error:no-privileges]]');\n+\t}\n+\t\n+\t// Get all notification IDs that belong to this user\n+\tconst userNotifIds = await user.notifications.getAll(socket.uid);\n+\t\n+\t// Check if the notification belongs to the user\n+\tif (!userNotifIds.includes(nid)) {\n+\t\tthrow new Error('[[error:no-privileges]]');\n+\t}\n+\t\n \tawait notifications.markUnread(nid, socket.uid);\n \tuser.notifications.pushCount(socket.uid);\n };\n \n SocketNotifs.markAllRead = async function (socket) {\n+\tif (!socket.uid) {\n+\t\tthrow new Error('[[error:no-privileges]]');\n+\t}\n+\t\n \tawait notifications.markAllRead(socket.uid);\n \tuser.notifications.pushCount(socket.uid);\n };"},{"message":"Fix the security vulnerability in SocketTopics.bookmark in src/socket.io/topics.js. Currently, there's no check to verify if the user has permission to read the topic before setting a bookmark. This could allow users to bookmark topics they don't have access to. Implement a solution that ensures users can only bookmark topics they have permission to read.","diff":"diff --git a/src/socket.io/topics.js b/src/socket.io/topics.js\nindex df20a6d..3cf26a5 100644\n--- a/src/socket.io/topics.js\n+++ b/src/socket.io/topics.js\n@@ -32,6 +32,10 @@ SocketTopics.bookmark = async function (socket, data) {\n \tif (!socket.uid || !data) {\n \t\tthrow new Error('[[error:invalid-data]]');\n \t}\n+\tconst canRead = await privileges.topics.can('topics:read', data.tid, socket.uid);\n+\tif (!canRead) {\n+\t\tthrow new Error('[[no-privileges]]');\n+\t}\n \tconst postcount = await topics.getTopicField(data.tid, 'postcount');\n \tif (data.index > meta.config.bookmarkThreshold && postcount > meta.config.bookmarkThreshold) {\n \t\tawait topics.setUserBookmark(data.tid, socket.uid, data.index);"},{"message":"Fix the security vulnerability in SocketTopics.isFollowed in src/socket.io/topics.js. Currently, there's no check to verify if the user has permission to view the topic before checking if they're following it. This could allow users to determine if they're following topics they shouldn't have access to. Implement a solution that ensures users can only check if they're following topics they have permission to read.","diff":"diff --git a/src/socket.io/topics.js b/src/socket.io/topics.js\nindex 3cf26a5..2a50313 100644\n--- a/src/socket.io/topics.js\n+++ b/src/socket.io/topics.js\n@@ -64,6 +64,10 @@ SocketTopics.createTopicFromPosts = async function (socket, data) {\n };\n \n SocketTopics.isFollowed = async function (socket, tid) {\n+\tconst canRead = await privileges.topics.can('topics:read', tid, socket.uid);\n+\tif (!canRead) {\n+\t\tthrow new Error('[[error:no-privileges]]');\n+\t}\n \tconst isFollowing = await topics.isFollowing([tid], socket.uid);\n \treturn isFollowing[0];\n };"},{"message":"Fix the security vulnerability in SocketTopics.isModerator in src/socket.io/topics.js. Currently, there's no check to verify if the user has permission to view the topic before checking if they're a moderator of its category. This could allow users to determine the category of topics they shouldn't have access to. Implement a solution that ensures users can only check if they're a moderator for topics they have permission to read.","diff":"diff --git a/src/socket.io/topics.js b/src/socket.io/topics.js\nindex 2a50313..60cf02b 100644\n--- a/src/socket.io/topics.js\n+++ b/src/socket.io/topics.js\n@@ -73,6 +73,10 @@ SocketTopics.isFollowed = async function (socket, tid) {\n };\n \n SocketTopics.isModerator = async function (socket, tid) {\n+\tconst canRead = await privileges.topics.can('topics:read', tid, socket.uid);\n+\tif (!canRead) {\n+\t\tthrow new Error('[[error:no-privileges]]');\n+\t}\n \tconst cid = await topics.getTopicField(tid, 'cid');\n \treturn await user.isModerator(socket.uid, cid);\n };"},{"message":"Fix the security vulnerability in SocketTopics.getMyNextPostIndex in src/socket.io/topics.js. Currently, there's no check to verify if the user has permission to view the topic before getting their next post index. This could allow users to gather information about topics they shouldn't have access to. Implement a solution that ensures users can only get their next post index for topics they have permission to read.","diff":"diff --git a/src/socket.io/topics.js b/src/socket.io/topics.js\nindex 60cf02b..20f71ec 100644\n--- a/src/socket.io/topics.js\n+++ b/src/socket.io/topics.js\n@@ -85,6 +85,11 @@ SocketTopics.getMyNextPostIndex = async function (socket, data) {\n \tif (!data || !data.tid || !data.index || !data.sort) {\n \t\tthrow new Error('[[error:invalid-data]]');\n \t}\n+\t\n+\tconst canRead = await privileges.topics.can('topics:read', data.tid, socket.uid);\n+\tif (!canRead) {\n+\t\tthrow new Error('[[error:no-privileges]]');\n+\t}\n \n \tasync function getTopicPids(index) {\n \t\tconst topicSet = data.sort === 'most_votes' ? `tid:${data.tid}:posts:votes` : `tid:${data.tid}:posts`;"},{"message":"Fix the security vulnerability in SocketTopics.getPostCountInTopic in src/socket.io/topics.js. Currently, there's no check to verify if the user has permission to view the topic before getting their post count in the topic. This could allow users to gather information about topics they shouldn't have access to. Implement a solution that ensures users can only get their post count for topics they have permission to read.","diff":"diff --git a/src/socket.io/topics.js b/src/socket.io/topics.js\nindex 20f71ec..97ab94a 100644\n--- a/src/socket.io/topics.js\n+++ b/src/socket.io/topics.js\n@@ -139,6 +139,10 @@ SocketTopics.getPostCountInTopic = async function (socket, tid) {\n \tif (!socket.uid || !tid) {\n \t\treturn 0;\n \t}\n+\tconst canRead = await privileges.topics.can('topics:read', tid, socket.uid);\n+\tif (!canRead) {\n+\t\tthrow new Error('[[error:no-privileges]]');\n+\t}\n \treturn await db.sortedSetScore(`tid:${tid}:posters`, socket.uid);\n };\n "},{"message":"Fix the potential stack overflow vulnerability in SocketTopics.getMyNextPostIndex in src/socket.io/topics.js. The function currently uses recursion when wrapping around to the beginning of a topic, which could lead to a stack overflow if there's a logic error. Modify the function to use an iterative approach instead of recursion, or add a recursion depth counter to limit the number of recursive calls.","diff":"diff --git a/src/socket.io/topics.js b/src/socket.io/topics.js\nindex 97ab94a..e0d8089 100644\n--- a/src/socket.io/topics.js\n+++ b/src/socket.io/topics.js\n@@ -115,24 +115,40 @@ SocketTopics.getMyNextPostIndex = async function (socket, data) {\n \t\tcache.set(cacheKey, pids, 30000);\n \t\treturn pids;\n \t}\n+\t\n \tconst postCountInTopic = await db.sortedSetScore(`tid:${data.tid}:posters`, socket.uid);\n \tif (postCountInTopic <= 0) {\n \t\treturn 0;\n \t}\n-\tconst [topicPids, userPidsInCategory] = await Promise.all([\n-\t\tgetTopicPids(data.index),\n-\t\tgetUserPids(),\n-\t]);\n-\tconst userPidsInTopic = _.intersection(topicPids, userPidsInCategory);\n-\tif (!userPidsInTopic.length) {\n-\t\tif (postCountInTopic > 0) {\n-\t\t\t// wrap around to beginning\n-\t\t\tconst wrapIndex = await SocketTopics.getMyNextPostIndex(socket, { ...data, index: 1 });\n-\t\t\treturn wrapIndex;\n+\t\n+\t// Iterative approach instead of recursion to prevent stack overflow\n+\tlet currentIndex = data.index;\n+\tlet attempts = 0;\n+\tconst maxAttempts = 2; // Limit to 2 attempts: original position and wrap-around\n+\t\n+\twhile (attempts < maxAttempts) {\n+\t\tconst [topicPids, userPidsInCategory] = await Promise.all([\n+\t\t\tgetTopicPids(currentIndex),\n+\t\t\tgetUserPids(),\n+\t\t]);\n+\t\t\n+\t\tconst userPidsInTopic = _.intersection(topicPids, userPidsInCategory);\n+\t\t\n+\t\tif (userPidsInTopic.length) {\n+\t\t\treturn await posts.getPidIndex(userPidsInTopic[0], data.tid, data.sort);\n \t\t}\n-\t\treturn 0;\n+\t\t\n+\t\t// If no posts found and we have posts in the topic, try from the beginning\n+\t\tif (postCountInTopic > 0 && currentIndex !== 1) {\n+\t\t\tcurrentIndex = 1; // Wrap around to beginning\n+\t\t} else {\n+\t\t\treturn 0; // No posts found after wrap-around or no need to wrap\n+\t\t}\n+\t\t\n+\t\tattempts += 1;\n \t}\n-\treturn await posts.getPidIndex(userPidsInTopic[0], data.tid, data.sort);\n+\t\n+\treturn 0; // Fallback if no posts found after all attempts\n };\n \n SocketTopics.getPostCountInTopic = async function (socket, tid) {"},{"message":"Fix the security vulnerability in SocketCategories.getRecentReplies and SocketCategories.getTopicCount in src/socket.io/categories.js by adding permission checks to ensure users can only access information about categories they have permission to view. Add a check using privileges.categories.can('read', cid, socket.uid) before retrieving any category data.","diff":"diff --git a/src/socket.io/categories.js b/src/socket.io/categories.js\nindex 7aceb75..7ed0661 100644\n--- a/src/socket.io/categories.js\n+++ b/src/socket.io/categories.js\n@@ -10,6 +10,10 @@ const SocketCategories = module.exports;\n require('./categories/search')(SocketCategories);\n \n SocketCategories.getRecentReplies = async function (socket, cid) {\n+\tconst allowed = await privileges.categories.can('read', cid, socket.uid);\n+\tif (!allowed) {\n+\t\tthrow new Error('[[error:no-privileges]]');\n+\t}\n \treturn await categories.getRecentReplies(cid, socket.uid, 0, 4);\n };\n \n@@ -83,6 +87,10 @@ SocketCategories.loadMore = async function (socket, data) {\n };\n \n SocketCategories.getTopicCount = async function (socket, cid) {\n+\tconst allowed = await privileges.categories.can('read', cid, socket.uid);\n+\tif (!allowed) {\n+\t\tthrow new Error('[[error:no-privileges]]');\n+\t}\n \treturn await categories.getCategoryField(cid, 'topic_count');\n };\n "},{"message":"Fix the security vulnerability in SocketGroups.issueMassInvite in src/socket.io/groups.js by adding a reasonable limit on the number of usernames that can be processed in a single request. Add a constant MAX_USERS_PER_INVITE (set to 100) and throw an error if the number of usernames exceeds this limit.","diff":"diff --git a/src/socket.io/groups.js b/src/socket.io/groups.js\nindex 3b6f30a..798eaec 100644\n--- a/src/socket.io/groups.js\n+++ b/src/socket.io/groups.js\n@@ -6,6 +6,7 @@ const utils = require('../utils');\n const events = require('../events');\n const privileges = require('../privileges');\n \n+const MAX_USERS_PER_INVITE = 100;\n const SocketGroups = module.exports;\n \n SocketGroups.before = async (socket, method, data) => {\n@@ -120,6 +121,10 @@ SocketGroups.issueMassInvite = async (socket, data) => {\n \t}\n \tlet usernames = String(data.usernames).split(',');\n \tusernames = usernames.map(username => username && username.trim());\n+\t\n+\tif (usernames.length > MAX_USERS_PER_INVITE) {\n+\t\tthrow new Error('[[error:too-many-users-invited]]');\n+\t}\n \n \tlet uids = await user.getUidsByUsernames(usernames);\n \tuids = uids.filter(uid => !!uid && parseInt(uid, 10));"},{"message":"Fix the security vulnerability in SocketGroups.loadMore in src/socket.io/groups.js by adding permission checks to ensure users can only view groups they have permission to access. Add a check using privileges.global.can('view:groups', socket.uid) before retrieving group data, and filter hidden groups for non-administrators.","diff":"diff --git a/src/socket.io/groups.js b/src/socket.io/groups.js\nindex 798eaec..b77c70c 100644\n--- a/src/socket.io/groups.js\n+++ b/src/socket.io/groups.js\n@@ -191,10 +191,23 @@ SocketGroups.loadMore = async (socket, data) => {\n \t\tthrow new Error('[[error:invalid-data]]');\n \t}\n \n+\t// Check if user has permission to view groups\n+\tconst canViewGroups = await privileges.global.can('view:groups', socket.uid);\n+\tif (!canViewGroups) {\n+\t\tthrow new Error('[[error:no-privileges]]');\n+\t}\n+\n \tconst groupsPerPage = 10;\n \tconst start = parseInt(data.after, 10);\n \tconst stop = start + groupsPerPage - 1;\n-\tconst groupData = await groups.getGroupsBySort(data.sort, start, stop);\n+\tconst isAdmin = await user.isAdministrator(socket.uid);\n+\t\n+\t// Get groups and filter hidden ones for non-admins\n+\tlet groupData = await groups.getGroupsBySort(data.sort, start, stop);\n+\tif (!isAdmin) {\n+\t\tgroupData = groupData.filter(group => !group.hidden);\n+\t}\n+\t\n \treturn { groups: groupData, nextStart: stop + 1 };\n };\n "},{"message":"Fix the security vulnerability in the rate limiting mechanism in src/socket.io/index.js by implementing rate limiting for admin events. Currently, the rate limiting in onMessage only applies to non-admin events (line 145), which could be abused if an attacker gains admin credentials. Modify the code to implement separate, higher rate limits for admin events rather than bypassing them entirely.","diff":"diff --git a/src/middleware/ratelimit.js b/src/middleware/ratelimit.js\nindex 9697c56..8add882 100644\n--- a/src/middleware/ratelimit.js\n+++ b/src/middleware/ratelimit.js\n@@ -6,6 +6,9 @@ const ratelimit = module.exports;\n \n const allowedCalls = 100;\n const timeframe = 10000;\n+// Higher limits for admin events\n+const adminAllowedCalls = 500;\n+const adminTimeframe = 10000;\n \n ratelimit.isFlooding = function (socket) {\n \tsocket.callsPerSecond = socket.callsPerSecond || 0;\n@@ -30,3 +33,28 @@ ratelimit.isFlooding = function (socket) {\n \tsocket.lastCallTime = now;\n \treturn false;\n };\n+\n+// Separate rate limiting function for admin events with higher thresholds\n+ratelimit.isAdminFlooding = function (socket) {\n+\tsocket.adminCallsPerSecond = socket.adminCallsPerSecond || 0;\n+\tsocket.adminElapsedTime = socket.adminElapsedTime || 0;\n+\tsocket.adminLastCallTime = socket.adminLastCallTime || Date.now();\n+\n+\tsocket.adminCallsPerSecond += 1;\n+\n+\tconst now = Date.now();\n+\tsocket.adminElapsedTime += now - socket.adminLastCallTime;\n+\n+\tif (socket.adminCallsPerSecond > adminAllowedCalls && socket.adminElapsedTime < adminTimeframe) {\n+\t\twinston.warn(`Admin flooding detected! Calls : ${socket.adminCallsPerSecond}, Duration : ${socket.adminElapsedTime}`);\n+\t\treturn true;\n+\t}\n+\n+\tif (socket.adminElapsedTime >= adminTimeframe) {\n+\t\tsocket.adminElapsedTime = 0;\n+\t\tsocket.adminCallsPerSecond = 0;\n+\t}\n+\n+\tsocket.adminLastCallTime = now;\n+\treturn false;\n+};\ndiff --git a/src/socket.io/index.js b/src/socket.io/index.js\nindex 58134ae..0e86897 100644\n--- a/src/socket.io/index.js\n+++ b/src/socket.io/index.js\n@@ -143,7 +143,13 @@ async function onMessage(socket, payload) {\n \t\tsocket.previousEvents.shift();\n \t}\n \n-\tif (!eventName.startsWith('admin.') && ratelimit.isFlooding(socket)) {\n+\t// Apply different rate limiting based on whether it's an admin event or not\n+\tif (eventName.startsWith('admin.')) {\n+\t\tif (ratelimit.isAdminFlooding(socket)) {\n+\t\t\twinston.warn(`[socket.io] Too many admin emits! Disconnecting uid : ${socket.uid}. Events : ${socket.previousEvents}`);\n+\t\t\treturn socket.disconnect();\n+\t\t}\n+\t} else if (ratelimit.isFlooding(socket)) {\n \t\twinston.warn(`[socket.io] Too many emits! Disconnecting uid : ${socket.uid}. Events : ${socket.previousEvents}`);\n \t\treturn socket.disconnect();\n \t}"},{"message":"Fix the IP extraction logic in onConnection in src/socket.io/index.js to make it more secure against spoofing. The current implementation takes the first IP from x-forwarded-for headers without validation, which could be manipulated if the proxy configuration isn't secure. Implement a more robust approach that validates the IP format and considers the specific proxy configuration.","diff":"diff --git a/src/socket.io/index.js b/src/socket.io/index.js\nindex 0e86897..49e8ce8 100644\n--- a/src/socket.io/index.js\n+++ b/src/socket.io/index.js\n@@ -62,7 +62,40 @@ Sockets.init = async function (server) {\n };\n \n function onConnection(socket) {\n-\tsocket.ip = (socket.request.headers['x-forwarded-for'] || socket.request.connection.remoteAddress || '').split(',')[0];\n+\t// Extract and validate IP address based on proxy configuration\n+\tlet ip = '';\n+\tconst trustProxy = nconf.get('trust_proxy');\n+\t\n+\tif (trustProxy) {\n+\t\t// If behind a proxy, get the IP from x-forwarded-for header\n+\t\t// but validate it properly to prevent spoofing\n+\t\tconst forwardedIps = socket.request.headers['x-forwarded-for'];\n+\t\t\n+\t\tif (forwardedIps) {\n+\t\t\t// Get the appropriate IP based on proxy configuration\n+\t\t\t// In a reverse proxy setup, the rightmost (last) IP is usually from the most recent proxy\n+\t\t\t// and the leftmost (first) IP is the original client IP\n+\t\t\tconst ips = forwardedIps.split(',').map(ip => ip.trim());\n+\t\t\t\n+\t\t\t// If we're behind a trusted proxy, take the leftmost IP (original client)\n+\t\t\t// Otherwise, take the rightmost IP (most recent proxy)\n+\t\t\tip = trustProxy === true ? ips[0] : ips[ips.length - 1];\n+\t\t\t\n+\t\t\t// Validate the IP format\n+\t\t\tif (ip && !validator.isIP(ip)) {\n+\t\t\t\t// If IP is invalid, don't use it\n+\t\t\t\tip = '';\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\t// Fall back to connection.remoteAddress if no valid IP from x-forwarded-for\n+\tif (!ip) {\n+\t\tip = socket.request.connection.remoteAddress || '';\n+\t}\n+\t\n+\t// Final validation to ensure we have a valid IP\n+\tsocket.ip = validator.isIP(ip) ? ip : '';\n \tsocket.request.ip = socket.ip;\n \tlogger.io_one(socket, socket.uid);\n "},{"message":"Fix the Socket.io configuration in src/socket.io/index.js to add explicit limits on connections and message sizes to prevent resource exhaustion attacks. Add configurations for maximum message size, ping timeout, ping interval, and connection timeout. Also implement a mechanism to limit the number of concurrent connections per IP or user.","diff":"diff --git a/src/socket.io/index.js b/src/socket.io/index.js\nindex 49e8ce8..4f8aec0 100644\n--- a/src/socket.io/index.js\n+++ b/src/socket.io/index.js\n@@ -15,6 +15,18 @@ const ratelimit = require('../middleware/ratelimit');\n \n const Namespaces = {};\n \n+// Connection tracking for rate limiting\n+const connectedIPs = new Map(); // IP -> count\n+const connectedUsers = new Map(); // UID -> count\n+\n+// Socket.io configuration defaults\n+const MAX_CONNECTIONS_PER_IP = 10;\n+const MAX_CONNECTIONS_PER_USER = 5;\n+const MAX_MESSAGE_SIZE = 1024 * 16; // 16KB\n+const PING_INTERVAL = 25000; // 25 seconds\n+const PING_TIMEOUT = 60000; // 60 seconds\n+const CONNECTION_TIMEOUT = 30000; // 30 seconds\n+\n const Sockets = module.exports;\n \n Sockets.init = async function (server) {\n@@ -23,6 +35,11 @@ Sockets.init = async function (server) {\n \tconst SocketIO = require('socket.io').Server;\n \tconst io = new SocketIO({\n \t\tpath: `${nconf.get('relative_path')}/socket.io`,\n+\t\t// Security limits to prevent resource exhaustion\n+\t\tmaxHttpBufferSize: nconf.get('socket.io:maxMessageSize') || MAX_MESSAGE_SIZE,\n+\t\tpingInterval: nconf.get('socket.io:pingInterval') || PING_INTERVAL,\n+\t\tpingTimeout: nconf.get('socket.io:pingTimeout') || PING_TIMEOUT,\n+\t\tconnectTimeout: nconf.get('socket.io:connectionTimeout') || CONNECTION_TIMEOUT,\n \t});\n \n \tif (nconf.get('isCluster')) {\n@@ -34,6 +51,7 @@ Sockets.init = async function (server) {\n \t\t}\n \t}\n \n+\tio.use(connectionLimiter);\n \tio.use(authorize);\n \n \tio.on('connection', onConnection);\n@@ -264,6 +282,65 @@ async function validateSession(socket, errorMsg) {\n \n const cookieParserAsync = util.promisify((req, callback) => cookieParser(req, {}, err => callback(err)));\n \n+/**\n+ * Middleware to limit the number of connections per IP and per user\n+ * Prevents resource exhaustion attacks by limiting concurrent connections\n+ */\n+async function connectionLimiter(socket, callback) {\n+\ttry {\n+\t\t// Get IP address\n+\t\tconst ip = socket.request.headers['x-forwarded-for'] || \n+\t\t\tsocket.request.connection.remoteAddress || \n+\t\t\tsocket.handshake.address || '';\n+\t\t\n+\t\t// Validate IP format\n+\t\tif (!ip || !validator.isIP(ip)) {\n+\t\t\treturn callback(new Error('[[error:invalid-ip-address]]'));\n+\t\t}\n+\t\t\n+\t\t// Check IP connection limit\n+\t\tconst ipCount = connectedIPs.get(ip) || 0;\n+\t\tconst maxPerIp = nconf.get('socket.io:maxConnectionsPerIp') || MAX_CONNECTIONS_PER_IP;\n+\t\t\n+\t\tif (ipCount >= maxPerIp) {\n+\t\t\twinston.warn(`[socket.io] Connection limit reached for IP: ${ip} (${ipCount}/${maxPerIp})`);\n+\t\t\treturn callback(new Error('[[error:connection-limit-reached]]'));\n+\t\t}\n+\t\t\n+\t\t// Track this connection for the IP\n+\t\tconnectedIPs.set(ip, ipCount + 1);\n+\t\t\n+\t\t// Clean up when socket disconnects\n+\t\tsocket.on('disconnect', () => {\n+\t\t\tconst currentCount = connectedIPs.get(ip);\n+\t\t\tif (currentCount) {\n+\t\t\t\tif (currentCount <= 1) {\n+\t\t\t\t\tconnectedIPs.delete(ip);\n+\t\t\t\t} else {\n+\t\t\t\t\tconnectedIPs.set(ip, currentCount - 1);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\n+\t\t\t// Also clean up user connection count if authenticated\n+\t\t\tif (socket.uid > 0) {\n+\t\t\t\tconst userCount = connectedUsers.get(socket.uid);\n+\t\t\t\tif (userCount) {\n+\t\t\t\t\tif (userCount <= 1) {\n+\t\t\t\t\t\tconnectedUsers.delete(socket.uid);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tconnectedUsers.set(socket.uid, userCount - 1);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\t\t\n+\t\tcallback();\n+\t} catch (err) {\n+\t\twinston.error(`[socket.io] Error in connection limiter: ${err.message}`);\n+\t\tcallback(err);\n+\t}\n+}\n+\n async function authorize(socket, callback) {\n \tconst { request } = socket;\n \n@@ -283,6 +360,20 @@ async function authorize(socket, callback) {\n \tif (sessionData && sessionData.passport && sessionData.passport.user) {\n \t\trequest.session = sessionData;\n \t\tsocket.uid = parseInt(sessionData.passport.user, 10);\n+\t\t\n+\t\t// Check user connection limit for authenticated users\n+\t\tif (socket.uid > 0) {\n+\t\t\tconst maxPerUser = nconf.get('socket.io:maxConnectionsPerUser') || MAX_CONNECTIONS_PER_USER;\n+\t\t\tconst userCount = connectedUsers.get(socket.uid) || 0;\n+\t\t\t\n+\t\t\tif (userCount >= maxPerUser) {\n+\t\t\t\twinston.warn(`[socket.io] Connection limit reached for user: ${socket.uid} (${userCount}/${maxPerUser})`);\n+\t\t\t\treturn callback(new Error('[[error:user-connection-limit-reached]]'));\n+\t\t\t}\n+\t\t\t\n+\t\t\t// Track this connection for the user\n+\t\t\tconnectedUsers.set(socket.uid, userCount + 1);\n+\t\t}\n \t} else {\n \t\tsocket.uid = 0;\n \t}\n@@ -315,3 +406,44 @@ Sockets.warnDeprecated = (socket, replacement) => {\n \t}\n \twinston.warn(`[deprecated]\\n ${new Error('-').stack.split('\\n').slice(2, 5).join('\\n')}\\n     use ${replacement}`);\n };\n+\n+/**\n+ * Get the current connection statistics\n+ * @returns {Object} Connection statistics\n+ */\n+Sockets.getConnectionStats = function () {\n+\treturn {\n+\t\t// Connection counts\n+\t\tipCount: connectedIPs.size,\n+\t\tuserCount: connectedUsers.size,\n+\t\ttotalConnections: Sockets.server ? Sockets.server.sockets.sockets.size : 0,\n+\t\t\n+\t\t// Connection limits\n+\t\tmaxConnectionsPerIp: nconf.get('socket.io:maxConnectionsPerIp') || MAX_CONNECTIONS_PER_IP,\n+\t\tmaxConnectionsPerUser: nconf.get('socket.io:maxConnectionsPerUser') || MAX_CONNECTIONS_PER_USER,\n+\t\t\n+\t\t// Socket.io configuration\n+\t\tmaxMessageSize: nconf.get('socket.io:maxMessageSize') || MAX_MESSAGE_SIZE,\n+\t\tpingInterval: nconf.get('socket.io:pingInterval') || PING_INTERVAL,\n+\t\tpingTimeout: nconf.get('socket.io:pingTimeout') || PING_TIMEOUT,\n+\t\tconnectionTimeout: nconf.get('socket.io:connectionTimeout') || CONNECTION_TIMEOUT,\n+\t};\n+};\n+\n+/**\n+ * Get the current connections for a specific IP\n+ * @param {string} ip - The IP address to check\n+ * @returns {number} Number of connections from this IP\n+ */\n+Sockets.getIPConnections = function (ip) {\n+\treturn connectedIPs.get(ip) || 0;\n+};\n+\n+/**\n+ * Get the current connections for a specific user\n+ * @param {number} uid - The user ID to check\n+ * @returns {number} Number of connections from this user\n+ */\n+Sockets.getUserConnections = function (uid) {\n+\treturn connectedUsers.get(uid) || 0;\n+};"},{"message":"Fix the uploads module in src/socket.io/uploads.js to address three security vulnerabilities: 1) Add a limit on the number of concurrent uploads per user to prevent memory exhaustion, 2) Add proper authorization checks to the clear function to prevent unauthorized clearing of other users' uploads, and 3) Add a limit on the total size of uploads in the inProgress global variable.","diff":"diff --git a/src/socket.io/uploads.js b/src/socket.io/uploads.js\nindex 66b7266..893068b 100644\n--- a/src/socket.io/uploads.js\n+++ b/src/socket.io/uploads.js\n@@ -4,8 +4,17 @@ const socketUser = require('./user');\n const socketGroup = require('./groups');\n const image = require('../image');\n const meta = require('../meta');\n+const user = require('../user');\n \n+// Security limits\n+const MAX_UPLOADS_PER_USER = 5; // Maximum number of concurrent uploads per user\n+const MAX_TOTAL_SIZE_PER_USER = 10 * 1024 * 1024; // 10MB maximum total size per user\n+const MAX_GLOBAL_UPLOADS_SIZE = 100 * 1024 * 1024; // 100MB maximum total size across all users\n+const UPLOAD_TIMEOUT = 30 * 60 * 1000; // 30 minutes timeout for uploads\n+\n+// Track uploads in progress\n const inProgress = {};\n+let totalUploadSize = 0; // Track total size of all uploads\n \n const uploads = module.exports;\n \n@@ -20,34 +29,163 @@ uploads.upload = async function (socket, data) {\n \t\tthrow new Error('[[error:invalid-data]]');\n \t}\n \n+\t// Initialize user's upload tracking\n \tinProgress[socket.id] = inProgress[socket.id] || Object.create(null);\n \tconst socketUploads = inProgress[socket.id];\n \tconst { method } = data.params;\n \n-\tsocketUploads[method] = socketUploads[method] || { imageData: '' };\n-\tsocketUploads[method].imageData += data.chunk;\n+\t// Check number of concurrent uploads per user\n+\tconst currentUploadsCount = Object.keys(socketUploads).length;\n+\tif (!socketUploads[method] && currentUploadsCount >= MAX_UPLOADS_PER_USER) {\n+\t\tthrow new Error('[[error:too-many-uploads]]');\n+\t}\n \n+// Initialize method's upload data\n+\tsocketUploads[method] = socketUploads[method] || { \n+\t\timageData: '',\n+\t\tuid: socket.uid, // Store the user ID for authorization checks\n+\t\tsize: 0,\n+\t\ttimestamp: Date.now() // Track when this upload was last updated\n+\t};\n+\t\n+// Add chunk to the upload\n+\tsocketUploads[method].imageData += data.chunk;\n+\t// Update timestamp to prevent premature cleanup\n+\tsocketUploads[method].timestamp = Date.now();\n+\t\n \ttry {\n \t\tconst maxSize = data.params.method === 'user.uploadCroppedPicture' ?\n \t\t\tmeta.config.maximumProfileImageSize : meta.config.maximumCoverImageSize;\n \t\tconst size = image.sizeFromBase64(socketUploads[method].imageData);\n-\n+\t\t\n+\t\t// Update size tracking\n+\t\tconst oldSize = socketUploads[method].size || 0;\n+\t\tconst sizeDiff = size - oldSize;\n+\t\tsocketUploads[method].size = size;\n+\t\t\n+\t\t// Update total size counters\n+\t\ttotalUploadSize += sizeDiff;\n+\t\t\n+\t\t// Check individual file size limit\n \t\tif (size > maxSize * 1024) {\n \t\t\tthrow new Error(`[[error:file-too-big, ${maxSize}]]`);\n \t\t}\n+\t\t\n+\t\t// Check user's total upload size limit\n+\t\tlet userTotalSize = 0;\n+\t\tObject.keys(socketUploads).forEach(key => {\n+\t\t\tuserTotalSize += socketUploads[key].size || 0;\n+\t\t});\n+\t\t\n+\t\tif (userTotalSize > MAX_TOTAL_SIZE_PER_USER) {\n+\t\t\tthrow new Error('[[error:upload-limit-exceeded]]');\n+\t\t}\n+\t\t\n+\t\t// Check global upload size limit\n+\t\tif (totalUploadSize > MAX_GLOBAL_UPLOADS_SIZE) {\n+\t\t\tthrow new Error('[[error:global-upload-limit-exceeded]]');\n+\t\t}\n+\t\t\n+\t\t// Continue with upload if not complete\n \t\tif (socketUploads[method].imageData.length < data.params.size) {\n \t\t\treturn;\n \t\t}\n+\t\t\n+\t\t// Process completed upload\n \t\tdata.params.imageData = socketUploads[method].imageData;\n \t\tconst result = await methodToFunc[data.params.method](socket, data.params);\n+\t\t\n+\t\t// Clean up after successful upload\n+\t\ttotalUploadSize -= socketUploads[method].size;\n \t\tdelete socketUploads[method];\n \t\treturn result;\n \t} catch (err) {\n-\t\tdelete inProgress[socket.id];\n+\t\t// Clean up on error\n+\t\tif (socketUploads[method]) {\n+\t\t\ttotalUploadSize -= socketUploads[method].size || 0;\n+\t\t\tdelete socketUploads[method];\n+\t\t}\n+\t\t\n+\t\t// If no more uploads for this socket, remove the socket entry\n+\t\tif (Object.keys(socketUploads).length === 0) {\n+\t\t\tdelete inProgress[socket.id];\n+\t\t}\n+\t\t\n \t\tthrow err;\n \t}\n };\n \n-uploads.clear = function (sid) {\n+uploads.clear = async function (socket, sid) {\n+\t// If no socket provided or user not logged in, reject the request\n+\tif (!socket || !socket.uid) {\n+\t\tthrow new Error('[[error:not-authorized]]');\n+\t}\n+\n+\t// If no sid provided, reject the request\n+\tif (!sid) {\n+\t\tthrow new Error('[[error:invalid-data]]');\n+\t}\n+\n+\t// Check if the upload exists\n+\tif (!inProgress[sid]) {\n+\t\treturn;\n+\t}\n+\n+\t// Check if the user is authorized to clear this upload\n+\t// Only allow users to clear their own uploads or admins to clear any\n+\tconst isAdmin = await user.isAdministrator(socket.uid);\n+\tconst isOwner = socket.id === sid;\n+\t\n+\t// If not authorized, reject the request\n+\tif (!isAdmin && !isOwner) {\n+\t\tthrow new Error('[[error:not-authorized]]');\n+\t}\n+\n+\t// Update the total upload size counter before clearing\n+\tif (inProgress[sid]) {\n+\t\tObject.keys(inProgress[sid]).forEach(method => {\n+\t\t\tif (inProgress[sid][method] && inProgress[sid][method].size) {\n+\t\t\t\ttotalUploadSize -= inProgress[sid][method].size;\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\t// Clear the upload\n \tdelete inProgress[sid];\n };\n+\n+/**\n+ * Clean up stale uploads to prevent memory leaks\n+ */\n+uploads.cleanupStaleUploads = function () {\n+\tconst now = Date.now();\n+\t\n+\t// Check each socket's uploads\n+\tObject.keys(inProgress).forEach((sid) => {\n+\t\tconst socketUploads = inProgress[sid];\n+\t\t\n+\t\t// Check each upload method for this socket\n+\t\tObject.keys(socketUploads).forEach((method) => {\n+\t\t\tconst upload = socketUploads[method];\n+\t\t\t\n+\t\t\t// If the upload is stale (hasn't been updated in UPLOAD_TIMEOUT ms)\n+\t\t\tif (upload.timestamp && (now - upload.timestamp > UPLOAD_TIMEOUT)) {\n+\t\t\t\t// Update the total size counter\n+\t\t\t\tif (upload.size) {\n+\t\t\t\t\ttotalUploadSize -= upload.size;\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t\t// Remove the stale upload\n+\t\t\t\tdelete socketUploads[method];\n+\t\t\t}\n+\t\t});\n+\t\t\n+\t\t// If no more uploads for this socket, remove the socket entry\n+\t\tif (Object.keys(socketUploads).length === 0) {\n+\t\t\tdelete inProgress[sid];\n+\t\t}\n+\t});\n+};\n+\n+// Set up periodic cleanup of stale uploads\n+setInterval(uploads.cleanupStaleUploads, UPLOAD_TIMEOUT / 2);"}]}]}