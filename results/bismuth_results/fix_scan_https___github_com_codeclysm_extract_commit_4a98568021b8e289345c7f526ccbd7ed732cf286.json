{"scanned_subsystems":[{"name":"Core Extraction","files":["extract.go","extractor.go"]},{"name":"Tools","files":["evil_generator/main.go"]}],"changesets":[{"title":"Security Fixes for Core Extraction Subsystem: Path Traversal and Resource Exhaustion Vulnerabilities","body":"## Security Vulnerability Fixes\n\nThis pull request addresses three critical security vulnerabilities in the Core Extraction subsystem:\n\n### 1. Path Traversal Vulnerability in Tar Hard Links\n- **Issue**: Unsafe file path handling in the Tar method could allow path traversal attacks\n- **Fix**: \n  - Replaced `filepath.Join` with `safeJoin` for hard links\n  - Added proper error handling to prevent path traversal through crafted hard links\n- **Location**: `extractor.go`, lines 219-220\n\n### 2. Symbolic Link Validation Vulnerability\n- **Issue**: Lack of validation for symbolic link targets in Tar and Zip extraction methods\n- **Fix**:\n  - Added `safeJoin` validation to ensure symlink targets don't point outside the extraction directory\n  - Prevents potential directory traversal attacks\n- **Locations**: \n  - Tar method: around line 246-247\n  - Zip method: similar changes applied\n\n### 3. Resource Exhaustion Prevention\n- **Issue**: Potential decompression bomb or resource exhaustion vulnerability in file copying\n- **Fix**:\n  - Introduced `MaxCopySize` constant (1GB) to limit file copy operations\n  - Added `ErrCopyLimitExceeded` to handle cases where copy limit is reached\n  - Modified `copyCancel` function to use `LimitedReader`\n- **Location**: `cancelable_reader.go`\n\n### Security Impact\nThese changes mitigate:\n- Path traversal attacks\n- Symbolic link-based directory escape\n- Potential resource exhaustion through large file or decompression bomb attacks\n\n### Recommended Action\n- Review and merge these security fixes\n- Update any dependent systems to use the new, more secure extraction methods\n\n**CVE Tracking**: Recommend assigning CVE identifiers for these vulnerabilities","commits":[{"message":"Fix the path traversal vulnerability in the Tar method where hard links use filepath.Join instead of safeJoin. In the Tar method at line 219-220, replace the filepath.Join with safeJoin and add proper error handling to prevent path traversal attacks through specially crafted hard links.","diff":"diff --git a/extractor.go b/extractor.go\nindex f408e4f..1e0b1dc 100644\n--- a/extractor.go\n+++ b/extractor.go\n@@ -217,7 +217,10 @@ func (e *Extractor) Tar(ctx context.Context, body io.Reader, location string, re\n \t\t\t\tname = rename(name)\n \t\t\t}\n \n-\t\t\tname = filepath.Join(location, name)\n+\t\t\tvar err error\n+\t\t\tif name, err = safeJoin(location, name); err != nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tlinks = append(links, &link{Path: path, Name: name})\n \t\tcase tar.TypeSymlink:\n \t\t\tsymlinks = append(symlinks, &link{Path: path, Name: header.Linkname})"},{"message":"Fix the security vulnerability in the Tar method where symbolic links are not validated. In the Tar method around line 246-247, add validation using safeJoin to ensure that symbolic link targets don't point outside the extraction directory.","diff":"diff --git a/extractor.go b/extractor.go\nindex 1e0b1dc..5e6c801 100644\n--- a/extractor.go\n+++ b/extractor.go\n@@ -247,7 +247,12 @@ func (e *Extractor) Tar(ctx context.Context, body io.Reader, location string, re\n \t\tdefault:\n \t\t}\n \t\t_ = e.FS.Remove(symlink.Path)\n-\t\tif err := e.FS.Symlink(symlink.Name, symlink.Path); err != nil {\n+\t\t// Validate that the symlink target doesn't point outside the extraction directory\n+\t\ttarget, err := safeJoin(location, symlink.Name)\n+\t\tif err != nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err := e.FS.Symlink(target, symlink.Path); err != nil {\n \t\t\treturn errors.Annotatef(err, \"Create link %s\", symlink.Path)\n \t\t}\n \t}\n@@ -351,7 +356,12 @@ func (e *Extractor) Zip(ctx context.Context, body io.Reader, location string, re\n \t\tdefault:\n \t\t}\n \t\t_ = e.FS.Remove(link.Path)\n-\t\tif err := e.FS.Symlink(link.Name, link.Path); err != nil {\n+\t\t// Validate that the symlink target doesn't point outside the extraction directory\n+\t\ttarget, err := safeJoin(location, link.Name)\n+\t\tif err != nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err := e.FS.Symlink(target, link.Path); err != nil {\n \t\t\treturn errors.Annotatef(err, \"Create link %s\", link.Path)\n \t\t}\n \t}"},{"message":"Add size limits to the copyCancel function to prevent resource exhaustion with large files or decompression bombs. Modify the function to track the amount of data copied and return an error if it exceeds a reasonable limit (e.g., 1GB).","diff":"diff --git a/cancelable_reader.go b/cancelable_reader.go\nindex 368a3b9..771a745 100644\n--- a/cancelable_reader.go\n+++ b/cancelable_reader.go\n@@ -6,8 +6,29 @@ import (\n \t\"io\"\n )\n \n+// MaxCopySize defines the maximum size in bytes that can be copied (1GB)\n+// to prevent resource exhaustion and decompression bomb attacks\n+const MaxCopySize int64 = 1073741824 // 1GB\n+\n+// ErrCopyLimitExceeded is returned when the copy operation exceeds the maximum allowed size\n+var ErrCopyLimitExceeded = errors.New(\"copy limit exceeded: potential decompression bomb or resource exhaustion attack\")\n+\n func copyCancel(ctx context.Context, dst io.Writer, src io.Reader) (int64, error) {\n-\treturn io.Copy(dst, newCancelableReader(ctx, src))\n+\t// Use a limited reader to prevent resource exhaustion\n+\tlimitedReader := &io.LimitedReader{\n+\t\tR: newCancelableReader(ctx, src),\n+\t\tN: MaxCopySize,\n+\t}\n+\t\n+\twritten, err := io.Copy(dst, limitedReader)\n+\t\n+\t// If we've written exactly MaxCopySize bytes and there's no error,\n+\t// it means we've hit the limit and there might be more data\n+\tif err == nil && written == MaxCopySize && limitedReader.N == 0 {\n+\t\treturn written, ErrCopyLimitExceeded\n+\t}\n+\t\n+\treturn written, err\n }\n \n type cancelableReader struct {"}]}]}