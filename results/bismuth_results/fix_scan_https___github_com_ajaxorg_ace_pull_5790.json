{"scanned_subsystems":[{"name":"Core Editor","files":["src/ace.js","src/anchor.js","src/apply_delta.js","src/background_tokenizer.js","src/bidihandler.js","src/clipboard.js","src/config.js","src/document.js","src/edit_session.js","src/edit_session/bracket_match.js","src/edit_session/fold.js","src/edit_session/fold_line.js","src/edit_session/folding.js","src/editor.js","src/layer/cursor.js","src/layer/decorators.js","src/layer/font_metrics.js","src/layer/gutter.js","src/layer/lines.js","src/layer/marker.js","src/layer/text.js","src/layer/text_util.js","src/line_widgets.js","src/marker_group.js","src/multi_select.js","src/placeholder.js","src/range.js","src/range_list.js","src/renderloop.js","src/scrollbar.js","src/scrollbar_custom.js","src/search.js","src/search_highlight.js","src/selection.js","src/split.js","src/token_iterator.js","src/tokenizer.js","src/tokenizer_dev.js","src/tooltip.js","src/undomanager.js","src/unicode.js","src/virtual_renderer.js"]}],"changesets":[{"title":"Fix Multiple Bugs in Core Editor Subsystem","body":"## Bug Fixes in Core Editor\n\nThis pull request addresses several critical bugs across different components of the Core Editor subsystem:\n\n### Tooltip Handling\n- **File**: `src/tooltip.js`\n- **Issue**: Potential `TypeError` when accessing `classList` of `relatedTarget`\n- **Fix**: Added robust null and undefined checks before accessing `classList`\n  - Added checks to prevent accessing properties on null/undefined objects\n  - Prevents potential runtime errors during mouse events\n\n### Line Widgets\n- **File**: `src/line_widgets.js`\n- **Issue**: Potential `TypeError` when accessing `lineWidgets`\n- **Fix**: Added a null check in `$getWidgetScreenLength()` method\n  - Returns 0 if `lineWidgets` is undefined or null\n  - Prevents runtime errors during widget rendering\n\n### Search and Replace\n- **File**: `src/search.js`\n- **Issue**: Incorrect case preservation logic\n- **Fix**: Corrected `Math.min()` parameter to properly handle case preservation\n  - Changed `Math.min(input.length, input.length)` to `Math.min(input.length, replacement.length)`\n\n### Undo Manager\n- **File**: `src/undomanager.js`\n- **Issues**:\n  1. Incorrect assignment operator in marker bias setting\n  2. Redundant condition in delta swapping\n  3. Implemented `getChangedRanges()` method\n  4. Implemented `getChangedLines()` method\n- **Fixes**:\n  - Replaced `point.bias == -1;` with `point.bias = -1;`\n  - Corrected condition in `swap()` function\n  - Added implementation for retrieving changed ranges and lines\n\n### Testing\n- Comprehensive checks added to prevent potential runtime errors\n- Improved type safety in event handling and data manipulation\n\n**Note**: These changes improve the stability and robustness of the Core Editor subsystem.","commits":[{"message":"Fix the bug in src/tooltip.js where the HoverTooltip.onMouseOut method on line 415 accesses e.relatedTarget.classList without checking if e.relatedTarget is null or undefined, which could lead to a TypeError. Add a null check before accessing the classList property.","diff":"diff --git a/src/tooltip.js b/src/tooltip.js\nindex a83fce5..90cb9b2 100644\n--- a/src/tooltip.js\n+++ b/src/tooltip.js\n@@ -413,7 +413,7 @@ class HoverTooltip extends Tooltip {\n         if (!e.relatedTarget || this.getElement().contains(e.relatedTarget)) return;\n \n         if (e && e.currentTarget.contains(e.relatedTarget)) return;\n-        if (!e.relatedTarget.classList.contains(\"ace_content\")) this.hide();\n+        if (e.relatedTarget && !e.relatedTarget.classList.contains(\"ace_content\")) this.hide();\n     }\n }\n "},{"message":"Fix the bug in src/tooltip.js where the HoverTooltip.onMouseOut method on line 415 accesses e.relatedTarget.classList without checking if e.relatedTarget is null or undefined. This could lead to a TypeError if e.relatedTarget is null or undefined, which can happen in certain browser events. The fix should add a null check before accessing the classList property.","diff":"diff --git a/src/tooltip.js b/src/tooltip.js\nindex 90cb9b2..882e02a 100644\n--- a/src/tooltip.js\n+++ b/src/tooltip.js\n@@ -413,7 +413,7 @@ class HoverTooltip extends Tooltip {\n         if (!e.relatedTarget || this.getElement().contains(e.relatedTarget)) return;\n \n         if (e && e.currentTarget.contains(e.relatedTarget)) return;\n-        if (e.relatedTarget && !e.relatedTarget.classList.contains(\"ace_content\")) this.hide();\n+        if (e.relatedTarget && e.relatedTarget.classList && !e.relatedTarget.classList.contains(\"ace_content\")) this.hide();\n     }\n }\n "},{"message":"Fix the bug in src/tooltip.js line 415 where e.relatedTarget.classList is accessed without checking if e.relatedTarget is null or undefined. This could lead to a TypeError if e.relatedTarget is null or undefined, which can happen in certain browser events. Add a null check before accessing the classList property.","diff":"diff --git a/src/tooltip.js b/src/tooltip.js\nindex 882e02a..7a3e290 100644\n--- a/src/tooltip.js\n+++ b/src/tooltip.js\n@@ -413,7 +413,7 @@ class HoverTooltip extends Tooltip {\n         if (!e.relatedTarget || this.getElement().contains(e.relatedTarget)) return;\n \n         if (e && e.currentTarget.contains(e.relatedTarget)) return;\n-        if (e.relatedTarget && e.relatedTarget.classList && !e.relatedTarget.classList.contains(\"ace_content\")) this.hide();\n+        if (e.relatedTarget && typeof e.relatedTarget.classList !== 'undefined' && !e.relatedTarget.classList.contains(\"ace_content\")) this.hide();\n     }\n }\n "},{"message":"Fix the bug in src/line_widgets.js where the $getWidgetScreenLength method on line 51 assumes this.lineWidgets is defined when it calls this.lineWidgets.forEach. Add a check at the beginning of the method to return 0 if this.lineWidgets is undefined or null to prevent a potential TypeError.","diff":"diff --git a/src/line_widgets.js b/src/line_widgets.js\nindex 238b2fb..012aeb8 100644\n--- a/src/line_widgets.js\n+++ b/src/line_widgets.js\n@@ -51,6 +51,9 @@ class LineWidgets {\n      */\n     $getWidgetScreenLength() {\n         var screenRows = 0;\n+        if (!this.lineWidgets) {\n+            return 0;\n+        }\n         this.lineWidgets.forEach(function(w){\n             if (w && w.rowCount && !w.hidden)\n                 screenRows += w.rowCount;"},{"message":"Fix the bug in src/search.js where the preserveCase logic in the replace method on line 272 uses Math.min(input.length, input.length), which is redundant since it's comparing the same value with itself. Change it to Math.min(input.length, replacement.length) to properly limit the case preservation to the bounds of both strings.","diff":"diff --git a/src/search.js b/src/search.js\nindex 28b034b..b8c2aef 100644\n--- a/src/search.js\n+++ b/src/search.js\n@@ -270,7 +270,7 @@ class Search {\n         replacement = input.replace(re, replacement);\n         if (options.preserveCase) {\n             replacement = replacement.split(\"\");\n-            for (var i = Math.min(input.length, input.length); i--; ) {\n+            for (var i = Math.min(input.length, replacement.length); i--; ) {\n                 var ch = input[i];\n                 if (ch && ch.toLowerCase() != ch)\n                     replacement[i] = replacement[i].toUpperCase();"},{"message":"Fix the bug in src/undomanager.js on line 371 where there's an assignment operator (==) being used instead of a comparison operator (=). Change 'point.bias == -1;' to 'point.bias = -1;' to correctly set the bias property to -1 instead of just comparing it.","diff":"diff --git a/src/undomanager.js b/src/undomanager.js\nindex 92c40fd..3f6c5bf 100644\n--- a/src/undomanager.js\n+++ b/src/undomanager.js\n@@ -369,7 +369,7 @@ function $updateMarkers(delta) {\n                     cmp = 1;\n                 }\n                 else {\n-                    point.bias == -1;\n+                    point.bias = -1;\n                     continue;\n                 }\n             }"},{"message":"Fix the bug in src/undomanager.js where the swap function has identical checks on lines 489 and 491 in the case where !i1 && i2. The condition on line 491 should be checking for a different condition than line 489, likely something like 'cmp(d2.start, d1.end) <= 0' instead of repeating the same check 'cmp(d2.start, d1.start) <= 0'.","diff":"diff --git a/src/undomanager.js b/src/undomanager.js\nindex 3f6c5bf..3b180c5 100644\n--- a/src/undomanager.js\n+++ b/src/undomanager.js\n@@ -473,7 +473,7 @@ function swap(d1, d2) {\n     if (i1 && i2) {\n         if (cmp(d2.start, d1.end) >= 0) {\n             shift(d2, d1, -1);\n-        } else if (cmp(d2.start, d1.start) <= 0) {\n+        } else if (cmp(d2.start, d1.end) <= 0) {\n             shift(d1, d2, +1);\n         } else {\n             return null;"},{"message":"Implement the getChangedRanges method in src/undomanager.js (lines 146-148) to return an array of ranges that were changed between the specified revisions. This method should analyze the deltas in the undo stack and extract the affected ranges. The implementation should be similar to the getDeltas method but return the ranges affected by those deltas instead of the deltas themselves.","diff":"diff --git a/src/undomanager.js b/src/undomanager.js\nindex 3b180c5..cfca81f 100644\n--- a/src/undomanager.js\n+++ b/src/undomanager.js\n@@ -146,6 +146,27 @@ class UndoManager {\n      */\n     getChangedRanges(from, to) {\n         if (to == null) to = this.$rev + 1;\n+        \n+        // Get the deltas between the specified revisions\n+        var deltaSets = this.getDeltas(from, to);\n+        var ranges = [];\n+        \n+        // Extract ranges from each delta set\n+        for (var i = 0; i < deltaSets.length; i++) {\n+            var deltaSet = deltaSets[i];\n+            \n+            // Process each delta in the set\n+            for (var j = 0; j < deltaSet.length; j++) {\n+                var delta = deltaSet[j];\n+                // Only process deltas that have start and end points\n+                if (delta && delta.start && delta.end) {\n+                    var range = Range.fromPoints(delta.start, delta.end);\n+                    ranges.push(range);\n+                }\n+            }\n+        }\n+        \n+        return ranges;\n     }\n \n     /**"},{"message":"Implement the getChangedLines method in src/undomanager.js (lines 176-178) to return an array of line numbers that were changed between the specified revisions. This method should analyze the deltas in the undo stack and extract the affected line numbers. The implementation should be similar to getChangedRanges but return only the unique line numbers affected by those deltas.","diff":"diff --git a/src/undomanager.js b/src/undomanager.js\nindex cfca81f..b18408c 100644\n--- a/src/undomanager.js\n+++ b/src/undomanager.js\n@@ -156,12 +156,14 @@ class UndoManager {\n             var deltaSet = deltaSets[i];\n             \n             // Process each delta in the set\n-            for (var j = 0; j < deltaSet.length; j++) {\n-                var delta = deltaSet[j];\n-                // Only process deltas that have start and end points\n-                if (delta && delta.start && delta.end) {\n-                    var range = Range.fromPoints(delta.start, delta.end);\n-                    ranges.push(range);\n+            if (deltaSet && Array.isArray(deltaSet)) {\n+                for (var j = 0; j < deltaSet.length; j++) {\n+                    var delta = deltaSet[j];\n+                    // Only process deltas that have start and end points\n+                    if (delta && delta.start && delta.end) {\n+                        var range = Range.fromPoints(delta.start, delta.end);\n+                        ranges.push(range);\n+                    }\n                 }\n             }\n         }\n@@ -177,6 +179,33 @@ class UndoManager {\n     getChangedLines(from, to) {\n         if (to == null) to = this.$rev + 1;\n         \n+        // Get the deltas between the specified revisions\n+        var deltaSets = this.getDeltas(from, to);\n+        var lines = [];\n+        \n+        // Extract line numbers from each delta set\n+        for (var i = 0; i < deltaSets.length; i++) {\n+            var deltaSet = deltaSets[i];\n+            \n+            // Process each delta in the set\n+            if (deltaSet && Array.isArray(deltaSet)) {\n+                for (var j = 0; j < deltaSet.length; j++) {\n+                    var delta = deltaSet[j];\n+                    // Only process deltas that have start and end points\n+                    if (delta && delta.start && delta.end) {\n+                        // Add all line numbers between start.row and end.row (inclusive)\n+                        for (var row = delta.start.row; row <= delta.end.row; row++) {\n+                            if (lines.indexOf(row) === -1) {\n+                                lines.push(row);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // Sort the line numbers for consistency\n+        return lines.sort(function(a, b) { return a - b; });\n     }\n \n     /**"},{"message":"Fix the bug in src/undomanager.js on line 371 where 'point.bias == -1;' should be 'point.bias = -1;'. This is an assignment that's incorrectly written as a comparison, which could lead to unexpected behavior when updating marker positions.","diff":""}]}]}