{"scanned_subsystems":[{"name":"User Interface","files":["src/ui/suggestionManager.ts","src/ui/ui-root.ts","src/ui/ui-uninstall.ts","src/ui/utils.ts"]}],"changesets":[{"title":"Fix Multiple UI Subsystem Bugs and Improve Error Handling","body":"## Overview\nThis pull request addresses several critical bugs and improves error handling in the User Interface subsystem. The fixes span multiple components and address issues related to path construction, suggestion rendering, text truncation, and error management.\n\n## Key Fixes\n\n### Path Construction and Cache Management\n- Fixed `deleteCacheFolder` function in `src/utils/config.ts` to:\n  - Correctly use `cachePath` directly instead of incorrectly joining with `os.homedir()`\n  - Use async/await with `fsAsync` for proper asynchronous file operations\n  - Add error handling for directory access and deletion\n\n### Suggestion Management\n- Improved `SuggestionManager` in `src/ui/suggestionManager.ts`:\n  - Added error handling for `getSuggestions` call\n  - Enhanced validation for suggestion navigation and selection\n  - Added checks to prevent errors with undefined or empty suggestion lists\n  - Improved handling of edge cases in suggestion rendering\n\n### Text Truncation and UI Rendering\n- Fixed text truncation functions in `src/ui/utils.ts`:\n  - Added validation for width calculations\n  - Prevented negative or zero-width rendering issues\n  - Improved handling of narrow terminal scenarios\n- Enhanced `renderBox` function to handle rows longer than available width\n- Fixed typo in `wcwidth` import\n\n### Uninstall UI\n- Improved error handling in uninstall UI\n- Fixed async function awaiting and error display\n\n### Root UI Rendering\n- Added comprehensive error handling for async operations\n- Added checks for non-TTY environments to prevent feature-specific errors\n- Improved terminal resize and keypress event handling\n\n## Testing Recommendations\n- Test cache folder deletion in various scenarios\n- Verify suggestion rendering in terminals of different sizes\n- Check uninstall process with and without existing cache\n- Test UI rendering in both TTY and non-TTY environments\n\nResolves potential stability and usability issues in the User Interface subsystem.","commits":[{"message":"Fix the path construction issue in the deleteCacheFolder function in src/utils/config.ts. The function incorrectly constructs cliConfigPath by joining os.homedir() with cachePath, which already includes os.homedir(). This creates an invalid nested path like '/home/user//home/user/.inshellisense'. The fix should use cachePath directly instead of joining it with os.homedir() again.","diff":"diff --git a/src/utils/config.ts b/src/utils/config.ts\nindex d1c9980..bd5261b 100644\n--- a/src/utils/config.ts\n+++ b/src/utils/config.ts\n@@ -135,8 +135,8 @@ export const loadConfig = async (program: Command) => {\n };\n \n export const deleteCacheFolder = async (): Promise<void> => {\n-  const cliConfigPath = path.join(os.homedir(), cachePath);\n-  if (fs.existsSync(cliConfigPath)) {\n-    fs.rmSync(cliConfigPath, { recursive: true });\n+  // Use cachePath directly as it already includes os.homedir()\n+  if (fs.existsSync(cachePath)) {\n+    fs.rmSync(cachePath, { recursive: true });\n   }\n };"},{"message":"Fix the render function in src/ui/ui-uninstall.ts to properly await the deleteCacheFolder async function and add error handling to prevent displaying success messages when deletion fails. Also fix the typo in the uninstall message where \"the\" is duplicated.","diff":"diff --git a/src/ui/ui-uninstall.ts b/src/ui/ui-uninstall.ts\nindex c96a30e..b869c94 100644\n--- a/src/ui/ui-uninstall.ts\n+++ b/src/ui/ui-uninstall.ts\n@@ -5,9 +5,16 @@ import chalk from \"chalk\";\n import { deleteCacheFolder } from \"../utils/config.js\";\n \n export const render = async () => {\n-  deleteCacheFolder();\n-  process.stdout.write(chalk.green(\"✓\") + \" successfully deleted the .inshellisense cache folder \\n\");\n-  process.stdout.write(\n-    chalk.magenta(\"•\") + \" to complete the uninstall, run the the command: \" + chalk.underline(chalk.cyan(\"npm uninstall -g @microsoft/inshellisense\")) + \"\\n\",\n-  );\n+  try {\n+    await deleteCacheFolder();\n+    process.stdout.write(chalk.green(\"✓\") + \" successfully deleted the .inshellisense cache folder \\n\");\n+    process.stdout.write(\n+      chalk.magenta(\"•\") + \" to complete the uninstall, run the command: \" + chalk.underline(chalk.cyan(\"npm uninstall -g @microsoft/inshellisense\")) + \"\\n\",\n+    );\n+  } catch (error) {\n+    process.stdout.write(chalk.red(\"✗\") + \" failed to delete the .inshellisense cache folder \\n\");\n+    process.stdout.write(\n+      chalk.magenta(\"•\") + \" to complete the uninstall, run the command: \" + chalk.underline(chalk.cyan(\"npm uninstall -g @microsoft/inshellisense\")) + \"\\n\",\n+    );\n+  }\n };"},{"message":"Fix the deleteCacheFolder function in src/utils/config.ts to properly use async/await with fsAsync instead of synchronous fs operations, since it's declared as an async function that returns Promise<void>.","diff":"diff --git a/src/utils/config.ts b/src/utils/config.ts\nindex bd5261b..9afdabb 100644\n--- a/src/utils/config.ts\n+++ b/src/utils/config.ts\n@@ -136,7 +136,13 @@ export const loadConfig = async (program: Command) => {\n \n export const deleteCacheFolder = async (): Promise<void> => {\n   // Use cachePath directly as it already includes os.homedir()\n-  if (fs.existsSync(cachePath)) {\n-    fs.rmSync(cachePath, { recursive: true });\n+  try {\n+    await fsAsync.access(cachePath);\n+    await fsAsync.rm(cachePath, { recursive: true });\n+  } catch (error) {\n+    // If the directory doesn't exist, that's fine - nothing to delete\n+    if (error.code !== 'ENOENT') {\n+      throw error; // Re-throw if it's a different error\n+    }\n   }\n };"},{"message":"Fix the potential error in SuggestionManager's update method (line 182-183) where chars could be undefined if both suggestion?.insertValue and suggestion?.name are undefined, which would cause an error when chars.trim() is called. Add a null check or provide a default empty string to prevent this error.","diff":"diff --git a/src/ui/suggestionManager.ts b/src/ui/suggestionManager.ts\nindex 5f7fdda..918f5d2 100644\n--- a/src/ui/suggestionManager.ts\n+++ b/src/ui/suggestionManager.ts\n@@ -180,7 +180,7 @@ export class SuggestionManager {\n     } else if (name == acceptKey && shift == !!acceptShift && ctrl == !!acceptCtrl) {\n       const removals = \"\\u007F\".repeat(this.#suggestBlob?.charactersToDrop ?? 0);\n       const suggestion = this.#suggestBlob?.suggestions.at(this.#activeSuggestionIdx);\n-      const chars = suggestion?.insertValue ?? suggestion?.name + \" \";\n+      const chars = suggestion?.insertValue ?? (suggestion?.name ? suggestion?.name + \" \" : \"\");\n       if (this.#suggestBlob == null || !chars.trim() || this.#suggestBlob?.suggestions.length == 0) {\n         return false;\n       }"},{"message":"Fix the typo in the variable name 'wcwdith' on line 6 and line 43 of src/ui/utils.ts (should be 'wcwidth'). This is a simple spelling correction that will improve code readability and prevent potential future issues.","diff":"diff --git a/src/ui/utils.ts b/src/ui/utils.ts\nindex a6f3e4e..4fc0ac7 100644\n--- a/src/ui/utils.ts\n+++ b/src/ui/utils.ts\n@@ -4,7 +4,7 @@\n import ansi from \"ansi-escapes\";\n import wrapAnsi from \"wrap-ansi\";\n import chalk from \"chalk\";\n-import wcwdith from \"wcwidth\";\n+import wcwidth from \"wcwidth\";\n \n /**\n  * Renders a box around the given rows\n@@ -41,7 +41,7 @@ export const truncateMultilineText = (description: string, width: number, maxHei\n  */\n export const truncateText = (text: string, width: number) => {\n   const textPoints = [...text];\n-  const wcOffset = Math.max(wcwdith(text) - textPoints.length, 0);\n+  const wcOffset = Math.max(wcwidth(text) - textPoints.length, 0);\n   const slicedText = textPoints.slice(0, width - 1 - wcOffset);\n   return slicedText.length == textPoints.length ? text.padEnd(width) : (slicedText.join(\"\") + \"…\").padEnd(width);\n };"},{"message":"Fix the truncateMultilineText function in src/ui/utils.ts to handle the case where the last line might be empty when truncation occurs. Currently, [...truncatedLines[maxHeight - 1]] could cause an error if truncatedLines[maxHeight - 1] is undefined or empty. Add a check to ensure the line exists and is not empty before attempting to spread it.","diff":"diff --git a/src/ui/utils.ts b/src/ui/utils.ts\nindex 4fc0ac7..296471e 100644\n--- a/src/ui/utils.ts\n+++ b/src/ui/utils.ts\n@@ -30,7 +30,7 @@ export const truncateMultilineText = (description: string, width: number, maxHei\n   });\n   const lines = wrappedText.split(\"\\n\");\n   const truncatedLines = lines.slice(0, maxHeight);\n-  if (lines.length > maxHeight) {\n+  if (lines.length > maxHeight && truncatedLines[maxHeight - 1] && truncatedLines[maxHeight - 1].length > 0) {\n     truncatedLines[maxHeight - 1] = [...truncatedLines[maxHeight - 1]].slice(0, -1).join(\"\") + \"…\";\n   }\n   return truncatedLines.map((line) => line.padEnd(width));"},{"message":"Fix the renderBox function in src/ui/utils.ts to validate that width is a positive number greater than or equal to 2 before using it in \"─\".repeat(width - 2). If width is less than 2, it should use a default minimum width to prevent negative repeat counts.","diff":"diff --git a/src/ui/utils.ts b/src/ui/utils.ts\nindex 296471e..753b3ec 100644\n--- a/src/ui/utils.ts\n+++ b/src/ui/utils.ts\n@@ -15,11 +15,13 @@ import wcwidth from \"wcwidth\";\n export const renderBox = (rows: string[], width: number, x: number, borderColor?: string) => {\n   const result = [];\n   const setColor = (text: string) => (borderColor ? chalk.hex(borderColor).apply(text) : text);\n-  result.push(ansi.cursorTo(x) + setColor(\"┌\" + \"─\".repeat(width - 2) + \"┐\") + ansi.cursorTo(x));\n+  // Ensure width is at least 2 to prevent negative repeat counts\n+  const safeWidth = Math.max(2, width);\n+  result.push(ansi.cursorTo(x) + setColor(\"┌\" + \"─\".repeat(safeWidth - 2) + \"┐\") + ansi.cursorTo(x));\n   rows.forEach((row) => {\n     result.push(ansi.cursorDown() + setColor(\"│\") + row + setColor(\"│\") + ansi.cursorTo(x));\n   });\n-  result.push(ansi.cursorDown() + setColor(\"└\" + \"─\".repeat(width - 2) + \"┘\") + ansi.cursorTo(x));\n+  result.push(ansi.cursorDown() + setColor(\"└\" + \"─\".repeat(safeWidth - 2) + \"┘\") + ansi.cursorTo(x));\n   return result.join(\"\") + ansi.cursorUp(rows.length + 1);\n };\n "},{"message":"Fix the truncateText function in src/ui/utils.ts to handle the case where width is 0 or negative. Currently, this could cause unexpected behavior in the slice operation. Add validation to ensure width is a positive number before using it in calculations.","diff":"diff --git a/src/ui/utils.ts b/src/ui/utils.ts\nindex 753b3ec..6771c40 100644\n--- a/src/ui/utils.ts\n+++ b/src/ui/utils.ts\n@@ -42,6 +42,11 @@ export const truncateMultilineText = (description: string, width: number, maxHei\n  * Truncates the text to the given width\n  */\n export const truncateText = (text: string, width: number) => {\n+  // Handle cases where width is 0 or negative\n+  if (width <= 0) {\n+    return \"\";\n+  }\n+  \n   const textPoints = [...text];\n   const wcOffset = Math.max(wcwidth(text) - textPoints.length, 0);\n   const slicedText = textPoints.slice(0, width - 1 - wcOffset);"},{"message":"Fix the truncateMultilineText function in src/ui/utils.ts to handle cases where width is 0 or negative, similar to the fix we made for truncateText. Add validation to ensure width is a positive number before using it in calculations.","diff":"diff --git a/src/ui/utils.ts b/src/ui/utils.ts\nindex 6771c40..0ae26a0 100644\n--- a/src/ui/utils.ts\n+++ b/src/ui/utils.ts\n@@ -26,6 +26,11 @@ export const renderBox = (rows: string[], width: number, x: number, borderColor?\n };\n \n export const truncateMultilineText = (description: string, width: number, maxHeight: number) => {\n+  // Handle cases where width is 0 or negative\n+  if (width <= 0) {\n+    return [];\n+  }\n+  \n   const wrappedText = wrapAnsi(description, width, {\n     trim: false,\n     hard: true,"},{"message":"Fix the renderBox function in src/ui/utils.ts to handle the case where a row is longer than width-2 characters. Currently, this could break the box rendering. Add validation to truncate rows that are too long before rendering them.","diff":"diff --git a/src/ui/utils.ts b/src/ui/utils.ts\nindex 0ae26a0..eaa650d 100644\n--- a/src/ui/utils.ts\n+++ b/src/ui/utils.ts\n@@ -19,7 +19,10 @@ export const renderBox = (rows: string[], width: number, x: number, borderColor?\n   const safeWidth = Math.max(2, width);\n   result.push(ansi.cursorTo(x) + setColor(\"┌\" + \"─\".repeat(safeWidth - 2) + \"┐\") + ansi.cursorTo(x));\n   rows.forEach((row) => {\n-    result.push(ansi.cursorDown() + setColor(\"│\") + row + setColor(\"│\") + ansi.cursorTo(x));\n+    // Truncate row if it's longer than width-2 to ensure it fits in the box\n+    const maxRowWidth = safeWidth - 2;\n+    const truncatedRow = row.length > maxRowWidth ? truncateText(row, maxRowWidth) : row;\n+    result.push(ansi.cursorDown() + setColor(\"│\") + truncatedRow + setColor(\"│\") + ansi.cursorTo(x));\n   });\n   result.push(ansi.cursorDown() + setColor(\"└\" + \"─\".repeat(safeWidth - 2) + \"┘\") + ansi.cursorTo(x));\n   return result.join(\"\") + ansi.cursorUp(rows.length + 1);"},{"message":"Fix the SuggestionManager's _loadSuggestions method in src/ui/suggestionManager.ts to add error handling for the getSuggestions call. Currently, if this call fails, the error would be unhandled. Add a try-catch block to properly handle any errors that might occur during the getSuggestions call.","diff":"diff --git a/src/ui/suggestionManager.ts b/src/ui/suggestionManager.ts\nindex 918f5d2..3500abb 100644\n--- a/src/ui/suggestionManager.ts\n+++ b/src/ui/suggestionManager.ts\n@@ -58,9 +58,15 @@ export class SuggestionManager {\n       return;\n     }\n     this.#command = commandText;\n-    const suggestionBlob = await getSuggestions(commandText, this.#term.cwd, this.#shell);\n-    this.#suggestBlob = suggestionBlob;\n-    this.#activeSuggestionIdx = 0;\n+    try {\n+      const suggestionBlob = await getSuggestions(commandText, this.#term.cwd, this.#shell);\n+      this.#suggestBlob = suggestionBlob;\n+      this.#activeSuggestionIdx = 0;\n+    } catch (error) {\n+      log.debug({ msg: \"Error loading suggestions\", error });\n+      this.#suggestBlob = { suggestions: [] };\n+      this.#activeSuggestionIdx = 0;\n+    }\n   }\n \n   private _renderArgumentDescription(description: string | undefined, x: number) {"},{"message":"Fix the SuggestionManager's rendering methods (_renderArgumentDescription, _renderDescription, _descriptionRows) in src/ui/suggestionManager.ts to add validation ensuring descriptionWidth - borderWidth is positive. Currently, if descriptionWidth is less than or equal to borderWidth, it could cause issues. Add a check to ensure the calculated width is at least 1.","diff":"diff --git a/src/ui/suggestionManager.ts b/src/ui/suggestionManager.ts\nindex 3500abb..77ee308 100644\n--- a/src/ui/suggestionManager.ts\n+++ b/src/ui/suggestionManager.ts\n@@ -71,17 +71,23 @@ export class SuggestionManager {\n \n   private _renderArgumentDescription(description: string | undefined, x: number) {\n     if (!description) return \"\";\n-    return renderBox([truncateText(description, descriptionWidth - borderWidth)], descriptionWidth, x);\n+    // Ensure width is at least 1\n+    const effectiveWidth = Math.max(1, descriptionWidth - borderWidth);\n+    return renderBox([truncateText(description, effectiveWidth)], descriptionWidth, x);\n   }\n \n   private _renderDescription(description: string | undefined, x: number) {\n     if (!description) return \"\";\n-    return renderBox(truncateMultilineText(description, descriptionWidth - borderWidth, descriptionHeight), descriptionWidth, x);\n+    // Ensure width is at least 1\n+    const effectiveWidth = Math.max(1, descriptionWidth - borderWidth);\n+    return renderBox(truncateMultilineText(description, effectiveWidth, descriptionHeight), descriptionWidth, x);\n   }\n \n   private _descriptionRows(description: string | undefined) {\n     if (!description) return 0;\n-    return truncateMultilineText(description, descriptionWidth - borderWidth, descriptionHeight).length;\n+    // Ensure width is at least 1\n+    const effectiveWidth = Math.max(1, descriptionWidth - borderWidth);\n+    return truncateMultilineText(description, effectiveWidth, descriptionHeight).length;\n   }\n \n   private _renderSuggestions(suggestions: Suggestion[], activeSuggestionIdx: number, x: number) {"},{"message":"Fix the SuggestionManager's update method in src/ui/suggestionManager.ts to improve the calculation on line 184: Math.min(this.#activeSuggestionIdx + 1, (this.#suggestBlob?.suggestions.length ?? 1) - 1). If this.#suggestBlob is undefined or suggestions is empty, this could cause unexpected behavior. Add better validation to handle these edge cases.","diff":"diff --git a/src/ui/suggestionManager.ts b/src/ui/suggestionManager.ts\nindex 77ee308..2de3ea7 100644\n--- a/src/ui/suggestionManager.ts\n+++ b/src/ui/suggestionManager.ts\n@@ -186,17 +186,37 @@ export class SuggestionManager {\n     if (name == dismissKey && shift == !!dismissShift && ctrl == !!dismissCtrl) {\n       this.#suggestBlob = undefined;\n     } else if (name == prevKey && shift == !!prevShift && ctrl == !!prevCtrl) {\n-      this.#activeSuggestionIdx = Math.max(0, this.#activeSuggestionIdx - 1);\n+      // Handle edge cases where suggestBlob is undefined or suggestions array is empty\n+      const suggestionsLength = this.#suggestBlob?.suggestions?.length || 0;\n+      // Only decrement if there are suggestions and we're not at the beginning\n+      if (suggestionsLength > 0) {\n+        this.#activeSuggestionIdx = Math.max(0, this.#activeSuggestionIdx - 1);\n+      }\n     } else if (name == nextKey && shift == !!nextShift && ctrl == !!nextCtrl) {\n-      this.#activeSuggestionIdx = Math.min(this.#activeSuggestionIdx + 1, (this.#suggestBlob?.suggestions.length ?? 1) - 1);\n+      // Handle edge cases where suggestBlob is undefined or suggestions array is empty\n+      const suggestionsLength = this.#suggestBlob?.suggestions?.length || 0;\n+      // Only increment if there are suggestions and we're not at the end\n+      if (suggestionsLength > 0) {\n+        this.#activeSuggestionIdx = Math.min(this.#activeSuggestionIdx + 1, suggestionsLength - 1);\n+      }\n     } else if (name == acceptKey && shift == !!acceptShift && ctrl == !!acceptCtrl) {\n-      const removals = \"\\u007F\".repeat(this.#suggestBlob?.charactersToDrop ?? 0);\n-      const suggestion = this.#suggestBlob?.suggestions.at(this.#activeSuggestionIdx);\n-      const chars = suggestion?.insertValue ?? (suggestion?.name ? suggestion?.name + \" \" : \"\");\n-      if (this.#suggestBlob == null || !chars.trim() || this.#suggestBlob?.suggestions.length == 0) {\n+      // Handle edge cases where suggestBlob is undefined or suggestions array is empty\n+      const suggestionsLength = this.#suggestBlob?.suggestions?.length || 0;\n+      \n+      // Only proceed if there are suggestions and the active index is valid\n+      if (suggestionsLength > 0 && this.#activeSuggestionIdx >= 0 && this.#activeSuggestionIdx < suggestionsLength) {\n+        const removals = \"\\u007F\".repeat(this.#suggestBlob?.charactersToDrop ?? 0);\n+        const suggestion = this.#suggestBlob?.suggestions.at(this.#activeSuggestionIdx);\n+        const chars = suggestion?.insertValue ?? (suggestion?.name ? suggestion?.name + \" \" : \"\");\n+        \n+        if (!chars.trim()) {\n+          return false;\n+        }\n+        \n+        this.#term.write(removals + chars);\n+      } else {\n         return false;\n       }\n-      this.#term.write(removals + chars);\n     } else {\n       return false;\n     }"},{"message":"Fix the SuggestionManager's render method in src/ui/suggestionManager.ts to handle the case where the terminal is very narrow. Currently, the calculation of maxPadding on line 122 assumes that suggestionWidth and descriptionWidth are less than this.#term.cols. Add validation to ensure maxPadding is never negative and that UI elements are properly sized for narrow terminals.","diff":"diff --git a/src/ui/suggestionManager.ts b/src/ui/suggestionManager.ts\nindex 2de3ea7..e482eb5 100644\n--- a/src/ui/suggestionManager.ts\n+++ b/src/ui/suggestionManager.ts\n@@ -71,33 +71,53 @@ export class SuggestionManager {\n \n   private _renderArgumentDescription(description: string | undefined, x: number) {\n     if (!description) return \"\";\n+    \n+    // Adjust description width for narrow terminals\n+    const availableWidth = this.#term.cols;\n+    const adjustedDescriptionWidth = Math.min(descriptionWidth, Math.max(10, availableWidth - x - 2));\n+    \n     // Ensure width is at least 1\n-    const effectiveWidth = Math.max(1, descriptionWidth - borderWidth);\n-    return renderBox([truncateText(description, effectiveWidth)], descriptionWidth, x);\n+    const effectiveWidth = Math.max(1, adjustedDescriptionWidth - borderWidth);\n+    return renderBox([truncateText(description, effectiveWidth)], adjustedDescriptionWidth, x);\n   }\n \n   private _renderDescription(description: string | undefined, x: number) {\n     if (!description) return \"\";\n+    \n+    // Adjust description width for narrow terminals\n+    const availableWidth = this.#term.cols;\n+    const adjustedDescriptionWidth = Math.min(descriptionWidth, Math.max(10, availableWidth - x - 2));\n+    \n     // Ensure width is at least 1\n-    const effectiveWidth = Math.max(1, descriptionWidth - borderWidth);\n-    return renderBox(truncateMultilineText(description, effectiveWidth, descriptionHeight), descriptionWidth, x);\n+    const effectiveWidth = Math.max(1, adjustedDescriptionWidth - borderWidth);\n+    return renderBox(truncateMultilineText(description, effectiveWidth, descriptionHeight), adjustedDescriptionWidth, x);\n   }\n \n   private _descriptionRows(description: string | undefined) {\n     if (!description) return 0;\n+    \n+    // Adjust description width for narrow terminals\n+    const availableWidth = this.#term.cols;\n+    // Use a conservative estimate for x position when calculating rows\n+    const adjustedDescriptionWidth = Math.min(descriptionWidth, Math.max(10, availableWidth - 5));\n+    \n     // Ensure width is at least 1\n-    const effectiveWidth = Math.max(1, descriptionWidth - borderWidth);\n+    const effectiveWidth = Math.max(1, adjustedDescriptionWidth - borderWidth);\n     return truncateMultilineText(description, effectiveWidth, descriptionHeight).length;\n   }\n \n   private _renderSuggestions(suggestions: Suggestion[], activeSuggestionIdx: number, x: number) {\n+    // Adjust suggestion width for narrow terminals\n+    const availableWidth = this.#term.cols;\n+    const adjustedSuggestionWidth = Math.min(suggestionWidth, Math.max(10, availableWidth - x - 2));\n+    \n     return renderBox(\n       suggestions.map((suggestion, idx) => {\n         const suggestionText = `${suggestion.icon} ${suggestion.name}`;\n-        const truncatedSuggestion = truncateText(suggestionText, suggestionWidth - 2);\n+        const truncatedSuggestion = truncateText(suggestionText, Math.max(1, adjustedSuggestionWidth - 2));\n         return idx == activeSuggestionIdx ? chalk.bgHex(activeSuggestionBackgroundColor)(truncatedSuggestion) : truncatedSuggestion;\n       }),\n-      suggestionWidth,\n+      adjustedSuggestionWidth,\n       x,\n     );\n   }\n@@ -120,9 +140,16 @@ export class SuggestionManager {\n     const activeDescription = pagedSuggestions.at(activePagedSuggestionIndex)?.description || argumentDescription || \"\";\n \n     const wrappedPadding = this.#term.getCursorState().cursorX % this.#term.cols;\n-    const maxPadding = activeDescription.length !== 0 ? this.#term.cols - suggestionWidth - descriptionWidth : this.#term.cols - suggestionWidth;\n-    const swapDescription = wrappedPadding > maxPadding && activeDescription.length !== 0;\n+    // Ensure maxPadding is never negative by using Math.max\n+    const maxPadding = Math.max(0, activeDescription.length !== 0 \n+      ? this.#term.cols - suggestionWidth - descriptionWidth \n+      : this.#term.cols - suggestionWidth);\n+    // For very narrow terminals, force swapping the description to improve layout\n+    const isNarrowTerminal = this.#term.cols < (suggestionWidth + descriptionWidth);\n+    const swapDescription = (wrappedPadding > maxPadding && activeDescription.length !== 0) || \n+                           (isNarrowTerminal && activeDescription.length !== 0);\n     const swappedPadding = swapDescription ? Math.max(wrappedPadding - descriptionWidth, 0) : wrappedPadding;\n+    // Ensure padding is never negative and doesn't exceed available space\n     const clampedLeftPadding = Math.min(Math.min(wrappedPadding, swappedPadding), maxPadding);\n \n     if (suggestions.length <= this.#activeSuggestionIdx) {"},{"message":"Fix the render function in src/ui/ui-root.ts to add error handling for async operations. Currently, there's no error handling for async operations like term.getCursorState() or suggestionManager.render(), which could lead to unhandled promise rejections. Add try-catch blocks around these async operations to properly handle errors.","diff":"diff --git a/src/ui/ui-root.ts b/src/ui/ui-root.ts\nindex 77e913c..0d0e9c4 100644\n--- a/src/ui/ui-root.ts\n+++ b/src/ui/ui-root.ts\n@@ -36,92 +36,125 @@ export const render = async (shell: Shell, underTest: boolean, parentTermExit: b\n       // Considers when data includes newlines which have shifted the cursor position downwards\n       const newlines = Math.max((data.match(/\\r/g) || []).length, (data.match(/\\n/g) || []).length);\n       const linesOfInterest = MAX_LINES + newlines;\n-      if (term.getCursorState().remainingLines <= MAX_LINES) {\n-        // handles when suggestions get loaded before shell output so you need to always clear below output as a precaution\n-        if (term.getCursorState().remainingLines != 0) {\n-          writeOutput(ansi.cursorHide + ansi.cursorSavePosition + eraseLinesBelow(linesOfInterest + 1) + ansi.cursorRestorePosition);\n+      try {\n+        const cursorState = term.getCursorState();\n+        if (cursorState.remainingLines <= MAX_LINES) {\n+          // handles when suggestions get loaded before shell output so you need to always clear below output as a precaution\n+          if (cursorState.remainingLines != 0) {\n+            writeOutput(ansi.cursorHide + ansi.cursorSavePosition + eraseLinesBelow(linesOfInterest + 1) + ansi.cursorRestorePosition);\n+          }\n+          writeOutput(\n+            data +\n+              ansi.cursorHide +\n+              ansi.cursorSavePosition +\n+              ansi.cursorPrevLine.repeat(linesOfInterest) +\n+              term.getCells(linesOfInterest, \"above\") +\n+              ansi.cursorRestorePosition +\n+              ansi.cursorShow,\n+          );\n+        } else {\n+          writeOutput(ansi.cursorHide + ansi.cursorSavePosition + eraseLinesBelow(linesOfInterest + 1) + ansi.cursorRestorePosition + ansi.cursorShow + data);\n         }\n-        writeOutput(\n-          data +\n-            ansi.cursorHide +\n-            ansi.cursorSavePosition +\n-            ansi.cursorPrevLine.repeat(linesOfInterest) +\n-            term.getCells(linesOfInterest, \"above\") +\n-            ansi.cursorRestorePosition +\n-            ansi.cursorShow,\n-        );\n-      } else {\n-        writeOutput(ansi.cursorHide + ansi.cursorSavePosition + eraseLinesBelow(linesOfInterest + 1) + ansi.cursorRestorePosition + ansi.cursorShow + data);\n+      } catch (error) {\n+        log.debug({ msg: \"Error getting cursor state\", error });\n+        writeOutput(data); // Fallback to just writing the data if there's an error\n       }\n     } else {\n       writeOutput(data);\n     }\n \n-    process.nextTick(async () => {\n-      // validate result to prevent stale suggestion being provided\n-      const suggestion = suggestionManager.validate(await suggestionManager.render(term.getCursorState().remainingLines));\n-      const commandState = term.getCommandState();\n+      process.nextTick(async () => {\n+        try {\n+          // validate result to prevent stale suggestion being provided\n+          const cursorState = await term.getCursorState();\n+          const suggestion = suggestionManager.validate(await suggestionManager.render(cursorState.remainingLines));\n+          const commandState = term.getCommandState();\n \n       if (suggestion.data != \"\" && commandState.cursorTerminated && !commandState.hasOutput) {\n         if (hasActiveSuggestions) {\n-          if (term.getCursorState().remainingLines < MAX_LINES) {\n-            writeOutput(\n-              ansi.cursorHide +\n-                ansi.cursorSavePosition +\n-                ansi.cursorPrevLine.repeat(MAX_LINES) +\n-                term.getCells(MAX_LINES, \"above\") +\n-                ansi.cursorRestorePosition +\n-                ansi.cursorSavePosition +\n-                ansi.cursorUp() +\n-                suggestion.data +\n-                ansi.cursorRestorePosition +\n-                ansi.cursorShow,\n-            );\n-          } else {\n-            const offset = MAX_LINES - suggestion.rows;\n-            writeOutput(\n-              ansi.cursorHide +\n-                ansi.cursorSavePosition +\n-                eraseLinesBelow(MAX_LINES) +\n-                (offset > 0 ? ansi.cursorUp(offset) : \"\") +\n-                suggestion.data +\n-                ansi.cursorRestorePosition +\n-                ansi.cursorShow,\n-            );\n+          try {\n+            const innerCursorState = await term.getCursorState();\n+            if (innerCursorState.remainingLines < MAX_LINES) {\n+              writeOutput(\n+                ansi.cursorHide +\n+                  ansi.cursorSavePosition +\n+                  ansi.cursorPrevLine.repeat(MAX_LINES) +\n+                  term.getCells(MAX_LINES, \"above\") +\n+                  ansi.cursorRestorePosition +\n+                  ansi.cursorSavePosition +\n+                  ansi.cursorUp() +\n+                  suggestion.data +\n+                  ansi.cursorRestorePosition +\n+                  ansi.cursorShow,\n+              );\n+            } else {\n+              const offset = MAX_LINES - suggestion.rows;\n+              writeOutput(\n+                ansi.cursorHide +\n+                  ansi.cursorSavePosition +\n+                  eraseLinesBelow(MAX_LINES) +\n+                  (offset > 0 ? ansi.cursorUp(offset) : \"\") +\n+                  suggestion.data +\n+                  ansi.cursorRestorePosition +\n+                  ansi.cursorShow,\n+              );\n+            }\n+          } catch (error) {\n+            log.debug({ msg: \"Error getting cursor state in active suggestions\", error });\n+            // Fallback to a simple output\n+            writeOutput(suggestion.data);\n           }\n         } else {\n-          if (term.getCursorState().remainingLines < MAX_LINES) {\n-            writeOutput(ansi.cursorHide + ansi.cursorSavePosition + ansi.cursorUp() + suggestion.data + ansi.cursorRestorePosition + ansi.cursorShow);\n-          } else {\n-            writeOutput(\n-              ansi.cursorHide +\n-                ansi.cursorSavePosition +\n-                ansi.cursorNextLine.repeat(suggestion.rows) +\n-                suggestion.data +\n-                ansi.cursorRestorePosition +\n-                ansi.cursorShow,\n-            );\n+          try {\n+            const innerCursorState = await term.getCursorState();\n+            if (innerCursorState.remainingLines < MAX_LINES) {\n+              writeOutput(ansi.cursorHide + ansi.cursorSavePosition + ansi.cursorUp() + suggestion.data + ansi.cursorRestorePosition + ansi.cursorShow);\n+            } else {\n+              writeOutput(\n+                ansi.cursorHide +\n+                  ansi.cursorSavePosition +\n+                  ansi.cursorNextLine.repeat(suggestion.rows) +\n+                  suggestion.data +\n+                  ansi.cursorRestorePosition +\n+                  ansi.cursorShow,\n+              );\n+            }\n+          } catch (error) {\n+            log.debug({ msg: \"Error getting cursor state in inactive suggestions\", error });\n+            // Fallback to a simple output\n+            writeOutput(suggestion.data);\n           }\n         }\n         hasActiveSuggestions = true;\n       } else {\n         if (hasActiveSuggestions) {\n-          if (term.getCursorState().remainingLines <= MAX_LINES) {\n-            writeOutput(\n-              ansi.cursorHide +\n-                ansi.cursorSavePosition +\n-                ansi.cursorPrevLine.repeat(MAX_LINES) +\n-                term.getCells(MAX_LINES, \"above\") +\n-                ansi.cursorRestorePosition +\n-                ansi.cursorShow,\n-            );\n-          } else {\n-            writeOutput(ansi.cursorHide + ansi.cursorSavePosition + eraseLinesBelow(MAX_LINES) + ansi.cursorRestorePosition + ansi.cursorShow);\n+          try {\n+            const innerCursorState = await term.getCursorState();\n+            if (innerCursorState.remainingLines <= MAX_LINES) {\n+              writeOutput(\n+                ansi.cursorHide +\n+                  ansi.cursorSavePosition +\n+                  ansi.cursorPrevLine.repeat(MAX_LINES) +\n+                  term.getCells(MAX_LINES, \"above\") +\n+                  ansi.cursorRestorePosition +\n+                  ansi.cursorShow,\n+              );\n+            } else {\n+              writeOutput(ansi.cursorHide + ansi.cursorSavePosition + eraseLinesBelow(MAX_LINES) + ansi.cursorRestorePosition + ansi.cursorShow);\n+            }\n+          } catch (error) {\n+            log.debug({ msg: \"Error getting cursor state in cleanup\", error });\n+            // Fallback to a simple cleanup\n+            writeOutput(ansi.cursorHide + ansi.cursorSavePosition + ansi.cursorShow);\n           }\n         }\n         hasActiveSuggestions = false;\n       }\n       previousSuggestionsRows = suggestion.rows;\n+      } catch (error) {\n+        log.debug({ msg: \"Error in suggestion rendering\", error });\n+        hasActiveSuggestions = false;\n+      }\n     });\n   });\n "},{"message":"Fix the render function in src/ui/ui-root.ts to add a check for non-TTY environments before using TTY-specific features like keypress events. Currently, it only checks if process.stdin.isTTY before setting raw mode (line 23), but there's no corresponding check before using other TTY-specific features. Add appropriate checks to prevent errors in non-TTY environments.","diff":"diff --git a/src/ui/ui-root.ts b/src/ui/ui-root.ts\nindex 0d0e9c4..4b2fc2a 100644\n--- a/src/ui/ui-root.ts\n+++ b/src/ui/ui-root.ts\n@@ -21,8 +21,11 @@ export const render = async (shell: Shell, underTest: boolean, parentTermExit: b\n   const suggestionManager = new SuggestionManager(term, shell);\n   let hasActiveSuggestions = false;\n   let previousSuggestionsRows = 0;\n-  if (process.stdin.isTTY) process.stdin.setRawMode(true);\n-  readline.emitKeypressEvents(process.stdin);\n+  // Only set up TTY-specific features if we're in a TTY environment\n+  if (process.stdin.isTTY) {\n+    process.stdin.setRawMode(true);\n+    readline.emitKeypressEvents(process.stdin);\n+  }\n \n   const writeOutput = (data: string) => {\n     log.debug({ msg: \"writing data\", data });\n@@ -158,19 +161,22 @@ export const render = async (shell: Shell, underTest: boolean, parentTermExit: b\n     });\n   });\n \n-  process.stdin.on(\"keypress\", (...keyPress: KeyPressEvent) => {\n-    const press = keyPress[1];\n-    const inputHandled = suggestionManager.update(press);\n-    if (previousSuggestionsRows > 0 && inputHandled) {\n-      term.noop();\n-    } else if (!inputHandled) {\n-      if (press.name == \"backspace\" && (shell === Shell.Pwsh || shell === Shell.Powershell || shell === Shell.Cmd)) {\n-        term.write(\"\\u007F\");\n-      } else {\n-        term.write(press.sequence);\n+  // Only set up keypress event listener in TTY environments\n+  if (process.stdin.isTTY) {\n+    process.stdin.on(\"keypress\", (...keyPress: KeyPressEvent) => {\n+      const press = keyPress[1];\n+      const inputHandled = suggestionManager.update(press);\n+      if (previousSuggestionsRows > 0 && inputHandled) {\n+        term.noop();\n+      } else if (!inputHandled) {\n+        if (press.name == \"backspace\" && (shell === Shell.Pwsh || shell === Shell.Powershell || shell === Shell.Cmd)) {\n+          term.write(\"\\u007F\");\n+        } else {\n+          term.write(press.sequence);\n+        }\n       }\n-    }\n-  });\n+    });\n+  }\n \n   term.onExit(({ exitCode }) => {\n     if (parentTermExit && process.ppid) {\n@@ -178,7 +184,10 @@ export const render = async (shell: Shell, underTest: boolean, parentTermExit: b\n     }\n     process.exit(exitCode);\n   });\n-  process.stdout.on(\"resize\", () => {\n-    term.resize(process.stdout.columns, process.stdout.rows);\n-  });\n+  // Only set up resize event listener in TTY environments\n+  if (process.stdout.isTTY) {\n+    process.stdout.on(\"resize\", () => {\n+      term.resize(process.stdout.columns, process.stdout.rows);\n+    });\n+  }\n };"},{"message":"Refactor the render function in src/ui/ui-root.ts to reduce code duplication between similar blocks (e.g., lines 65-90 and 91-104). Extract common functionality into helper functions to improve maintainability and reduce the risk of inconsistencies when one block is updated but not the others.","diff":""}]}]}