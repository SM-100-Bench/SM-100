{"scanned_subsystems":[{"name":"Query","files":["lib/cursor/aggregationCursor.js","lib/cursor/changeStream.js","lib/cursor/queryCursor.js","lib/helpers/query/applyGlobalOption.js","lib/helpers/query/cast$expr.js","lib/helpers/query/castFilterPath.js","lib/helpers/query/castUpdate.js","lib/helpers/query/getEmbeddedDiscriminatorPath.js","lib/helpers/query/handleImmutable.js","lib/helpers/query/handleReadPreferenceAliases.js","lib/helpers/query/hasDollarKeys.js","lib/helpers/query/isOperator.js","lib/helpers/query/sanitizeFilter.js","lib/helpers/query/sanitizeProjection.js","lib/helpers/query/selectPopulatedFields.js","lib/helpers/query/trusted.js","lib/helpers/query/validOps.js","lib/query.js","lib/queryHelpers.js"]},{"name":"TypeDefinitions","files":["types/aggregate.d.ts","types/augmentations.d.ts","types/callback.d.ts","types/collection.d.ts","types/connection.d.ts","types/cursor.d.ts","types/document.d.ts","types/error.d.ts","types/expressions.d.ts","types/helpers.d.ts","types/index.d.ts","types/indexes.d.ts","types/inferrawdoctype.d.ts","types/inferschematype.d.ts","types/middlewares.d.ts","types/models.d.ts","types/mongooseoptions.d.ts","types/pipelinestage.d.ts","types/populate.d.ts","types/query.d.ts","types/schemaoptions.d.ts","types/schematypes.d.ts","types/session.d.ts","types/types.d.ts","types/utility.d.ts","types/validation.d.ts","types/virtuals.d.ts"]}],"changesets":[{"title":"Bismuth: fix 12 bugs in Query","body":"Fixes:\n- Fix the critical security vulnerability in sanitizeFilter.js where it only checks for MongoDB operators at the top level of each value but doesn't recursively check nested objects. This allows attackers to bypass sanitization with queries like { field: { nested: { $ne: null } } }. The fix should recursively check all nested objects for MongoDB operators and sanitize them appropriately.\n- Fix the security vulnerability in sanitizeProjection.js where it only converts string values to 1 but doesn't handle nested objects or arrays that might contain MongoDB operators. This simplistic approach could allow projection injection attacks with complex projections. The fix should recursively check all nested objects and arrays for potential MongoDB operators and sanitize them appropriately.\n- Fix the security vulnerability in QueryCursor.prototype.map (line 194 of queryCursor.js) where the function parameter is directly added to _transforms without any validation. If an attacker can control this parameter, they could inject malicious code that would be executed for each document processed by the cursor. The fix should validate that the parameter is a legitimate function before adding it to _transforms.\n- Fix the security vulnerability in selectPopulatedFields.js where there's no validation of the path names in populateOptions (line 14). If an attacker can control these paths, they could potentially use special property names like '__proto__' or 'constructor' to cause prototype pollution. The fix should validate path names to ensure they don't contain dangerous property names before using them.\n- Fix the critical security vulnerability in sanitizeFilter.js where the function only checks for dollar keys at the top level of each value using hasDollarKeys(). This means nested objects with MongoDB operators like { field: { nested: { $ne: null } } } would bypass sanitization. The fix should recursively check all nested objects for MongoDB operators and sanitize them appropriately to prevent NoSQL injection attacks.\n- Fix the security vulnerability in sanitizeProjection.js where the function only converts string values to 1 but doesn't handle nested objects or arrays that might contain MongoDB operators. Enhance the function to recursively check all nested objects and arrays for potential MongoDB operators and sanitize them appropriately to prevent projection injection attacks.\n- Fix the security vulnerability in QueryCursor.prototype.map and other transform-related functions where function parameters are directly added to _transforms without validation. Implement a validation mechanism to prevent arbitrary code execution if an attacker can control these transform functions. This should include validation in QueryCursor.prototype.map, AggregationCursor.prototype.map, and any other places where transform functions are applied to documents.\n- Fix the security vulnerability in sanitizeFilter.js where there's no depth limit on recursive calls for arrays and $and/$or operators. Implement a maximum depth limit to prevent denial of service attacks from deeply nested filters. The fix should include a configurable depth limit with a reasonable default value, and proper error handling when the limit is exceeded.\n- Analyze the Mongoose query and cursor management subsystem for security vulnerabilities and provide a comprehensive security assessment report. Focus on the critical vulnerabilities already identified:\n\n1. The sanitizeFilter.js function only checks for MongoDB operators at the top level of each value, allowing nested objects with MongoDB operators to bypass sanitization completely, enabling NoSQL injection attacks.\n\n2. In QueryCursor.prototype.map and other transform-related functions, function parameters are directly added to _transforms without validation, allowing arbitrary code execution if an attacker can control these transform functions.\n\n3. There is no depth limit on recursive calls in sanitizeFilter.js for arrays and $and/$or operators, which could allow an attacker to cause a denial of service by crafting a deeply nested filter.\n\n4. The sanitizeProjection.js function only converts string values to 1 but doesn't handle nested objects or arrays that might contain MongoDB operators, which could allow projection injection attacks.\n\nFor each vulnerability, provide:\n- A detailed explanation of the vulnerability\n- The potential impact and attack vectors\n- The code changes needed to fix the vulnerability\n- Recommendations for additional security improvements\n- Fix the security vulnerability in QueryCursor.prototype.map where the function parameter is directly added to _transforms without validation (line 194). This could allow an attacker to inject malicious code that would be executed for each document processed by the cursor. Implement proper validation and sanitization of transform functions to prevent arbitrary code execution.\n- Fix the security vulnerability in sanitizeFilter.js where there's no depth limit on recursive calls for arrays and $and/$or operators. This could allow an attacker to cause a denial of service by crafting a deeply nested filter with many nested $and/$or operators. Implement a maximum depth limit for recursive calls to prevent this attack vector.\n- Fix the security vulnerability in QueryCursor.prototype.map where the function parameter is directly added to _transforms without validation (line 194). This could allow an attacker to inject malicious code that would be executed for each document processed by the cursor. Implement a validation mechanism that ensures only safe transform functions can be added to the _transforms array.","commits":[{"message":"Fix the critical security vulnerability in sanitizeFilter.js where it only checks for MongoDB operators at the top level of each value but doesn't recursively check nested objects. This allows attackers to bypass sanitization with queries like { field: { nested: { $ne: null } } }. The fix should recursively check all nested objects for MongoDB operators and sanitize them appropriately.","diff":"diff --git a/lib/helpers/query/sanitizeFilter.js b/lib/helpers/query/sanitizeFilter.js\nindex 1147df3..1c83900 100644\n--- a/lib/helpers/query/sanitizeFilter.js\n+++ b/lib/helpers/query/sanitizeFilter.js\n@@ -31,6 +31,15 @@ module.exports = function sanitizeFilter(filter) {\n         continue;\n       }\n       filter[key] = { $eq: filter[key] };\n+    } else if (value != null && typeof value === 'object' && !Array.isArray(value)) {\n+      // Recursively check nested objects for MongoDB operators\n+      sanitizeFilter(value);\n+      \n+      // After recursively sanitizing, check if the nested object now has MongoDB operators\n+      // This handles cases like { field: { nested: { $ne: null } } }\n+      if (hasDollarKeys(value)) {\n+        filter[key] = { $eq: value };\n+      }\n     }\n   }\n \ndiff --git a/test-sanitize-filter.js b/test-sanitize-filter.js\nnew file mode 100644\nindex 0000000..64605cb\n--- /dev/null\n+++ b/test-sanitize-filter.js\n@@ -0,0 +1,54 @@\n+'use strict';\n+\n+const assert = require('assert');\n+const sanitizeFilter = require('./lib/helpers/query/sanitizeFilter');\n+const { trusted } = require('./lib/helpers/query/trusted');\n+\n+console.log('Testing sanitizeFilter function...');\n+\n+// Test 1: Basic object without operators\n+let obj1 = { username: 'val', pwd: 'my secret' };\n+sanitizeFilter(obj1);\n+assert.deepEqual(obj1, { username: 'val', pwd: 'my secret' });\n+console.log('Test 1 passed: Basic object without operators');\n+\n+// Test 2: Object with top-level operator\n+let obj2 = { username: 'val', pwd: { $ne: null } };\n+sanitizeFilter(obj2);\n+assert.deepEqual(obj2, { username: 'val', pwd: { $eq: { $ne: null } } });\n+console.log('Test 2 passed: Object with top-level operator');\n+\n+// Test 3: Object with nested operator (the vulnerability we're fixing)\n+let obj3 = { username: 'val', pwd: { nested: { $ne: null } } };\n+sanitizeFilter(obj3);\n+// After our fix, this should be sanitized to:\n+// { username: 'val', pwd: { $eq: { nested: { $eq: { $ne: null } } } } }\n+// or at minimum: { username: 'val', pwd: { nested: { $eq: { $ne: null } } } }\n+console.log('Original:', JSON.stringify(obj3));\n+// Check that the nested $ne operator has been sanitized\n+assert.ok(!obj3.pwd.nested.$ne, 'Nested $ne operator should be sanitized');\n+console.log('Test 3 passed: Object with nested operator');\n+\n+// Test 4: Object with deeply nested operator\n+let obj4 = { username: 'val', pwd: { level1: { level2: { level3: { $ne: null } } } } };\n+sanitizeFilter(obj4);\n+console.log('Original:', JSON.stringify(obj4));\n+// Check that the deeply nested $ne operator has been sanitized\n+assert.ok(!obj4.pwd.level1.level2.level3.$ne, 'Deeply nested $ne operator should be sanitized');\n+console.log('Test 4 passed: Object with deeply nested operator');\n+\n+// Test 5: Object with trusted operator\n+let obj5 = { username: 'val', pwd: trusted({ $type: 'string', $eq: 'my secret' }) };\n+sanitizeFilter(obj5);\n+assert.deepEqual(obj5, { username: 'val', pwd: { $type: 'string', $eq: 'my secret' } });\n+console.log('Test 5 passed: Object with trusted operator');\n+\n+// Test 6: Object with $and/$or operators\n+let obj6 = { $and: [{ username: 'val' }, { pwd: { nested: { $ne: 'my secret' } } }] };\n+sanitizeFilter(obj6);\n+console.log('Original:', JSON.stringify(obj6));\n+// Check that the nested $ne operator within $and has been sanitized\n+assert.ok(!obj6.$and[1].pwd.nested.$ne, 'Nested $ne operator within $and should be sanitized');\n+console.log('Test 6 passed: Object with $and operator and nested operator');\n+\n+console.log('All tests passed! The sanitizeFilter function now properly handles nested operators.');\n\\ No newline at end of file"},{"message":"Fix the security vulnerability in sanitizeProjection.js where it only converts string values to 1 but doesn't handle nested objects or arrays that might contain MongoDB operators. This simplistic approach could allow projection injection attacks with complex projections. The fix should recursively check all nested objects and arrays for potential MongoDB operators and sanitize them appropriately.","diff":"diff --git a/lib/helpers/query/sanitizeProjection.js b/lib/helpers/query/sanitizeProjection.js\nindex 0c03487..4df44f3 100644\n--- a/lib/helpers/query/sanitizeProjection.js\n+++ b/lib/helpers/query/sanitizeProjection.js\n@@ -1,14 +1,55 @@\n 'use strict';\n \n+const hasDollarKeys = require('./hasDollarKeys');\n+const { trustedSymbol } = require('./trusted');\n+\n module.exports = function sanitizeProjection(projection) {\n   if (projection == null) {\n     return;\n   }\n \n+  // Handle arrays (e.g., for $slice operator in arrays)\n+  if (Array.isArray(projection)) {\n+    for (let i = 0; i < projection.length; ++i) {\n+      if (typeof projection[i] === 'object' && projection[i] !== null) {\n+        sanitizeProjection(projection[i]);\n+      }\n+    }\n+    return;\n+  }\n+\n+  // Skip if not an object\n+  if (typeof projection !== 'object') {\n+    return;\n+  }\n+\n   const keys = Object.keys(projection);\n   for (let i = 0; i < keys.length; ++i) {\n-    if (typeof projection[keys[i]] === 'string') {\n-      projection[keys[i]] = 1;\n+    const key = keys[i];\n+    const value = projection[key];\n+\n+    // Skip trusted values\n+    if (value != null && value[trustedSymbol]) {\n+      continue;\n+    }\n+\n+    // Convert string values to 1 (original behavior)\n+    if (typeof value === 'string') {\n+      projection[key] = 1;\n+      continue;\n+    }\n+\n+    // Recursively sanitize nested objects\n+    if (value != null && typeof value === 'object') {\n+      // If the object has MongoDB operators (keys starting with $), \n+      // replace the entire value with 1 to prevent injection\n+      if (hasDollarKeys(value)) {\n+        projection[key] = 1;\n+      } else {\n+        // Otherwise recursively sanitize the nested object\n+        sanitizeProjection(value);\n+      }\n+      continue;\n     }\n   }\n };\ndiff --git a/test-sanitize-projection.js b/test-sanitize-projection.js\nnew file mode 100644\nindex 0000000..916d0ea\n--- /dev/null\n+++ b/test-sanitize-projection.js\n@@ -0,0 +1,79 @@\n+'use strict';\n+\n+const assert = require('assert');\n+const sanitizeProjection = require('./lib/helpers/query/sanitizeProjection');\n+const { trusted } = require('./lib/helpers/query/trusted');\n+\n+// Test basic string sanitization (original functionality)\n+console.log('Testing basic string sanitization...');\n+const basicProjection = { name: '$name', age: 1 };\n+sanitizeProjection(basicProjection);\n+assert.deepStrictEqual(basicProjection, { name: 1, age: 1 }, 'Failed to sanitize basic string value');\n+console.log('✓ Basic string sanitization works');\n+\n+// Test nested object with MongoDB operator\n+console.log('Testing nested object with MongoDB operator...');\n+const nestedProjection = { \n+  name: 1, \n+  profile: { \n+    $elemMatch: { active: true } \n+  } \n+};\n+sanitizeProjection(nestedProjection);\n+assert.deepStrictEqual(\n+  nestedProjection, \n+  { name: 1, profile: 1 }, \n+  'Failed to sanitize nested object with MongoDB operator'\n+);\n+console.log('✓ Nested object sanitization works');\n+\n+// Test array sanitization\n+console.log('Testing array sanitization...');\n+const arrayProjection = { \n+  comments: { \n+    $slice: [0, 5],\n+    $elemMatch: { author: 'John' } \n+  } \n+};\n+sanitizeProjection(arrayProjection);\n+assert.deepStrictEqual(\n+  arrayProjection, \n+  { comments: 1 }, \n+  'Failed to sanitize array projection with MongoDB operators'\n+);\n+console.log('✓ Array sanitization works');\n+\n+// Test deeply nested objects\n+console.log('Testing deeply nested objects...');\n+const deeplyNested = {\n+  user: {\n+    profile: {\n+      details: {\n+        $elemMatch: { verified: true }\n+      }\n+    }\n+  }\n+};\n+sanitizeProjection(deeplyNested);\n+assert.deepStrictEqual(\n+  deeplyNested, \n+  { user: { profile: { details: 1 } } }, \n+  'Failed to sanitize deeply nested objects'\n+);\n+console.log('✓ Deeply nested object sanitization works');\n+\n+// Test trusted values\n+console.log('Testing trusted values...');\n+const trustedProjection = {\n+  name: 1,\n+  profile: trusted({ $elemMatch: { active: true } })\n+};\n+sanitizeProjection(trustedProjection);\n+assert.deepStrictEqual(\n+  trustedProjection.profile.$elemMatch, \n+  { active: true }, \n+  'Failed to preserve trusted values'\n+);\n+console.log('✓ Trusted values preserved correctly');\n+\n+console.log('All tests passed!');\n\\ No newline at end of file"},{"message":"Fix the security vulnerability in QueryCursor.prototype.map (line 194 of queryCursor.js) where the function parameter is directly added to _transforms without any validation. If an attacker can control this parameter, they could inject malicious code that would be executed for each document processed by the cursor. The fix should validate that the parameter is a legitimate function before adding it to _transforms.","diff":"diff --git a/lib/cursor/queryCursor.js b/lib/cursor/queryCursor.js\nindex 895919a..e475360 100644\n--- a/lib/cursor/queryCursor.js\n+++ b/lib/cursor/queryCursor.js\n@@ -192,6 +192,9 @@ QueryCursor.prototype.getDriverCursor = async function getDriverCursor() {\n \n Object.defineProperty(QueryCursor.prototype, 'map', {\n   value: function(fn) {\n+    if (typeof fn !== 'function') {\n+      throw new MongooseError('Query.prototype.map() requires a function parameter');\n+    }\n     this._transforms.push(fn);\n     return this;\n   },\ndiff --git a/test-map-validation.js b/test-map-validation.js\nnew file mode 100644\nindex 0000000..4ff56e4\n--- /dev/null\n+++ b/test-map-validation.js\n@@ -0,0 +1,81 @@\n+'use strict';\n+\n+const assert = require('assert');\n+const QueryCursor = require('./lib/cursor/queryCursor');\n+const MongooseError = require('./lib/error/mongooseError');\n+\n+// Mock query object\n+const mockQuery = {\n+  model: {\n+    hooks: {\n+      execPre: (hookName, query, cb) => cb()\n+    },\n+    collection: {\n+      _shouldBufferCommands: () => false,\n+      find: () => ({})\n+    }\n+  },\n+  _optionsForExec: () => ({}),\n+  _transforms: []\n+};\n+\n+// Create a new QueryCursor instance\n+const cursor = new QueryCursor(mockQuery);\n+\n+console.log('Testing QueryCursor.prototype.map validation...');\n+\n+// Test 1: Valid function parameter should work\n+try {\n+  cursor.map(function(doc) { return doc; });\n+  console.log('✓ Valid function parameter accepted');\n+} catch (error) {\n+  console.error('✗ Valid function parameter failed:', error.message);\n+  process.exit(1);\n+}\n+\n+// Test 2: Non-function parameter should throw an error\n+try {\n+  cursor.map('not a function');\n+  console.error('✗ Non-function parameter was incorrectly accepted');\n+  process.exit(1);\n+} catch (error) {\n+  if (error instanceof MongooseError && \n+      error.message === 'Query.prototype.map() requires a function parameter') {\n+    console.log('✓ Non-function parameter correctly rejected');\n+  } else {\n+    console.error('✗ Unexpected error:', error.message);\n+    process.exit(1);\n+  }\n+}\n+\n+// Test 3: null parameter should throw an error\n+try {\n+  cursor.map(null);\n+  console.error('✗ null parameter was incorrectly accepted');\n+  process.exit(1);\n+} catch (error) {\n+  if (error instanceof MongooseError && \n+      error.message === 'Query.prototype.map() requires a function parameter') {\n+    console.log('✓ null parameter correctly rejected');\n+  } else {\n+    console.error('✗ Unexpected error:', error.message);\n+    process.exit(1);\n+  }\n+}\n+\n+// Test 4: object parameter should throw an error\n+try {\n+  cursor.map({});\n+  console.error('✗ object parameter was incorrectly accepted');\n+  process.exit(1);\n+} catch (error) {\n+  if (error instanceof MongooseError && \n+      error.message === 'Query.prototype.map() requires a function parameter') {\n+    console.log('✓ object parameter correctly rejected');\n+  } else {\n+    console.error('✗ Unexpected error:', error.message);\n+    process.exit(1);\n+  }\n+}\n+\n+console.log('All tests passed! The security vulnerability has been fixed.');\n\\ No newline at end of file"},{"message":"Fix the security vulnerability in selectPopulatedFields.js where there's no validation of the path names in populateOptions (line 14). If an attacker can control these paths, they could potentially use special property names like '__proto__' or 'constructor' to cause prototype pollution. The fix should validate path names to ensure they don't contain dangerous property names before using them.","diff":"diff --git a/lib/helpers/query/selectPopulatedFields.js b/lib/helpers/query/selectPopulatedFields.js\nindex dc96caf..60bec6c 100644\n--- a/lib/helpers/query/selectPopulatedFields.js\n+++ b/lib/helpers/query/selectPopulatedFields.js\n@@ -2,17 +2,36 @@\n \n const isExclusive = require('../projection/isExclusive');\n const isInclusive = require('../projection/isInclusive');\n+const specialProperties = require('../specialProperties');\n \n /*!\n  * ignore\n  */\n \n+/**\n+ * Check if a path contains any dangerous segments that could lead to prototype pollution\n+ * @param {String} path - The path to check\n+ * @return {Boolean} - True if the path is safe, false if it contains dangerous segments\n+ */\n+function isPathSafe(path) {\n+  if (typeof path !== 'string') return false;\n+  const segments = path.split('.');\n+  for (let i = 0; i < segments.length; i++) {\n+    if (specialProperties.has(segments[i])) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n module.exports = function selectPopulatedFields(fields, userProvidedFields, populateOptions) {\n   if (populateOptions == null) {\n     return;\n   }\n \n-  const paths = Object.keys(populateOptions);\n+  // Filter out dangerous property names to prevent prototype pollution\n+  const paths = Object.keys(populateOptions)\n+    .filter(path => !specialProperties.has(path) && isPathSafe(path));\n   userProvidedFields = userProvidedFields || {};\n   if (isInclusive(fields)) {\n     for (const path of paths) {\n@@ -23,7 +42,7 @@ module.exports = function selectPopulatedFields(fields, userProvidedFields, popu\n       }\n \n       const refPath = populateOptions[path]?.refPath;\n-      if (typeof refPath === 'string') {\n+      if (typeof refPath === 'string' && !specialProperties.has(refPath) && isPathSafe(refPath)) {\n         if (!isPathInFields(userProvidedFields, refPath)) {\n           fields[refPath] = 1;\n         } else if (userProvidedFields[refPath] === 0) {\n@@ -37,7 +56,7 @@ module.exports = function selectPopulatedFields(fields, userProvidedFields, popu\n         delete fields[path];\n       }\n       const refPath = populateOptions[path]?.refPath;\n-      if (typeof refPath === 'string' && userProvidedFields[refPath] == null) {\n+      if (typeof refPath === 'string' && !specialProperties.has(refPath) && isPathSafe(refPath) && userProvidedFields[refPath] == null) {\n         delete fields[refPath];\n       }\n     }\n@@ -51,6 +70,8 @@ module.exports = function selectPopulatedFields(fields, userProvidedFields, popu\n function isPathInFields(userProvidedFields, path) {\n   const pieces = path.split('.');\n   const len = pieces.length;\n+  \n+  // Path safety is already checked by isPathSafe function before this is called\n   let cur = pieces[0];\n   for (let i = 1; i < len; ++i) {\n     if (userProvidedFields[cur] != null || userProvidedFields[cur + '.$'] != null) {\ndiff --git a/test-selectPopulatedFields.js b/test-selectPopulatedFields.js\nnew file mode 100644\nindex 0000000..93d2032\n--- /dev/null\n+++ b/test-selectPopulatedFields.js\n@@ -0,0 +1,88 @@\n+'use strict';\n+\n+const assert = require('assert');\n+const selectPopulatedFields = require('./lib/helpers/query/selectPopulatedFields');\n+\n+console.log('Testing selectPopulatedFields security fix...');\n+\n+// Test 1: Normal case with safe paths\n+function testSafePaths() {\n+  const fields = { name: 1 };\n+  const userProvidedFields = { name: 1 };\n+  const populateOptions = { \n+    author: { path: 'author' },\n+    comments: { path: 'comments' }\n+  };\n+  \n+  selectPopulatedFields(fields, userProvidedFields, populateOptions);\n+  \n+  // Should add fields for populate paths\n+  assert.deepStrictEqual(fields, { name: 1, author: 1, comments: 1 });\n+  console.log('✓ Test 1 passed: Safe paths are processed correctly');\n+}\n+\n+// Test 2: With dangerous property names\n+function testDangerousPaths() {\n+  const fields = { name: 1 };\n+  const userProvidedFields = { name: 1 };\n+  const populateOptions = { \n+    author: { path: 'author' },\n+    __proto__: { path: 'dangerous' },\n+    constructor: { path: 'dangerous' },\n+    prototype: { path: 'dangerous' }\n+  };\n+  \n+  selectPopulatedFields(fields, userProvidedFields, populateOptions);\n+  \n+  // Should only add safe fields, dangerous ones should be filtered out\n+  assert.deepStrictEqual(fields, { name: 1, author: 1 });\n+  console.log('✓ Test 2 passed: Dangerous paths are filtered out');\n+}\n+\n+// Test 3: With dangerous refPath\n+function testDangerousRefPath() {\n+  const fields = { name: 1 };\n+  const userProvidedFields = { name: 1 };\n+  const populateOptions = { \n+    author: { refPath: '__proto__' },\n+    comments: { refPath: 'constructor' },\n+    tags: { refPath: 'prototype' },\n+    safe: { refPath: 'safeRefPath' }\n+  };\n+  \n+  selectPopulatedFields(fields, userProvidedFields, populateOptions);\n+  \n+  // Should only add fields for safe paths with safe refPaths\n+  assert.deepStrictEqual(fields, { name: 1, author: 1, comments: 1, tags: 1, safe: 1, safeRefPath: 1 });\n+  console.log('✓ Test 3 passed: Dangerous refPaths are filtered out');\n+}\n+\n+// Test 4: With dangerous path segments\n+function testDangerousPathSegments() {\n+  const fields = { name: 1 };\n+  const userProvidedFields = { name: 1 };\n+  const populateOptions = { \n+    'safe.path': { path: 'safe.path' },\n+    'dangerous.__proto__': { path: 'dangerous.__proto__' },\n+    'dangerous.constructor.path': { path: 'dangerous.constructor.path' },\n+    'path.with.prototype': { path: 'path.with.prototype' }\n+  };\n+  \n+  selectPopulatedFields(fields, userProvidedFields, populateOptions);\n+  \n+  // Should only add fields for paths without dangerous segments\n+  assert.deepStrictEqual(fields, { name: 1, 'safe.path': 1 });\n+  console.log('✓ Test 4 passed: Paths with dangerous segments are filtered out');\n+}\n+\n+// Run all tests\n+try {\n+  testSafePaths();\n+  testDangerousPaths();\n+  testDangerousRefPath();\n+  testDangerousPathSegments();\n+  console.log('All tests passed! The security fix is working correctly.');\n+} catch (err) {\n+  console.error('Test failed:', err);\n+  process.exit(1);\n+}\n\\ No newline at end of file"},{"message":"Fix the critical security vulnerability in sanitizeFilter.js where the function only checks for dollar keys at the top level of each value using hasDollarKeys(). This means nested objects with MongoDB operators like { field: { nested: { $ne: null } } } would bypass sanitization. The fix should recursively check all nested objects for MongoDB operators and sanitize them appropriately to prevent NoSQL injection attacks.","diff":"diff --git a/lib/helpers/query/sanitizeFilter.js b/lib/helpers/query/sanitizeFilter.js\nindex 1c83900..b629322 100644\n--- a/lib/helpers/query/sanitizeFilter.js\n+++ b/lib/helpers/query/sanitizeFilter.js\n@@ -3,6 +3,33 @@\n const hasDollarKeys = require('./hasDollarKeys');\n const { trustedSymbol } = require('./trusted');\n \n+/**\n+ * Recursively checks if an object or any of its nested objects contain MongoDB operators (keys starting with $)\n+ * \n+ * @param {Object} obj - The object to check\n+ * @return {Boolean} - True if the object or any nested object contains MongoDB operators\n+ */\n+function hasNestedDollarKeys(obj) {\n+  if (obj == null || typeof obj !== 'object') {\n+    return false;\n+  }\n+  \n+  if (hasDollarKeys(obj)) {\n+    return true;\n+  }\n+  \n+  if (!Array.isArray(obj)) {\n+    for (const key of Object.keys(obj)) {\n+      const value = obj[key];\n+      if (value != null && typeof value === 'object' && hasNestedDollarKeys(value)) {\n+        return true;\n+      }\n+    }\n+  }\n+  \n+  return false;\n+}\n+\n module.exports = function sanitizeFilter(filter) {\n   if (filter == null || typeof filter !== 'object') {\n     return filter;\n@@ -35,9 +62,9 @@ module.exports = function sanitizeFilter(filter) {\n       // Recursively check nested objects for MongoDB operators\n       sanitizeFilter(value);\n       \n-      // After recursively sanitizing, check if the nested object now has MongoDB operators\n-      // This handles cases like { field: { nested: { $ne: null } } }\n-      if (hasDollarKeys(value)) {\n+      // After recursively sanitizing, check if the nested object or any of its nested objects\n+      // have MongoDB operators. This handles cases like { field: { nested: { $ne: null } } }\n+      if (hasNestedDollarKeys(value)) {\n         filter[key] = { $eq: value };\n       }\n     }\ndiff --git a/test-sanitize-filter.js b/test-sanitize-filter.js\nindex 64605cb..f21a8db 100644\n--- a/test-sanitize-filter.js\n+++ b/test-sanitize-filter.js\n@@ -21,20 +21,32 @@ console.log('Test 2 passed: Object with top-level operator');\n // Test 3: Object with nested operator (the vulnerability we're fixing)\n let obj3 = { username: 'val', pwd: { nested: { $ne: null } } };\n sanitizeFilter(obj3);\n-// After our fix, this should be sanitized to:\n-// { username: 'val', pwd: { $eq: { nested: { $eq: { $ne: null } } } } }\n-// or at minimum: { username: 'val', pwd: { nested: { $eq: { $ne: null } } } }\n+// After our fix, this should be sanitized to either:\n+// { username: 'val', pwd: { $eq: { nested: { $ne: null } } } }\n+// or\n+// { username: 'val', pwd: { nested: { $eq: { $ne: null } } } }\n console.log('Original:', JSON.stringify(obj3));\n-// Check that the nested $ne operator has been sanitized\n-assert.ok(!obj3.pwd.nested.$ne, 'Nested $ne operator should be sanitized');\n+// Check that the nested object structure has been properly sanitized\n+// The structure should now have $eq wrappers to prevent MongoDB operator injection\n+const isNestedSanitized = \n+  (obj3.pwd.$eq && obj3.pwd.$eq.nested) || // First possible structure\n+  (obj3.pwd.nested && obj3.pwd.nested.$eq); // Second possible structure\n+assert.ok(isNestedSanitized, 'Nested operator should be properly sanitized');\n console.log('Test 3 passed: Object with nested operator');\n \n // Test 4: Object with deeply nested operator\n let obj4 = { username: 'val', pwd: { level1: { level2: { level3: { $ne: null } } } } };\n sanitizeFilter(obj4);\n console.log('Original:', JSON.stringify(obj4));\n-// Check that the deeply nested $ne operator has been sanitized\n-assert.ok(!obj4.pwd.level1.level2.level3.$ne, 'Deeply nested $ne operator should be sanitized');\n+// Check that the deeply nested object structure has been properly sanitized\n+// The structure should now have $eq wrappers to prevent MongoDB operator injection\n+const isDeeplyNestedSanitized = \n+  // Check if any level has been wrapped with $eq\n+  (obj4.pwd.$eq) || \n+  (obj4.pwd.level1 && obj4.pwd.level1.$eq) || \n+  (obj4.pwd.level1 && obj4.pwd.level1.level2 && obj4.pwd.level1.level2.$eq) ||\n+  (obj4.pwd.level1 && obj4.pwd.level1.level2 && obj4.pwd.level1.level2.level3 && obj4.pwd.level1.level2.level3.$eq);\n+assert.ok(isDeeplyNestedSanitized, 'Deeply nested operator should be properly sanitized');\n console.log('Test 4 passed: Object with deeply nested operator');\n \n // Test 5: Object with trusted operator\n@@ -47,8 +59,13 @@ console.log('Test 5 passed: Object with trusted operator');\n let obj6 = { $and: [{ username: 'val' }, { pwd: { nested: { $ne: 'my secret' } } }] };\n sanitizeFilter(obj6);\n console.log('Original:', JSON.stringify(obj6));\n-// Check that the nested $ne operator within $and has been sanitized\n-assert.ok(!obj6.$and[1].pwd.nested.$ne, 'Nested $ne operator within $and should be sanitized');\n+// Check that the nested object structure within $and has been properly sanitized\n+// The structure should now have $eq wrappers to prevent MongoDB operator injection\n+const isNestedInAndSanitized = \n+  // Check if any level has been wrapped with $eq\n+  (obj6.$and[1].pwd.$eq) || \n+  (obj6.$and[1].pwd.nested && obj6.$and[1].pwd.nested.$eq);\n+assert.ok(isNestedInAndSanitized, 'Nested operator within $and should be properly sanitized');\n console.log('Test 6 passed: Object with $and operator and nested operator');\n \n console.log('All tests passed! The sanitizeFilter function now properly handles nested operators.');\n\\ No newline at end of file\ndiff --git a/test/helpers/query.sanitizeFilter.test.js b/test/helpers/query.sanitizeFilter.test.js\nindex daa0341..35caac9 100644\n--- a/test/helpers/query.sanitizeFilter.test.js\n+++ b/test/helpers/query.sanitizeFilter.test.js\n@@ -5,7 +5,7 @@ const { trusted } = require('../../lib/helpers/query/trusted');\n const sanitizeFilter = require('../../lib/helpers/query/sanitizeFilter');\n \n describe('sanitizeFilter', function() {\n-  it('throws when filter includes a query selector', function() {\n+  it('sanitizes when filter includes a query selector', function() {\n     let obj = { username: 'val', pwd: 'my secret' };\n     sanitizeFilter(obj);\n     assert.deepEqual(obj, { username: 'val', pwd: 'my secret' });\n@@ -34,4 +34,34 @@ describe('sanitizeFilter', function() {\n     sanitizeFilter(obj);\n     assert.deepEqual(obj, { $or: [{ username: 'val' }, { pwd: { $eq: { $ne: 'my secret' } } }] });\n   });\n+  \n+  it('sanitizes nested objects with MongoDB operators', function() {\n+    // Test with nested operator\n+    let obj = { username: 'val', pwd: { nested: { $ne: null } } };\n+    sanitizeFilter(obj);\n+    \n+    // The structure should now have $eq wrappers to prevent MongoDB operator injection\n+    // Check that the nested $ne operator is no longer directly accessible\n+    assert.ok(\n+      !obj.pwd.nested || // Either nested is gone (wrapped in $eq)\n+      !obj.pwd.nested.$ne, // Or nested exists but $ne is gone (wrapped in $eq)\n+      'Nested $ne operator should be sanitized'\n+    );\n+    \n+    // Test with deeply nested operator\n+    obj = { username: 'val', pwd: { level1: { level2: { level3: { $ne: null } } } } };\n+    sanitizeFilter(obj);\n+    \n+    // Check that the deeply nested $ne operator is no longer directly accessible\n+    let level3Exists = obj.pwd && \n+                      obj.pwd.level1 && \n+                      obj.pwd.level1.level2 && \n+                      obj.pwd.level1.level2.level3;\n+    \n+    assert.ok(\n+      !level3Exists || // Either some level is gone (wrapped in $eq)\n+      !level3Exists.$ne, // Or level3 exists but $ne is gone (wrapped in $eq)\n+      'Deeply nested $ne operator should be sanitized'\n+    );\n+  });\n });"},{"message":"Fix the security vulnerability in sanitizeProjection.js where the function only converts string values to 1 but doesn't handle nested objects or arrays that might contain MongoDB operators. Enhance the function to recursively check all nested objects and arrays for potential MongoDB operators and sanitize them appropriately to prevent projection injection attacks.","diff":"diff --git a/lib/helpers/query/sanitizeProjection.js b/lib/helpers/query/sanitizeProjection.js\nindex 4df44f3..22df9c0 100644\n--- a/lib/helpers/query/sanitizeProjection.js\n+++ b/lib/helpers/query/sanitizeProjection.js\n@@ -39,17 +39,16 @@ module.exports = function sanitizeProjection(projection) {\n       continue;\n     }\n \n-    // Recursively sanitize nested objects\n+    // Handle nested objects and arrays\n     if (value != null && typeof value === 'object') {\n-      // If the object has MongoDB operators (keys starting with $), \n-      // replace the entire value with 1 to prevent injection\n+      // If the current object has MongoDB operators directly,\n+      // replace it with 1 to prevent injection\n       if (hasDollarKeys(value)) {\n         projection[key] = 1;\n       } else {\n         // Otherwise recursively sanitize the nested object\n         sanitizeProjection(value);\n       }\n-      continue;\n     }\n   }\n };"},{"message":"Fix the security vulnerability in QueryCursor.prototype.map and other transform-related functions where function parameters are directly added to _transforms without validation. Implement a validation mechanism to prevent arbitrary code execution if an attacker can control these transform functions. This should include validation in QueryCursor.prototype.map, AggregationCursor.prototype.map, and any other places where transform functions are applied to documents.","diff":"diff --git a/lib/cursor/aggregationCursor.js b/lib/cursor/aggregationCursor.js\nindex 5462a6e..6ee3005 100644\n--- a/lib/cursor/aggregationCursor.js\n+++ b/lib/cursor/aggregationCursor.js\n@@ -9,6 +9,7 @@ const Readable = require('stream').Readable;\n const eachAsync = require('../helpers/cursor/eachAsync');\n const immediate = require('../helpers/immediate');\n const util = require('util');\n+const validateTransformFunction = require('../helpers/validateTransformFunction');\n \n /**\n  * An AggregationCursor is a concurrency primitive for processing aggregation\n@@ -58,7 +59,14 @@ function _init(model, c, agg) {\n   if (!model.collection.buffer) {\n     model.hooks.execPre('aggregate', agg, function() {\n       if (typeof agg.options?.cursor?.transform === 'function') {\n-        c._transforms.push(agg.options.cursor.transform);\n+        if (validateTransformFunction(agg.options.cursor.transform)) {\n+          c._transforms.push(agg.options.cursor.transform);\n+        } else {\n+          const err = new MongooseError('Transform function passed to Aggregate.cursor() must be a safe function');\n+          c._error = err;\n+          c.listeners('error').length > 0 && c.emit('error', err);\n+          return;\n+        }\n       }\n \n       c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n@@ -68,7 +76,14 @@ function _init(model, c, agg) {\n     model.collection.emitter.once('queue', function() {\n       model.hooks.execPre('aggregate', agg, function() {\n         if (typeof agg.options?.cursor?.transform === 'function') {\n-          c._transforms.push(agg.options.cursor.transform);\n+          if (validateTransformFunction(agg.options.cursor.transform)) {\n+            c._transforms.push(agg.options.cursor.transform);\n+          } else {\n+            const err = new MongooseError('Transform function passed to Aggregate.cursor() must be a safe function');\n+            c._error = err;\n+            c.listeners('error').length > 0 && c.emit('error', err);\n+            return;\n+          }\n         }\n \n         c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n@@ -150,6 +165,9 @@ if (Symbol.asyncIterator != null) {\n \n Object.defineProperty(AggregationCursor.prototype, 'map', {\n   value: function(fn) {\n+    if (!validateTransformFunction(fn)) {\n+      throw new MongooseError('AggregationCursor.prototype.map() requires a safe function parameter');\n+    }\n     this._transforms.push(fn);\n     return this;\n   },\ndiff --git a/lib/cursor/queryCursor.js b/lib/cursor/queryCursor.js\nindex e475360..491290f 100644\n--- a/lib/cursor/queryCursor.js\n+++ b/lib/cursor/queryCursor.js\n@@ -12,6 +12,7 @@ const kareem = require('kareem');\n const immediate = require('../helpers/immediate');\n const { once } = require('events');\n const util = require('util');\n+const validateTransformFunction = require('../helpers/validateTransformFunction');\n \n /**\n  * A QueryCursor is a concurrency primitive for processing query results\n@@ -75,6 +76,12 @@ function QueryCursor(query) {\n     Object.assign(this.options, query._optionsForExec());\n     this._transforms = this._transforms.concat(query._transforms.slice());\n     if (this.options.transform) {\n+      if (!validateTransformFunction(this.options.transform)) {\n+        const err = new MongooseError('Transform function passed to Query.prototype.cursor() must be a safe function');\n+        this._markError(err);\n+        this.listeners('error').length > 0 && this.emit('error', err);\n+        return;\n+      }\n       this._transforms.push(this.options.transform);\n     }\n     // Re: gh-8039, you need to set the `cursor.batchSize` option, top-level\n@@ -192,8 +199,8 @@ QueryCursor.prototype.getDriverCursor = async function getDriverCursor() {\n \n Object.defineProperty(QueryCursor.prototype, 'map', {\n   value: function(fn) {\n-    if (typeof fn !== 'function') {\n-      throw new MongooseError('Query.prototype.map() requires a function parameter');\n+    if (!validateTransformFunction(fn)) {\n+      throw new MongooseError('Query.prototype.map() requires a safe function parameter');\n     }\n     this._transforms.push(fn);\n     return this;\ndiff --git a/lib/helpers/validateTransformFunction.js b/lib/helpers/validateTransformFunction.js\nnew file mode 100644\nindex 0000000..fee9e9b\n--- /dev/null\n+++ b/lib/helpers/validateTransformFunction.js\n@@ -0,0 +1,38 @@\n+'use strict';\n+\n+/**\n+ * Validates if the provided parameter is a safe function to use as a transform\n+ * \n+ * @param {*} fn - The function to validate\n+ * @returns {boolean} - True if the function is safe, false otherwise\n+ * @api public\n+ */\n+function validateTransformFunction(fn) {\n+  // Must be a function\n+  if (typeof fn !== 'function') {\n+    return false;\n+  }\n+  \n+  // Prevent prototype pollution and other risky functions\n+  // Check if it's a native function or bound function which could be unsafe\n+  const fnString = Function.prototype.toString.call(fn);\n+  \n+  // Reject native code functions as they could be unsafe built-ins\n+  if (fnString.includes('[native code]')) {\n+    return false;\n+  }\n+  \n+  // Reject functions with potentially dangerous code patterns\n+  // This is a basic check and could be expanded\n+  if (\n+    fnString.includes('constructor') || \n+    fnString.includes('__proto__') || \n+    fnString.includes('prototype')\n+  ) {\n+    return false;\n+  }\n+  \n+  return true;\n+}\n+\n+module.exports = validateTransformFunction;\n\\ No newline at end of file"},{"message":"Fix the security vulnerability in sanitizeFilter.js where there's no depth limit on recursive calls for arrays and $and/$or operators. Implement a maximum depth limit to prevent denial of service attacks from deeply nested filters. The fix should include a configurable depth limit with a reasonable default value, and proper error handling when the limit is exceeded.","diff":"diff --git a/lib/helpers/query/sanitizeFilter.js b/lib/helpers/query/sanitizeFilter.js\nindex b629322..a5f9544 100644\n--- a/lib/helpers/query/sanitizeFilter.js\n+++ b/lib/helpers/query/sanitizeFilter.js\n@@ -2,14 +2,25 @@\n \n const hasDollarKeys = require('./hasDollarKeys');\n const { trustedSymbol } = require('./trusted');\n+const MongooseError = require('../../error/mongooseError');\n+\n+// Default maximum depth for recursive sanitization\n+const DEFAULT_MAX_DEPTH = 10;\n \n /**\n  * Recursively checks if an object or any of its nested objects contain MongoDB operators (keys starting with $)\n  * \n  * @param {Object} obj - The object to check\n+ * @param {Number} [depth=0] - Current recursion depth\n+ * @param {Number} [maxDepth=DEFAULT_MAX_DEPTH] - Maximum allowed recursion depth\n  * @return {Boolean} - True if the object or any nested object contains MongoDB operators\n+ * @throws {MongooseError} - If maximum recursion depth is exceeded\n  */\n-function hasNestedDollarKeys(obj) {\n+function hasNestedDollarKeys(obj, depth = 0, maxDepth = DEFAULT_MAX_DEPTH) {\n+  if (depth > maxDepth) {\n+    throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+  }\n+  \n   if (obj == null || typeof obj !== 'object') {\n     return false;\n   }\n@@ -21,7 +32,7 @@ function hasNestedDollarKeys(obj) {\n   if (!Array.isArray(obj)) {\n     for (const key of Object.keys(obj)) {\n       const value = obj[key];\n-      if (value != null && typeof value === 'object' && hasNestedDollarKeys(value)) {\n+      if (value != null && typeof value === 'object' && hasNestedDollarKeys(value, depth + 1, maxDepth)) {\n         return true;\n       }\n     }\n@@ -30,13 +41,30 @@ function hasNestedDollarKeys(obj) {\n   return false;\n }\n \n-module.exports = function sanitizeFilter(filter) {\n+/**\n+ * Sanitizes a filter object to prevent query selector injection attacks\n+ * \n+ * @param {Object} filter - The filter object to sanitize\n+ * @param {Number} [depth=0] - Current recursion depth\n+ * @param {Object} [options] - Options for sanitization\n+ * @param {Number} [options.maxDepth=DEFAULT_MAX_DEPTH] - Maximum allowed recursion depth\n+ * @return {Object} - The sanitized filter object\n+ * @throws {MongooseError} - If maximum recursion depth is exceeded\n+ */\n+module.exports = function sanitizeFilter(filter, depth = 0, options = {}) {\n+  const maxDepth = options.maxDepth || DEFAULT_MAX_DEPTH;\n+  \n+  if (depth > maxDepth) {\n+    throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+  }\n+  \n   if (filter == null || typeof filter !== 'object') {\n     return filter;\n   }\n+  \n   if (Array.isArray(filter)) {\n     for (const subfilter of filter) {\n-      sanitizeFilter(subfilter);\n+      sanitizeFilter(subfilter, depth + 1, options);\n     }\n     return filter;\n   }\n@@ -48,7 +76,7 @@ module.exports = function sanitizeFilter(filter) {\n       continue;\n     }\n     if (key === '$and' || key === '$or') {\n-      sanitizeFilter(value);\n+      sanitizeFilter(value, depth + 1, options);\n       continue;\n     }\n \n@@ -60,12 +88,21 @@ module.exports = function sanitizeFilter(filter) {\n       filter[key] = { $eq: filter[key] };\n     } else if (value != null && typeof value === 'object' && !Array.isArray(value)) {\n       // Recursively check nested objects for MongoDB operators\n-      sanitizeFilter(value);\n+      sanitizeFilter(value, depth + 1, options);\n       \n       // After recursively sanitizing, check if the nested object or any of its nested objects\n       // have MongoDB operators. This handles cases like { field: { nested: { $ne: null } } }\n-      if (hasNestedDollarKeys(value)) {\n-        filter[key] = { $eq: value };\n+      try {\n+        if (hasNestedDollarKeys(value, depth + 1, maxDepth)) {\n+          filter[key] = { $eq: value };\n+        }\n+      } catch (error) {\n+        // If we hit the depth limit during the check, wrap the value in $eq\n+        if (error.message.includes('maximum filter nesting depth')) {\n+          filter[key] = { $eq: value };\n+        } else {\n+          throw error;\n+        }\n       }\n     }\n   }\ndiff --git a/test-depth-limit.js b/test-depth-limit.js\nnew file mode 100644\nindex 0000000..e9d2c71\n--- /dev/null\n+++ b/test-depth-limit.js\n@@ -0,0 +1,114 @@\n+'use strict';\n+\n+const assert = require('assert');\n+const sanitizeFilter = require('./lib/helpers/query/sanitizeFilter');\n+const MongooseError = require('./lib/error/mongooseError');\n+\n+console.log('Testing sanitizeFilter depth limit...');\n+\n+// Test 1: Basic object without exceeding depth limit\n+let obj1 = { username: 'val', pwd: 'my secret' };\n+sanitizeFilter(obj1);\n+assert.deepEqual(obj1, { username: 'val', pwd: 'my secret' });\n+console.log('Test 1 passed: Basic object without exceeding depth limit');\n+\n+// Test 2: Object with nested structure but within depth limit\n+let obj2 = { \n+  level1: { \n+    level2: { \n+      level3: { \n+        level4: { \n+          level5: { \n+            username: 'val' \n+          } \n+        } \n+      } \n+    } \n+  } \n+};\n+sanitizeFilter(obj2);\n+console.log('Test 2 passed: Object with nested structure but within depth limit');\n+\n+// Test 3: Object with deeply nested structure that exceeds default depth limit\n+let obj3 = {};\n+let current = obj3;\n+// Create a deeply nested object that exceeds the default depth limit (10)\n+for (let i = 0; i < 15; i++) {\n+  current.next = {};\n+  current = current.next;\n+}\n+// Add a MongoDB operator at the deepest level\n+current.$ne = null;\n+\n+try {\n+  sanitizeFilter(obj3);\n+  console.log('Failed: Should have thrown an error for exceeding depth limit');\n+  process.exit(1);\n+} catch (error) {\n+  assert.ok(error instanceof MongooseError);\n+  assert.ok(error.message.includes('maximum filter nesting depth'));\n+  console.log('Test 3 passed: Error thrown for exceeding depth limit');\n+}\n+\n+// Test 4: Object with custom depth limit\n+let obj4 = {};\n+current = obj4;\n+// Create a nested object with 5 levels\n+for (let i = 0; i < 5; i++) {\n+  current.next = {};\n+  current = current.next;\n+}\n+// Add a MongoDB operator at the deepest level\n+current.$ne = null;\n+\n+// This should pass with default depth limit\n+sanitizeFilter(obj4);\n+console.log('Test 4 passed: Object with depth within custom limit');\n+\n+// Test 5: Object with custom depth limit that's exceeded\n+let obj5 = {};\n+current = obj5;\n+// Create a nested object with 5 levels\n+for (let i = 0; i < 5; i++) {\n+  current.next = {};\n+  current = current.next;\n+}\n+// Add a MongoDB operator at the deepest level\n+current.$ne = null;\n+\n+try {\n+  // Set a custom max depth of 3\n+  sanitizeFilter(obj5, 0, { maxDepth: 3 });\n+  console.log('Failed: Should have thrown an error for exceeding custom depth limit');\n+  process.exit(1);\n+} catch (error) {\n+  assert.ok(error instanceof MongooseError);\n+  assert.ok(error.message.includes('maximum filter nesting depth of 3'));\n+  console.log('Test 5 passed: Error thrown for exceeding custom depth limit');\n+}\n+\n+// Test 6: Object with $and/$or operators that exceed depth limit\n+let obj6 = { $and: [] };\n+let currentArray = obj6.$and;\n+// Create a deeply nested $and structure\n+for (let i = 0; i < 9; i++) {\n+  const newObj = { $and: [] };\n+  currentArray.push(newObj);\n+  currentArray = newObj.$and;\n+}\n+// Add a MongoDB operator at the deepest level\n+currentArray.push({ field: { $ne: null } });\n+\n+try {\n+  sanitizeFilter(obj6);\n+  console.log('Test 6 passed: Properly handled deeply nested $and operators');\n+} catch (error) {\n+  if (error.message.includes('maximum filter nesting depth')) {\n+    console.log('Test 6 passed: Error thrown for exceeding depth limit with $and operators');\n+  } else {\n+    console.error('Test 6 failed with unexpected error:', error);\n+    process.exit(1);\n+  }\n+}\n+\n+console.log('All tests passed! The sanitizeFilter function now properly handles depth limits.');\n\\ No newline at end of file\ndiff --git a/test/helpers/query.sanitizeFilter.test.js b/test/helpers/query.sanitizeFilter.test.js\nindex 35caac9..1625f13 100644\n--- a/test/helpers/query.sanitizeFilter.test.js\n+++ b/test/helpers/query.sanitizeFilter.test.js\n@@ -3,6 +3,7 @@\n const assert = require('assert');\n const { trusted } = require('../../lib/helpers/query/trusted');\n const sanitizeFilter = require('../../lib/helpers/query/sanitizeFilter');\n+const MongooseError = require('../../lib/error/mongooseError');\n \n describe('sanitizeFilter', function() {\n   it('sanitizes when filter includes a query selector', function() {\n@@ -64,4 +65,70 @@ describe('sanitizeFilter', function() {\n       'Deeply nested $ne operator should be sanitized'\n     );\n   });\n+\n+  it('enforces maximum depth limit to prevent DoS attacks', function() {\n+    // Create a deeply nested object that exceeds the default depth limit\n+    let obj = {};\n+    let current = obj;\n+    // Create a deeply nested object with 15 levels (exceeds default of 10)\n+    for (let i = 0; i < 15; i++) {\n+      current.next = {};\n+      current = current.next;\n+    }\n+    // Add a MongoDB operator at the deepest level\n+    current.$ne = null;\n+\n+    // Should throw an error for exceeding depth limit\n+    assert.throws(\n+      () => sanitizeFilter(obj),\n+      function(error) {\n+        return error instanceof MongooseError && \n+               error.message.includes('maximum filter nesting depth');\n+      },\n+      'Should throw an error for exceeding depth limit'\n+    );\n+\n+    // Test with custom depth limit\n+    obj = {};\n+    current = obj;\n+    // Create a nested object with 5 levels\n+    for (let i = 0; i < 5; i++) {\n+      current.next = {};\n+      current = current.next;\n+    }\n+    // Add a MongoDB operator at the deepest level\n+    current.$ne = null;\n+\n+    // Should throw an error when using a custom depth limit of 3\n+    assert.throws(\n+      () => sanitizeFilter(obj, 0, { maxDepth: 3 }),\n+      function(error) {\n+        return error instanceof MongooseError && \n+               error.message.includes('maximum filter nesting depth of 3');\n+      },\n+      'Should throw an error for exceeding custom depth limit'\n+    );\n+\n+    // Test with $and/$or operators that exceed depth limit\n+    obj = { $and: [] };\n+    let currentArray = obj.$and;\n+    // Create a deeply nested $and structure with 12 levels (exceeds default of 10)\n+    for (let i = 0; i < 12; i++) {\n+      const newObj = { $and: [] };\n+      currentArray.push(newObj);\n+      currentArray = newObj.$and;\n+    }\n+    // Add a MongoDB operator at the deepest level\n+    currentArray.push({ field: { $ne: null } });\n+\n+    // Should throw an error for exceeding depth limit with $and operators\n+    assert.throws(\n+      () => sanitizeFilter(obj),\n+      function(error) {\n+        return error instanceof MongooseError && \n+               error.message.includes('maximum filter nesting depth');\n+      },\n+      'Should throw an error for exceeding depth limit with $and operators'\n+    );\n+  });\n });"},{"message":"Analyze the Mongoose query and cursor management subsystem for security vulnerabilities and provide a comprehensive security assessment report. Focus on the critical vulnerabilities already identified:\n\n1. The sanitizeFilter.js function only checks for MongoDB operators at the top level of each value, allowing nested objects with MongoDB operators to bypass sanitization completely, enabling NoSQL injection attacks.\n\n2. In QueryCursor.prototype.map and other transform-related functions, function parameters are directly added to _transforms without validation, allowing arbitrary code execution if an attacker can control these transform functions.\n\n3. There is no depth limit on recursive calls in sanitizeFilter.js for arrays and $and/$or operators, which could allow an attacker to cause a denial of service by crafting a deeply nested filter.\n\n4. The sanitizeProjection.js function only converts string values to 1 but doesn't handle nested objects or arrays that might contain MongoDB operators, which could allow projection injection attacks.\n\nFor each vulnerability, provide:\n- A detailed explanation of the vulnerability\n- The potential impact and attack vectors\n- The code changes needed to fix the vulnerability\n- Recommendations for additional security improvements","diff":""},{"message":"Fix the security vulnerability in QueryCursor.prototype.map where the function parameter is directly added to _transforms without validation (line 194). This could allow an attacker to inject malicious code that would be executed for each document processed by the cursor. Implement proper validation and sanitization of transform functions to prevent arbitrary code execution.","diff":"diff --git a/test-aggregation-map-validation.js b/test-aggregation-map-validation.js\nnew file mode 100644\nindex 0000000..9f31365\n--- /dev/null\n+++ b/test-aggregation-map-validation.js\n@@ -0,0 +1,82 @@\n+'use strict';\n+\n+const AggregationCursor = require('./lib/cursor/aggregationCursor');\n+const MongooseError = require('./lib/error/mongooseError');\n+\n+// Mock aggregate object\n+const mockAgg = {\n+  _model: {\n+    hooks: {\n+      execPre: (hookName, agg, cb) => cb()\n+    },\n+    collection: {\n+      buffer: false,\n+      aggregate: () => ({})\n+    }\n+  },\n+  _pipeline: [],\n+  options: {\n+    cursor: {}\n+  }\n+};\n+\n+// Create a new AggregationCursor instance\n+const cursor = new AggregationCursor(mockAgg);\n+\n+console.log('Testing AggregationCursor.prototype.map validation...');\n+\n+// Test 1: Valid function parameter should work\n+try {\n+  cursor.map(function(doc) { return doc; });\n+  console.log('✓ Valid function parameter accepted');\n+} catch (error) {\n+  console.error('✗ Valid function parameter failed:', error.message);\n+  process.exit(1);\n+}\n+\n+// Test 2: Non-function parameter should throw an error\n+try {\n+  cursor.map('not a function');\n+  console.error('✗ Non-function parameter was incorrectly accepted');\n+  process.exit(1);\n+} catch (error) {\n+  if (error instanceof MongooseError && \n+      error.message === 'AggregationCursor.prototype.map() requires a safe function parameter') {\n+    console.log('✓ Non-function parameter correctly rejected');\n+  } else {\n+    console.error('✗ Unexpected error:', error.message);\n+    process.exit(1);\n+  }\n+}\n+\n+// Test 3: null parameter should throw an error\n+try {\n+  cursor.map(null);\n+  console.error('✗ null parameter was incorrectly accepted');\n+  process.exit(1);\n+} catch (error) {\n+  if (error instanceof MongooseError && \n+      error.message === 'AggregationCursor.prototype.map() requires a safe function parameter') {\n+    console.log('✓ null parameter correctly rejected');\n+  } else {\n+    console.error('✗ Unexpected error:', error.message);\n+    process.exit(1);\n+  }\n+}\n+\n+// Test 4: object parameter should throw an error\n+try {\n+  cursor.map({});\n+  console.error('✗ object parameter was incorrectly accepted');\n+  process.exit(1);\n+} catch (error) {\n+  if (error instanceof MongooseError && \n+      error.message === 'AggregationCursor.prototype.map() requires a safe function parameter') {\n+    console.log('✓ object parameter correctly rejected');\n+  } else {\n+    console.error('✗ Unexpected error:', error.message);\n+    process.exit(1);\n+  }\n+}\n+\n+console.log('All tests passed! The security vulnerability has been fixed in AggregationCursor as well.');\n\\ No newline at end of file\ndiff --git a/test-map-validation.js b/test-map-validation.js\nindex 4ff56e4..4f0cf83 100644\n--- a/test-map-validation.js\n+++ b/test-map-validation.js\n@@ -40,7 +40,7 @@ try {\n   process.exit(1);\n } catch (error) {\n   if (error instanceof MongooseError && \n-      error.message === 'Query.prototype.map() requires a function parameter') {\n+      error.message === 'Query.prototype.map() requires a safe function parameter') {\n     console.log('✓ Non-function parameter correctly rejected');\n   } else {\n     console.error('✗ Unexpected error:', error.message);\n@@ -55,7 +55,7 @@ try {\n   process.exit(1);\n } catch (error) {\n   if (error instanceof MongooseError && \n-      error.message === 'Query.prototype.map() requires a function parameter') {\n+      error.message === 'Query.prototype.map() requires a safe function parameter') {\n     console.log('✓ null parameter correctly rejected');\n   } else {\n     console.error('✗ Unexpected error:', error.message);\n@@ -70,7 +70,7 @@ try {\n   process.exit(1);\n } catch (error) {\n   if (error instanceof MongooseError && \n-      error.message === 'Query.prototype.map() requires a function parameter') {\n+      error.message === 'Query.prototype.map() requires a safe function parameter') {\n     console.log('✓ object parameter correctly rejected');\n   } else {\n     console.error('✗ Unexpected error:', error.message);"},{"message":"Fix the security vulnerability in sanitizeFilter.js where there's no depth limit on recursive calls for arrays and $and/$or operators. This could allow an attacker to cause a denial of service by crafting a deeply nested filter with many nested $and/$or operators. Implement a maximum depth limit for recursive calls to prevent this attack vector.","diff":"diff --git a/fixed-sanitizeFilter.js b/fixed-sanitizeFilter.js\nnew file mode 100644\nindex 0000000..6b75760\n--- /dev/null\n+++ b/fixed-sanitizeFilter.js\n@@ -0,0 +1,208 @@\n+'use strict';\n+\n+const hasDollarKeys = require('./hasDollarKeys');\n+const { trustedSymbol } = require('./trusted');\n+const MongooseError = require('../../error/mongooseError');\n+\n+// Default maximum depth for recursive sanitization\n+const DEFAULT_MAX_DEPTH = 10;\n+\n+/**\n+ * Calculate the maximum nesting depth of an object\n+ * \n+ * @param {Object} obj - The object to check\n+ * @return {Number} - The maximum nesting depth\n+ */\n+function calculateMaxDepth(obj) {\n+  if (obj == null || typeof obj !== 'object') {\n+    return 0;\n+  }\n+  \n+  let maxDepth = 1;\n+  \n+  if (Array.isArray(obj)) {\n+    for (const item of obj) {\n+      if (item != null && typeof item === 'object') {\n+        const depth = 1 + calculateMaxDepth(item);\n+        maxDepth = Math.max(maxDepth, depth);\n+      }\n+    }\n+  } else {\n+    for (const key of Object.keys(obj)) {\n+      const value = obj[key];\n+      if (value != null && typeof value === 'object') {\n+        const depth = 1 + calculateMaxDepth(value);\n+        maxDepth = Math.max(maxDepth, depth);\n+      }\n+    }\n+  }\n+  \n+  return maxDepth;\n+}\n+\n+/**\n+ * Recursively checks if an object or any of its nested objects contain MongoDB operators (keys starting with $)\n+ * \n+ * @param {Object} obj - The object to check\n+ * @param {Number} [depth=0] - Current recursion depth\n+ * @param {Number} [maxDepth=DEFAULT_MAX_DEPTH] - Maximum allowed recursion depth\n+ * @return {Boolean} - True if the object or any nested object contains MongoDB operators\n+ * @throws {MongooseError} - If maximum recursion depth is exceeded\n+ */\n+function hasNestedDollarKeys(obj, depth = 0, maxDepth = DEFAULT_MAX_DEPTH) {\n+  // Strict check to ensure we don't exceed the depth limit\n+  if (depth >= maxDepth) {\n+    throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+  }\n+  \n+  if (obj == null || typeof obj !== 'object') {\n+    return false;\n+  }\n+  \n+  if (hasDollarKeys(obj)) {\n+    return true;\n+  }\n+  \n+  if (Array.isArray(obj)) {\n+    // Check each element in the array\n+    for (const item of obj) {\n+      if (item != null && typeof item === 'object') {\n+        // Check depth before recursing\n+        if (depth + 1 >= maxDepth) {\n+          throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+        }\n+        if (hasNestedDollarKeys(item, depth + 1, maxDepth)) {\n+          return true;\n+        }\n+      }\n+    }\n+  } else {\n+    for (const key of Object.keys(obj)) {\n+      const value = obj[key];\n+      if (value != null && typeof value === 'object') {\n+        // Check depth before recursing\n+        if (depth + 1 >= maxDepth) {\n+          throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+        }\n+        if (hasNestedDollarKeys(value, depth + 1, maxDepth)) {\n+          return true;\n+        }\n+      }\n+    }\n+  }\n+  \n+  return false;\n+}\n+\n+/**\n+ * Sanitizes a filter object to prevent query selector injection attacks\n+ * \n+ * @param {Object} filter - The filter object to sanitize\n+ * @param {Number} [depth=0] - Current recursion depth\n+ * @param {Object} [options] - Options for sanitization\n+ * @param {Number} [options.maxDepth=DEFAULT_MAX_DEPTH] - Maximum allowed recursion depth\n+ * @return {Object} - The sanitized filter object\n+ * @throws {MongooseError} - If maximum recursion depth is exceeded\n+ */\n+function sanitizeFilter(filter, depth = 0, options = {}) {\n+  const maxDepth = options.maxDepth || DEFAULT_MAX_DEPTH;\n+  \n+  // If we're at the top level, check the total nesting depth of the object\n+  if (depth === 0) {\n+    const totalDepth = calculateMaxDepth(filter);\n+    if (totalDepth > maxDepth) {\n+      throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+    }\n+  }\n+  \n+  // Strict check to ensure we don't exceed the depth limit\n+  if (depth >= maxDepth) {\n+    throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+  }\n+  \n+  if (filter == null || typeof filter !== 'object') {\n+    return filter;\n+  }\n+  \n+  // Track the current path depth for more accurate depth checking\n+  const currentDepth = depth;\n+  \n+  if (Array.isArray(filter)) {\n+    // Check each element in the array without exceeding depth limit\n+    for (let i = 0; i < filter.length; i++) {\n+      // Check depth before recursing\n+      if (currentDepth + 1 >= maxDepth) {\n+        throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+      }\n+      filter[i] = sanitizeFilter(filter[i], currentDepth + 1, options);\n+    }\n+    return filter;\n+  }\n+\n+  const filterKeys = Object.keys(filter);\n+  for (const key of filterKeys) {\n+    const value = filter[key];\n+    \n+    // Skip trusted values\n+    if (value != null && value[trustedSymbol]) {\n+      continue;\n+    }\n+    \n+    // Handle $and/$or operators\n+    if (key === '$and' || key === '$or') {\n+      if (!Array.isArray(value)) {\n+        // If $and/$or value is not an array, wrap it in $eq\n+        filter[key] = { $eq: value };\n+        continue;\n+      }\n+      \n+      // Check depth before processing $and/$or arrays\n+      if (currentDepth + 1 >= maxDepth) {\n+        throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+      }\n+      \n+      sanitizeFilter(value, currentDepth + 1, options);\n+      continue;\n+    }\n+\n+    // Handle values with MongoDB operators\n+    if (hasDollarKeys(value)) {\n+      const keys = Object.keys(value);\n+      if (keys.length === 1 && keys[0] === '$eq') {\n+        continue;\n+      }\n+      filter[key] = { $eq: filter[key] };\n+    } \n+    // Handle nested objects\n+    else if (value != null && typeof value === 'object' && !Array.isArray(value)) {\n+      // Check depth before recursively processing nested objects\n+      if (currentDepth + 1 >= maxDepth) {\n+        // If we would exceed the depth limit, wrap the value in $eq instead of recursing\n+        filter[key] = { $eq: value };\n+        continue;\n+      }\n+      \n+      // Recursively check nested objects for MongoDB operators\n+      sanitizeFilter(value, currentDepth + 1, options);\n+      \n+      // After recursively sanitizing, check if the nested object or any of its nested objects\n+      // have MongoDB operators. This handles cases like { field: { nested: { $ne: null } } }\n+      try {\n+        if (hasNestedDollarKeys(value, currentDepth + 1, maxDepth)) {\n+          filter[key] = { $eq: value };\n+        }\n+      } catch (error) {\n+        // If we hit the depth limit during the check, wrap the value in $eq\n+        if (error.message.includes('maximum filter nesting depth')) {\n+          filter[key] = { $eq: value };\n+        } else {\n+          throw error;\n+        }\n+      }\n+    }\n+  }\n+\n+  return filter;\n+}\n+\n+module.exports = sanitizeFilter;\n\\ No newline at end of file\ndiff --git a/lib/helpers/query/sanitizeFilter.js b/lib/helpers/query/sanitizeFilter.js\nindex a5f9544..6b75760 100644\n--- a/lib/helpers/query/sanitizeFilter.js\n+++ b/lib/helpers/query/sanitizeFilter.js\n@@ -7,6 +7,39 @@ const MongooseError = require('../../error/mongooseError');\n // Default maximum depth for recursive sanitization\n const DEFAULT_MAX_DEPTH = 10;\n \n+/**\n+ * Calculate the maximum nesting depth of an object\n+ * \n+ * @param {Object} obj - The object to check\n+ * @return {Number} - The maximum nesting depth\n+ */\n+function calculateMaxDepth(obj) {\n+  if (obj == null || typeof obj !== 'object') {\n+    return 0;\n+  }\n+  \n+  let maxDepth = 1;\n+  \n+  if (Array.isArray(obj)) {\n+    for (const item of obj) {\n+      if (item != null && typeof item === 'object') {\n+        const depth = 1 + calculateMaxDepth(item);\n+        maxDepth = Math.max(maxDepth, depth);\n+      }\n+    }\n+  } else {\n+    for (const key of Object.keys(obj)) {\n+      const value = obj[key];\n+      if (value != null && typeof value === 'object') {\n+        const depth = 1 + calculateMaxDepth(value);\n+        maxDepth = Math.max(maxDepth, depth);\n+      }\n+    }\n+  }\n+  \n+  return maxDepth;\n+}\n+\n /**\n  * Recursively checks if an object or any of its nested objects contain MongoDB operators (keys starting with $)\n  * \n@@ -17,7 +50,8 @@ const DEFAULT_MAX_DEPTH = 10;\n  * @throws {MongooseError} - If maximum recursion depth is exceeded\n  */\n function hasNestedDollarKeys(obj, depth = 0, maxDepth = DEFAULT_MAX_DEPTH) {\n-  if (depth > maxDepth) {\n+  // Strict check to ensure we don't exceed the depth limit\n+  if (depth >= maxDepth) {\n     throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n   }\n   \n@@ -29,11 +63,30 @@ function hasNestedDollarKeys(obj, depth = 0, maxDepth = DEFAULT_MAX_DEPTH) {\n     return true;\n   }\n   \n-  if (!Array.isArray(obj)) {\n+  if (Array.isArray(obj)) {\n+    // Check each element in the array\n+    for (const item of obj) {\n+      if (item != null && typeof item === 'object') {\n+        // Check depth before recursing\n+        if (depth + 1 >= maxDepth) {\n+          throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+        }\n+        if (hasNestedDollarKeys(item, depth + 1, maxDepth)) {\n+          return true;\n+        }\n+      }\n+    }\n+  } else {\n     for (const key of Object.keys(obj)) {\n       const value = obj[key];\n-      if (value != null && typeof value === 'object' && hasNestedDollarKeys(value, depth + 1, maxDepth)) {\n-        return true;\n+      if (value != null && typeof value === 'object') {\n+        // Check depth before recursing\n+        if (depth + 1 >= maxDepth) {\n+          throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+        }\n+        if (hasNestedDollarKeys(value, depth + 1, maxDepth)) {\n+          return true;\n+        }\n       }\n     }\n   }\n@@ -51,10 +104,19 @@ function hasNestedDollarKeys(obj, depth = 0, maxDepth = DEFAULT_MAX_DEPTH) {\n  * @return {Object} - The sanitized filter object\n  * @throws {MongooseError} - If maximum recursion depth is exceeded\n  */\n-module.exports = function sanitizeFilter(filter, depth = 0, options = {}) {\n+function sanitizeFilter(filter, depth = 0, options = {}) {\n   const maxDepth = options.maxDepth || DEFAULT_MAX_DEPTH;\n   \n-  if (depth > maxDepth) {\n+  // If we're at the top level, check the total nesting depth of the object\n+  if (depth === 0) {\n+    const totalDepth = calculateMaxDepth(filter);\n+    if (totalDepth > maxDepth) {\n+      throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+    }\n+  }\n+  \n+  // Strict check to ensure we don't exceed the depth limit\n+  if (depth >= maxDepth) {\n     throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n   }\n   \n@@ -62,9 +124,17 @@ module.exports = function sanitizeFilter(filter, depth = 0, options = {}) {\n     return filter;\n   }\n   \n+  // Track the current path depth for more accurate depth checking\n+  const currentDepth = depth;\n+  \n   if (Array.isArray(filter)) {\n-    for (const subfilter of filter) {\n-      sanitizeFilter(subfilter, depth + 1, options);\n+    // Check each element in the array without exceeding depth limit\n+    for (let i = 0; i < filter.length; i++) {\n+      // Check depth before recursing\n+      if (currentDepth + 1 >= maxDepth) {\n+        throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+      }\n+      filter[i] = sanitizeFilter(filter[i], currentDepth + 1, options);\n     }\n     return filter;\n   }\n@@ -72,28 +142,53 @@ module.exports = function sanitizeFilter(filter, depth = 0, options = {}) {\n   const filterKeys = Object.keys(filter);\n   for (const key of filterKeys) {\n     const value = filter[key];\n+    \n+    // Skip trusted values\n     if (value != null && value[trustedSymbol]) {\n       continue;\n     }\n+    \n+    // Handle $and/$or operators\n     if (key === '$and' || key === '$or') {\n-      sanitizeFilter(value, depth + 1, options);\n+      if (!Array.isArray(value)) {\n+        // If $and/$or value is not an array, wrap it in $eq\n+        filter[key] = { $eq: value };\n+        continue;\n+      }\n+      \n+      // Check depth before processing $and/$or arrays\n+      if (currentDepth + 1 >= maxDepth) {\n+        throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+      }\n+      \n+      sanitizeFilter(value, currentDepth + 1, options);\n       continue;\n     }\n \n+    // Handle values with MongoDB operators\n     if (hasDollarKeys(value)) {\n       const keys = Object.keys(value);\n       if (keys.length === 1 && keys[0] === '$eq') {\n         continue;\n       }\n       filter[key] = { $eq: filter[key] };\n-    } else if (value != null && typeof value === 'object' && !Array.isArray(value)) {\n+    } \n+    // Handle nested objects\n+    else if (value != null && typeof value === 'object' && !Array.isArray(value)) {\n+      // Check depth before recursively processing nested objects\n+      if (currentDepth + 1 >= maxDepth) {\n+        // If we would exceed the depth limit, wrap the value in $eq instead of recursing\n+        filter[key] = { $eq: value };\n+        continue;\n+      }\n+      \n       // Recursively check nested objects for MongoDB operators\n-      sanitizeFilter(value, depth + 1, options);\n+      sanitizeFilter(value, currentDepth + 1, options);\n       \n       // After recursively sanitizing, check if the nested object or any of its nested objects\n       // have MongoDB operators. This handles cases like { field: { nested: { $ne: null } } }\n       try {\n-        if (hasNestedDollarKeys(value, depth + 1, maxDepth)) {\n+        if (hasNestedDollarKeys(value, currentDepth + 1, maxDepth)) {\n           filter[key] = { $eq: value };\n         }\n       } catch (error) {\n@@ -108,4 +203,6 @@ module.exports = function sanitizeFilter(filter, depth = 0, options = {}) {\n   }\n \n   return filter;\n-};\n+}\n+\n+module.exports = sanitizeFilter;\n\\ No newline at end of file\ndiff --git a/new-sanitizeFilter.js b/new-sanitizeFilter.js\nnew file mode 100644\nindex 0000000..f0e6ef3\n--- /dev/null\n+++ b/new-sanitizeFilter.js\n@@ -0,0 +1,170 @@\n+'use strict';\n+\n+const hasDollarKeys = require('./hasDollarKeys');\n+const { trustedSymbol } = require('./trusted');\n+const MongooseError = require('../../error/mongooseError');\n+\n+// Default maximum depth for recursive sanitization\n+const DEFAULT_MAX_DEPTH = 10;\n+\n+// Track the current path depth for more accurate depth checking\n+let globalDepthCounter = 0;\n+\n+/**\n+ * Recursively checks if an object or any of its nested objects contain MongoDB operators (keys starting with $)\n+ * \n+ * @param {Object} obj - The object to check\n+ * @param {Number} [depth=0] - Current recursion depth\n+ * @param {Number} [maxDepth=DEFAULT_MAX_DEPTH] - Maximum allowed recursion depth\n+ * @return {Boolean} - True if the object or any nested object contains MongoDB operators\n+ * @throws {MongooseError} - If maximum recursion depth is exceeded\n+ */\n+function hasNestedDollarKeys(obj, depth = 0, maxDepth = DEFAULT_MAX_DEPTH) {\n+  // Strict check to ensure we don't exceed the depth limit\n+  if (depth >= maxDepth) {\n+    throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+  }\n+  \n+  if (obj == null || typeof obj !== 'object') {\n+    return false;\n+  }\n+  \n+  if (hasDollarKeys(obj)) {\n+    return true;\n+  }\n+  \n+  if (Array.isArray(obj)) {\n+    // Check each element in the array\n+    for (const item of obj) {\n+      if (item != null && typeof item === 'object') {\n+        // Check depth before recursing\n+        if (depth + 1 >= maxDepth) {\n+          throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+        }\n+        if (hasNestedDollarKeys(item, depth + 1, maxDepth)) {\n+          return true;\n+        }\n+      }\n+    }\n+  } else {\n+    for (const key of Object.keys(obj)) {\n+      const value = obj[key];\n+      if (value != null && typeof value === 'object') {\n+        // Check depth before recursing\n+        if (depth + 1 >= maxDepth) {\n+          throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+        }\n+        if (hasNestedDollarKeys(value, depth + 1, maxDepth)) {\n+          return true;\n+        }\n+      }\n+    }\n+  }\n+  \n+  return false;\n+}\n+\n+/**\n+ * Sanitizes a filter object to prevent query selector injection attacks\n+ * \n+ * @param {Object} filter - The filter object to sanitize\n+ * @param {Number} [depth=0] - Current recursion depth\n+ * @param {Object} [options] - Options for sanitization\n+ * @param {Number} [options.maxDepth=DEFAULT_MAX_DEPTH] - Maximum allowed recursion depth\n+ * @return {Object} - The sanitized filter object\n+ * @throws {MongooseError} - If maximum recursion depth is exceeded\n+ */\n+function sanitizeFilter(filter, depth = 0, options = {}) {\n+  const maxDepth = options.maxDepth || DEFAULT_MAX_DEPTH;\n+  \n+  // Strict check to ensure we don't exceed the depth limit\n+  if (depth >= maxDepth) {\n+    throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+  }\n+  \n+  if (filter == null || typeof filter !== 'object') {\n+    return filter;\n+  }\n+  \n+  // Track the current path depth for more accurate depth checking\n+  const currentDepth = depth;\n+  \n+  if (Array.isArray(filter)) {\n+    // Check each element in the array without exceeding depth limit\n+    for (let i = 0; i < filter.length; i++) {\n+      // Check depth before recursing\n+      if (currentDepth + 1 >= maxDepth) {\n+        throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+      }\n+      filter[i] = sanitizeFilter(filter[i], currentDepth + 1, options);\n+    }\n+    return filter;\n+  }\n+\n+  const filterKeys = Object.keys(filter);\n+  for (const key of filterKeys) {\n+    const value = filter[key];\n+    \n+    // Skip trusted values\n+    if (value != null && value[trustedSymbol]) {\n+      continue;\n+    }\n+    \n+    // Handle $and/$or operators\n+    if (key === '$and' || key === '$or') {\n+      if (!Array.isArray(value)) {\n+        // If $and/$or value is not an array, wrap it in $eq\n+        filter[key] = { $eq: value };\n+        continue;\n+      }\n+      \n+      // Check depth before processing $and/$or arrays\n+      if (currentDepth + 1 >= maxDepth) {\n+        throw new MongooseError(`Exceeded maximum filter nesting depth of ${maxDepth}. This may be a denial of service attack attempt.`);\n+      }\n+      \n+      sanitizeFilter(value, currentDepth + 1, options);\n+      continue;\n+    }\n+\n+    // Handle values with MongoDB operators\n+    if (hasDollarKeys(value)) {\n+      const keys = Object.keys(value);\n+      if (keys.length === 1 && keys[0] === '$eq') {\n+        continue;\n+      }\n+      filter[key] = { $eq: filter[key] };\n+    } \n+    // Handle nested objects\n+    else if (value != null && typeof value === 'object' && !Array.isArray(value)) {\n+      // Check depth before recursively processing nested objects\n+      if (currentDepth + 1 >= maxDepth) {\n+        // If we would exceed the depth limit, wrap the value in $eq instead of recursing\n+        filter[key] = { $eq: value };\n+        continue;\n+      }\n+      \n+      // Recursively check nested objects for MongoDB operators\n+      sanitizeFilter(value, currentDepth + 1, options);\n+      \n+      // After recursively sanitizing, check if the nested object or any of its nested objects\n+      // have MongoDB operators. This handles cases like { field: { nested: { $ne: null } } }\n+      try {\n+        if (hasNestedDollarKeys(value, currentDepth + 1, maxDepth)) {\n+          filter[key] = { $eq: value };\n+        }\n+      } catch (error) {\n+        // If we hit the depth limit during the check, wrap the value in $eq\n+        if (error.message.includes('maximum filter nesting depth')) {\n+          filter[key] = { $eq: value };\n+        } else {\n+          throw error;\n+        }\n+      }\n+    }\n+  }\n+\n+  return filter;\n+}\n+\n+module.exports = sanitizeFilter;\n\\ No newline at end of file"},{"message":"Fix the security vulnerability in QueryCursor.prototype.map where the function parameter is directly added to _transforms without validation (line 194). This could allow an attacker to inject malicious code that would be executed for each document processed by the cursor. Implement a validation mechanism that ensures only safe transform functions can be added to the _transforms array.","diff":"diff --git a/lib/helpers/validateTransformFunction.js b/lib/helpers/validateTransformFunction.js\nindex fee9e9b..a37614e 100644\n--- a/lib/helpers/validateTransformFunction.js\n+++ b/lib/helpers/validateTransformFunction.js\n@@ -23,12 +23,39 @@ function validateTransformFunction(fn) {\n   }\n   \n   // Reject functions with potentially dangerous code patterns\n-  // This is a basic check and could be expanded\n-  if (\n-    fnString.includes('constructor') || \n-    fnString.includes('__proto__') || \n-    fnString.includes('prototype')\n-  ) {\n+  const dangerousPatterns = [\n+    'constructor',\n+    '__proto__',\n+    'prototype',\n+    'eval(',\n+    'new Function',\n+    'setTimeout',\n+    'setInterval',\n+    'setImmediate',\n+    'process',\n+    'child_process',\n+    'global',\n+    'globalThis',\n+    'require(',\n+    'import(',\n+    'document.',\n+    'window.',\n+    'localStorage',\n+    'sessionStorage',\n+    'indexedDB',\n+    'fetch(',\n+    'XMLHttpRequest'\n+  ];\n+  \n+  // Check for dangerous patterns in the function string\n+  for (const pattern of dangerousPatterns) {\n+    if (fnString.includes(pattern)) {\n+      return false;\n+    }\n+  }\n+  \n+  // Check for Function constructor usage which can be used for eval-like behavior\n+  if (/Function\\s*\\(/.test(fnString)) {\n     return false;\n   }\n   "}]}]}