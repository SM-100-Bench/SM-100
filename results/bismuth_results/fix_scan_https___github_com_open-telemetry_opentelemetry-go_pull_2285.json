{"scanned_subsystems":[{"name":"Semantic Conventions","files":["semconv/v1.4.0/doc.go","semconv/v1.4.0/exception.go","semconv/v1.4.0/http.go","semconv/v1.4.0/resource.go","semconv/v1.4.0/schema.go","semconv/v1.4.0/trace.go"]}],"changesets":[{"title":"Fix IPv6 Address Parsing in NetAttributesFromHTTPRequest","body":"## Description\nThis pull request addresses a critical bug in the IPv6 address parsing logic within the `NetAttributesFromHTTPRequest` function in the Semantic Conventions subsystem.\n\n### Problem\nThe previous implementation used `strings.LastIndex` to parse IP addresses and ports, which fails for IPv6 addresses. This approach does not correctly handle IPv6 addresses that contain colons as part of their format.\n\n### Solution\n- Replaced the manual parsing with `net.SplitHostPort()` for robust handling of both IPv4 and IPv6 addresses\n- Added comprehensive test cases to verify parsing for:\n  - IPv6 addresses with ports (e.g., `[2001:db8::1]:8080`)\n  - IPv6 addresses without ports\n  - IPv4 addresses with ports\n  - IPv4 addresses without ports\n\n### Changes\n- Updated `http.go` to use `net.SplitHostPort()` for more reliable address parsing\n- Added `ipv6_test.go` with test cases to validate the new implementation\n\n### Benefits\n- Improved compatibility with different IP address formats\n- More robust handling of network address parsing\n- Prevents potential errors in network-related attribute generation\n\nFixes parsing of IP addresses in network semantic conventions.","commits":[{"message":"Fix the IPv6 address parsing bug in NetAttributesFromHTTPRequest function. The current implementation incorrectly handles IPv6 addresses in RemoteAddr by using strings.LastIndex to find the last colon, which doesn't work for IPv6 addresses that contain colons as part of their format. Implement a proper solution that correctly handles both IPv4 and IPv6 addresses with ports (e.g., \"192.168.1.1:8080\" and \"[2001:db8::1]:8080\").","diff":"diff --git a/semconv/v1.4.0/http.go b/semconv/v1.4.0/http.go\nindex f7157c6..284f106 100644\n--- a/semconv/v1.4.0/http.go\n+++ b/semconv/v1.4.0/http.go\n@@ -53,25 +53,34 @@ func NetAttributesFromHTTPRequest(network string, request *http.Request) []attri\n \n \tpeerName, peerIP, peerPort := \"\", \"\", 0\n \t{\n-\t\thostPart := request.RemoteAddr\n-\t\tportPart := \"\"\n-\t\tif idx := strings.LastIndex(hostPart, \":\"); idx >= 0 {\n-\t\t\thostPart = request.RemoteAddr[:idx]\n-\t\t\tportPart = request.RemoteAddr[idx+1:]\n-\t\t}\n-\t\tif hostPart != \"\" {\n-\t\t\tif ip := net.ParseIP(hostPart); ip != nil {\n-\t\t\t\tpeerIP = ip.String()\n+\t\tif request.RemoteAddr != \"\" {\n+\t\t\thostPart, portPart, err := net.SplitHostPort(request.RemoteAddr)\n+\t\t\tif err == nil {\n+\t\t\t\t// Only set peer port if we have a non-empty host part\n+\t\t\t\t// This maintains compatibility with the original behavior\n+\t\t\t\tif hostPart != \"\" {\n+\t\t\t\t\tif ip := net.ParseIP(hostPart); ip != nil {\n+\t\t\t\t\t\tpeerIP = ip.String()\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tpeerName = hostPart\n+\t\t\t\t\t}\n+\t\t\t\t\t\n+\t\t\t\t\tif portPart != \"\" {\n+\t\t\t\t\t\tnumPort, err := strconv.ParseUint(portPart, 10, 16)\n+\t\t\t\t\t\tif err == nil {\n+\t\t\t\t\t\t\tpeerPort = (int)(numPort)\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tpeerName, peerIP = \"\", \"\"\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t} else {\n-\t\t\t\tpeerName = hostPart\n-\t\t\t}\n-\n-\t\t\tif portPart != \"\" {\n-\t\t\t\tnumPort, err := strconv.ParseUint(portPart, 10, 16)\n-\t\t\t\tif err == nil {\n-\t\t\t\t\tpeerPort = (int)(numPort)\n+\t\t\t\t// If SplitHostPort fails, assume the RemoteAddr is just a host without a port\n+\t\t\t\thostPart = request.RemoteAddr\n+\t\t\t\tif ip := net.ParseIP(hostPart); ip != nil {\n+\t\t\t\t\tpeerIP = ip.String()\n \t\t\t\t} else {\n-\t\t\t\t\tpeerName, peerIP = \"\", \"\"\n+\t\t\t\t\tpeerName = hostPart\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -88,17 +97,21 @@ func NetAttributesFromHTTPRequest(network string, request *http.Request) []attri\n \n \thostIP, hostName, hostPort := \"\", \"\", 0\n \tfor _, someHost := range []string{request.Host, request.Header.Get(\"Host\"), request.URL.Host} {\n-\t\thostPart := \"\"\n-\t\tif idx := strings.LastIndex(someHost, \":\"); idx >= 0 {\n-\t\t\tstrPort := someHost[idx+1:]\n-\t\t\tnumPort, err := strconv.ParseUint(strPort, 10, 16)\n+\t\tif someHost == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\t\n+\t\thostPart, portPart, err := net.SplitHostPort(someHost)\n+\t\tif err != nil {\n+\t\t\t// If SplitHostPort fails, assume the host doesn't have a port\n+\t\t\thostPart = someHost\n+\t\t} else if portPart != \"\" {\n+\t\t\tnumPort, err := strconv.ParseUint(portPart, 10, 16)\n \t\t\tif err == nil {\n \t\t\t\thostPort = (int)(numPort)\n \t\t\t}\n-\t\t\thostPart = someHost[:idx]\n-\t\t} else {\n-\t\t\thostPart = someHost\n \t\t}\n+\t\t\n \t\tif hostPart != \"\" {\n \t\t\tip := net.ParseIP(hostPart)\n \t\t\tif ip != nil {\ndiff --git a/semconv/v1.4.0/ipv6_test.go b/semconv/v1.4.0/ipv6_test.go\nnew file mode 100644\nindex 0000000..7c2300f\n--- /dev/null\n+++ b/semconv/v1.4.0/ipv6_test.go\n@@ -0,0 +1,80 @@\n+// Copyright The OpenTelemetry Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package semconv\n+\n+import (\n+\t\"net/http\"\n+\t\"net/url\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\n+\t\"go.opentelemetry.io/otel/attribute\"\n+)\n+\n+func TestIPv6AddressHandling(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tname       string\n+\t\tremoteAddr string\n+\t\texpected   []attribute.KeyValue\n+\t}{\n+\t\t{\n+\t\t\tname:       \"IPv6 with port\",\n+\t\t\tremoteAddr: \"[2001:db8::1]:8080\",\n+\t\t\texpected: []attribute.KeyValue{\n+\t\t\t\tattribute.String(\"net.transport\", \"ip_tcp\"),\n+\t\t\t\tattribute.String(\"net.peer.ip\", \"2001:db8::1\"),\n+\t\t\t\tattribute.Int(\"net.peer.port\", 8080),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"IPv6 without port\",\n+\t\t\tremoteAddr: \"2001:db8::1\",\n+\t\t\texpected: []attribute.KeyValue{\n+\t\t\t\tattribute.String(\"net.transport\", \"ip_tcp\"),\n+\t\t\t\tattribute.String(\"net.peer.ip\", \"2001:db8::1\"),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"IPv4 with port\",\n+\t\t\tremoteAddr: \"192.168.1.1:8080\",\n+\t\t\texpected: []attribute.KeyValue{\n+\t\t\t\tattribute.String(\"net.transport\", \"ip_tcp\"),\n+\t\t\t\tattribute.String(\"net.peer.ip\", \"192.168.1.1\"),\n+\t\t\t\tattribute.Int(\"net.peer.port\", 8080),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"IPv4 without port\",\n+\t\t\tremoteAddr: \"192.168.1.1\",\n+\t\t\texpected: []attribute.KeyValue{\n+\t\t\t\tattribute.String(\"net.transport\", \"ip_tcp\"),\n+\t\t\t\tattribute.String(\"net.peer.ip\", \"192.168.1.1\"),\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tr := &http.Request{\n+\t\t\t\tRemoteAddr: tc.remoteAddr,\n+\t\t\t\tURL:        &url.URL{},\n+\t\t\t\tHeader:     http.Header{},\n+\t\t\t}\n+\t\t\tgot := NetAttributesFromHTTPRequest(\"tcp\", r)\n+\t\t\tassert.ElementsMatch(t, tc.expected, got)\n+\t\t})\n+\t}\n+}\n\\ No newline at end of file"}]}]}