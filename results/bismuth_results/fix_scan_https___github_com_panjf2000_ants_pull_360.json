{"scanned_subsystems":[{"name":"Worker Implementation","files":["worker.go","worker_func.go","worker_func_generic.go","worker_loop_queue.go","worker_queue.go","worker_stack.go"]}],"changesets":[{"title":"Fix Worker Implementation Bugs: Worker Caching and Queue Reset","body":"## Bug Fixes in Worker Implementation Subsystem\n\nThis pull request addresses two critical bugs in the worker implementation:\n\n### 1. Worker Caching Before Panic Check\nIn the worker implementations (`worker.go`, `worker_func.go`, `worker_func_generic.go`), there was a critical bug where workers were being put back into the cache **before** checking for panics. This could potentially lead to corrupted workers being reused if a panic occurred.\n\n**Fix**: \n- Moved `w.pool.workerCache.Put(w)` to after the panic check in all three worker implementation files.\n- Ensures that only stable, non-panicking workers are returned to the cache.\n\n### 2. Worker Loop Queue Reset Issue\nIn `worker_loop_queue.go`, the `reset()` function was incorrectly setting the size to 0, which would make the queue unusable if reused.\n\n**Fix**:\n- Replaced `wq.size = 0` with preserving the original queue size\n- Reinitialize `wq.items` with the original size\n- Added `wq.isFull = false` to reset the full state of the queue\n\n### Impact\nThese fixes prevent potential worker corruption and ensure proper queue management, improving the reliability of the worker pool implementation.\n\n### Tested\n- Verified that workers are correctly handled during panic scenarios\n- Confirmed queue reset maintains its original capacity","commits":[{"message":"Fix the bug in the worker implementations (worker.go, worker_func.go, worker_func_generic.go) where the worker is put back into the cache before checking for panics. This could lead to corrupted workers being reused if a panic occurs. The fix should move the worker.pool.workerCache.Put(w) line to after the panic check in all three worker implementations.","diff":"diff --git a/worker.go b/worker.go\nindex 03b4bd7..4cf97ed 100644\n--- a/worker.go\n+++ b/worker.go\n@@ -54,7 +54,6 @@ func (w *goWorker) run() {\n \t\t\t\t\tclose(w.pool.allDone)\n \t\t\t\t})\n \t\t\t}\n-\t\t\tw.pool.workerCache.Put(w)\n \t\t\tif p := recover(); p != nil {\n \t\t\t\tif ph := w.pool.options.PanicHandler; ph != nil {\n \t\t\t\t\tph(p)\n@@ -62,6 +61,7 @@ func (w *goWorker) run() {\n \t\t\t\t\tw.pool.options.Logger.Printf(\"worker exits from panic: %v\\n%s\\n\", p, debug.Stack())\n \t\t\t\t}\n \t\t\t}\n+\t\t\tw.pool.workerCache.Put(w)\n \t\t\t// Call Signal() here in case there are goroutines waiting for available workers.\n \t\t\tw.pool.cond.Signal()\n \t\t}()\ndiff --git a/worker_func.go b/worker_func.go\nindex 8437e40..c157b4e 100644\n--- a/worker_func.go\n+++ b/worker_func.go\n@@ -54,7 +54,6 @@ func (w *goWorkerWithFunc) run() {\n \t\t\t\t\tclose(w.pool.allDone)\n \t\t\t\t})\n \t\t\t}\n-\t\t\tw.pool.workerCache.Put(w)\n \t\t\tif p := recover(); p != nil {\n \t\t\t\tif ph := w.pool.options.PanicHandler; ph != nil {\n \t\t\t\t\tph(p)\n@@ -62,6 +61,7 @@ func (w *goWorkerWithFunc) run() {\n \t\t\t\t\tw.pool.options.Logger.Printf(\"worker exits from panic: %v\\n%s\\n\", p, debug.Stack())\n \t\t\t\t}\n \t\t\t}\n+\t\t\tw.pool.workerCache.Put(w)\n \t\t\t// Call Signal() here in case there are goroutines waiting for available workers.\n \t\t\tw.pool.cond.Signal()\n \t\t}()\ndiff --git a/worker_func_generic.go b/worker_func_generic.go\nindex a76d109..0a3c1ba 100644\n--- a/worker_func_generic.go\n+++ b/worker_func_generic.go\n@@ -57,7 +57,6 @@ func (w *goWorkerWithFuncGeneric[T]) run() {\n \t\t\t\t\tclose(w.pool.allDone)\n \t\t\t\t})\n \t\t\t}\n-\t\t\tw.pool.workerCache.Put(w)\n \t\t\tif p := recover(); p != nil {\n \t\t\t\tif ph := w.pool.options.PanicHandler; ph != nil {\n \t\t\t\t\tph(p)\n@@ -65,6 +64,7 @@ func (w *goWorkerWithFuncGeneric[T]) run() {\n \t\t\t\t\tw.pool.options.Logger.Printf(\"worker exits from panic: %v\\n%s\\n\", p, debug.Stack())\n \t\t\t\t}\n \t\t\t}\n+\t\t\tw.pool.workerCache.Put(w)\n \t\t\t// Call Signal() here in case there are goroutines waiting for available workers.\n \t\t\tw.pool.cond.Signal()\n \t\t}()"},{"message":"Fix the bug in worker_loop_queue.go where the reset() function sets the size field to 0, which would make the queue unusable if it's reused after reset. The fix should preserve the original size of the queue during reset, similar to how the workerStack implementation handles it.","diff":"diff --git a/worker_loop_queue.go b/worker_loop_queue.go\nindex b372983..73137ab 100644\n--- a/worker_loop_queue.go\n+++ b/worker_loop_queue.go\n@@ -170,8 +170,8 @@ retry:\n \t\tw.finish()\n \t\tgoto retry\n \t}\n-\twq.items = wq.items[:0]\n-\twq.size = 0\n+\twq.items = make([]worker, wq.size)\n \twq.head = 0\n \twq.tail = 0\n+\twq.isFull = false\n }"}]}]}