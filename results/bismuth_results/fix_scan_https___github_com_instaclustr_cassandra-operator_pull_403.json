{"scanned_subsystems":[{"name":"Cassandra Datacenter Controller","files":["pkg/common/cluster/utils.go","pkg/common/nodestate/nodestate.go","pkg/controller/cassandradatacenter/cassandradatacenter_controller.go","pkg/controller/cassandradatacenter/configmap.go","pkg/controller/cassandradatacenter/errors.go","pkg/controller/cassandradatacenter/finalizers.go","pkg/controller/cassandradatacenter/helpers.go","pkg/controller/cassandradatacenter/metadata.go","pkg/controller/cassandradatacenter/ports.go","pkg/controller/cassandradatacenter/services.go","pkg/controller/cassandradatacenter/statefulset.go"]}],"changesets":[{"title":"Bismuth: fix 10 bugs in Cassandra Datacenter Controller","body":"Fixes:\n- Fix the remove function in pkg/controller/cassandradatacenter/helpers.go to safely handle duplicate elements in the list. The current implementation modifies the list while iterating over it, which can lead to skipping elements or index out of range errors. The function should either break after removing the first occurrence or use a safer approach to remove all occurrences.\n- Fix the getPVCs function in pkg/controller/cassandradatacenter/finalizers.go to safely handle the case where the filterFn pointer is non-nil but points to a nil function. Currently, it checks if the pointer is nil at line 47, but then directly dereferences it at line 54 without checking if the function itself is nil, which could lead to a nil pointer dereference.\n- Fix the podWithMaxOrdinal function in pkg/controller/cassandradatacenter/statefulset.go to safely handle the case where the pods list is empty. Currently, it assumes there's at least one pod in the list and returns pods[maxIndex] without checking if the list is empty, which could cause a panic with index out of range error.\n- Fix the createOrUpdateSeedNodesService function in pkg/controller/cassandradatacenter/services.go to properly merge annotations instead of overwriting them. Currently, at line 112, it completely overwrites the annotations set at line 102, which means any annotations from SeedNodesAnnotations(rctx.cdc) will be lost and replaced with only the \"service.alpha.kubernetes.io/tolerate-unready-endpoints\" annotation.\n- Fix the typo in the success event message in createOrUpdateSeedNodesService function in pkg/controller/cassandradatacenter/services.go. Currently, it says 'Seed nodes sevice' instead of 'Seed nodes service' at line 138, which could cause issues with logging or monitoring.\n- Fix the typo in the error message in scaleStatefulSet function in pkg/controller/cassandradatacenter/statefulset.go. Currently, at line 566, it says 'Unable to decommission a node as than one Cassandra node is already decommissioned.' It should be 'as more than one'. This could cause confusion for users trying to understand error messages.\n- Fix the sortStatefulSetsAscending and sortStatefulSetsDescending functions in pkg/controller/cassandradatacenter/helpers.go to sort by Spec.Replicas instead of Status.Replicas. Currently, they sort by Status.Replicas which could lead to unexpected sorting if StatefulSets are in the process of scaling, as Status.Replicas reflects the current state while Spec.Replicas reflects the desired state.\n- Fix the newSysctlLimitsContainer function in pkg/controller/cassandradatacenter/statefulset.go to use a specific version tag for the busybox image instead of 'latest'. Currently, it uses 'busybox:latest' as the default image if no InitImage is specified, which can lead to unexpected behavior if the image changes. Use a specific version like 'busybox:1.33.1' to ensure consistent behavior.\n- Fix the youngGen function in pkg/controller/cassandradatacenter/configmap.go to dynamically determine the number of available CPU cores instead of using a hardcoded value of 4. This hardcoded value could be inaccurate for different environments, leading to suboptimal JVM tuning. Use runtime.NumCPU() or a similar approach to get the actual number of cores available to the container.\n- Fix the isCassandra4 function in pkg/controller/cassandradatacenter/configmap.go to handle different image naming formats. The current implementation assumes a specific format and checks if the last part of the image name (after splitting by \"/\") starts with \"cassandra-4\". This could lead to incorrect results if the image name doesn't follow the expected pattern. Implement a more robust approach that can handle various image naming conventions.","commits":[{"message":"Fix the remove function in pkg/controller/cassandradatacenter/helpers.go to safely handle duplicate elements in the list. The current implementation modifies the list while iterating over it, which can lead to skipping elements or index out of range errors. The function should either break after removing the first occurrence or use a safer approach to remove all occurrences.","diff":"diff --git a/pkg/controller/cassandradatacenter/helpers.go b/pkg/controller/cassandradatacenter/helpers.go\nindex fd56570..210c72b 100644\n--- a/pkg/controller/cassandradatacenter/helpers.go\n+++ b/pkg/controller/cassandradatacenter/helpers.go\n@@ -122,10 +122,15 @@ func contains(list []string, s string) bool {\n }\n \n func remove(list []string, s string) []string {\n-\tfor i, v := range list {\n-\t\tif v == s {\n-\t\t\tlist = append(list[:i], list[i+1:]...)\n+\t// Create a new slice to hold the result\n+\tresult := make([]string, 0, len(list))\n+\t\n+\t// Add all elements except those matching s\n+\tfor _, v := range list {\n+\t\tif v != s {\n+\t\t\tresult = append(result, v)\n \t\t}\n \t}\n-\treturn list\n+\t\n+\treturn result\n }\ndiff --git a/pkg/controller/cassandradatacenter/helpers_test.go b/pkg/controller/cassandradatacenter/helpers_test.go\nnew file mode 100644\nindex 0000000..07ae5bd\n--- /dev/null\n+++ b/pkg/controller/cassandradatacenter/helpers_test.go\n@@ -0,0 +1,55 @@\n+package cassandradatacenter\n+\n+import (\n+\t\"reflect\"\n+\t\"testing\"\n+)\n+\n+func TestRemove(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\tlist     []string\n+\t\ttoRemove string\n+\t\texpected []string\n+\t}{\n+\t\t{\n+\t\t\tname:     \"Remove single occurrence\",\n+\t\t\tlist:     []string{\"a\", \"b\", \"c\"},\n+\t\t\ttoRemove: \"b\",\n+\t\t\texpected: []string{\"a\", \"c\"},\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Remove multiple occurrences\",\n+\t\t\tlist:     []string{\"a\", \"b\", \"b\", \"c\", \"b\"},\n+\t\t\ttoRemove: \"b\",\n+\t\t\texpected: []string{\"a\", \"c\"},\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Remove non-existent element\",\n+\t\t\tlist:     []string{\"a\", \"b\", \"c\"},\n+\t\t\ttoRemove: \"d\",\n+\t\t\texpected: []string{\"a\", \"b\", \"c\"},\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Remove from empty list\",\n+\t\t\tlist:     []string{},\n+\t\t\ttoRemove: \"a\",\n+\t\t\texpected: []string{},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresult := remove(tt.list, tt.toRemove)\n+\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n+\t\t\t\tt.Errorf(\"remove() = %v, want %v\", result, tt.expected)\n+\t\t\t}\n+\t\t\t\n+\t\t\t// Ensure the original list is not modified (this is important for the old implementation)\n+\t\t\t// but our new implementation doesn't modify the original list anyway\n+\t\t\tif len(tt.list) > 0 && len(result) > 0 && &tt.list[0] == &result[0] {\n+\t\t\t\tt.Errorf(\"remove() modified the original list, which could cause issues\")\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n\\ No newline at end of file"},{"message":"Fix the getPVCs function in pkg/controller/cassandradatacenter/finalizers.go to safely handle the case where the filterFn pointer is non-nil but points to a nil function. Currently, it checks if the pointer is nil at line 47, but then directly dereferences it at line 54 without checking if the function itself is nil, which could lead to a nil pointer dereference.","diff":"diff --git a/pkg/controller/cassandradatacenter/finalizers.go b/pkg/controller/cassandradatacenter/finalizers.go\nindex 88e3e35..2c329a8 100644\n--- a/pkg/controller/cassandradatacenter/finalizers.go\n+++ b/pkg/controller/cassandradatacenter/finalizers.go\n@@ -51,8 +51,11 @@ func (r *ReconcileCassandraDataCenter) getPVCs(\n \n \t\tvar filterPVCs []corev1.PersistentVolumeClaim\n \n+\t\t// Check if the function pointer is non-nil and the function itself is not nil\n+\t\t// before attempting to call it\n \t\tfor _, pvc := range pvcList.Items {\n-\t\t\tif (*filterFn)(pvc) {\n+\t\t\t// Use a nil-safe way to call the function\n+\t\t\tif filterFn != nil && *filterFn != nil && (*filterFn)(pvc) {\n \t\t\t\tfilterPVCs = append(filterPVCs, pvc)\n \t\t\t}\n \t\t}\ndiff --git a/pkg/controller/cassandradatacenter/finalizers_test.go b/pkg/controller/cassandradatacenter/finalizers_test.go\nnew file mode 100644\nindex 0000000..8dc79b8\n--- /dev/null\n+++ b/pkg/controller/cassandradatacenter/finalizers_test.go\n@@ -0,0 +1,102 @@\n+package cassandradatacenter\n+\n+import (\n+\t\"testing\"\n+\n+\tcassandraoperatorv1alpha1 \"github.com/instaclustr/cassandra-operator/pkg/apis/cassandraoperator/v1alpha1\"\n+\t\"github.com/stretchr/testify/assert\"\n+\tcorev1 \"k8s.io/api/core/v1\"\n+\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n+\t\"k8s.io/apimachinery/pkg/runtime\"\n+\t\"sigs.k8s.io/controller-runtime/pkg/client/fake\"\n+)\n+\n+func TestGetPVCs(t *testing.T) {\n+\t// Create a fake client\n+\tscheme := runtime.NewScheme()\n+\t_ = corev1.AddToScheme(scheme)\n+\t// Register the CassandraDataCenter type with the scheme\n+\t_ = cassandraoperatorv1alpha1.SchemeBuilder.AddToScheme(scheme)\n+\n+\t// Create test PVCs\n+\tpvc1 := &corev1.PersistentVolumeClaim{\n+\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\tName:      \"pvc-1\",\n+\t\t\tNamespace: \"test-namespace\",\n+\t\t\tLabels: map[string]string{\n+\t\t\t\t\"cassandra-operator.instaclustr.com/datacenter\": \"test-dc\",\n+\t\t\t\t\"cassandra-operator.instaclustr.com/cluster\":    \"test-cluster\",\n+\t\t\t},\n+\t\t},\n+\t}\n+\tpvc2 := &corev1.PersistentVolumeClaim{\n+\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\tName:      \"pvc-2\",\n+\t\t\tNamespace: \"test-namespace\",\n+\t\t\tLabels: map[string]string{\n+\t\t\t\t\"cassandra-operator.instaclustr.com/datacenter\": \"test-dc\",\n+\t\t\t\t\"cassandra-operator.instaclustr.com/cluster\":    \"test-cluster\",\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// Create a test instance\n+\tinstance := &cassandraoperatorv1alpha1.CassandraDataCenter{\n+\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\tName:      \"test-dc\",\n+\t\t\tNamespace: \"test-namespace\",\n+\t\t},\n+\t\tCluster:    \"test-cluster\",\n+\t\tDataCenter: \"test-dc\",\n+\t}\n+\n+\t// Test cases\n+\ttests := []struct {\n+\t\tname     string\n+\t\tfilterFn *pvcFilterFunc\n+\t\texpected int\n+\t}{\n+\t\t{\n+\t\t\tname:     \"nil filter function pointer\",\n+\t\t\tfilterFn: nil,\n+\t\t\texpected: 2,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"non-nil filter function pointer with valid function\",\n+\t\t\tfilterFn: func() *pvcFilterFunc {\n+\t\t\t\tfn := pvcFilterFunc(func(pvc corev1.PersistentVolumeClaim) bool {\n+\t\t\t\t\treturn pvc.Name == \"pvc-1\"\n+\t\t\t\t})\n+\t\t\t\treturn &fn\n+\t\t\t}(),\n+\t\t\texpected: 1,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"non-nil filter function pointer with nil function\",\n+\t\t\tfilterFn: func() *pvcFilterFunc {\n+\t\t\t\tvar nilFn pvcFilterFunc\n+\t\t\t\treturn &nilFn\n+\t\t\t}(),\n+\t\t\texpected: 0,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Create a new client for each test to ensure clean state\n+\t\t\tclient := fake.NewFakeClientWithScheme(scheme, pvc1, pvc2)\n+\t\t\t\n+\t\t\tr := &ReconcileCassandraDataCenter{\n+\t\t\t\tclient: client,\n+\t\t\t\tscheme: scheme,\n+\t\t\t}\n+\n+\t\t\t// Call the function\n+\t\t\tpvcs, err := r.getPVCs(instance, tt.filterFn)\n+\t\t\t\n+\t\t\t// Verify results\n+\t\t\tassert.NoError(t, err)\n+\t\t\tassert.Equal(t, tt.expected, len(pvcs), \"Expected %d PVCs, got %d\", tt.expected, len(pvcs))\n+\t\t})\n+\t}\n+}\n\\ No newline at end of file"},{"message":"Fix the podWithMaxOrdinal function in pkg/controller/cassandradatacenter/statefulset.go to safely handle the case where the pods list is empty. Currently, it assumes there's at least one pod in the list and returns pods[maxIndex] without checking if the list is empty, which could cause a panic with index out of range error.","diff":"diff --git a/pkg/controller/cassandradatacenter/statefulset.go b/pkg/controller/cassandradatacenter/statefulset.go\nindex 79d46ee..5e5009f 100644\n--- a/pkg/controller/cassandradatacenter/statefulset.go\n+++ b/pkg/controller/cassandradatacenter/statefulset.go\n@@ -572,9 +572,14 @@ func scaleStatefulSet(\n }\n \n func podWithMaxOrdinal(pods []corev1.Pod) corev1.Pod {\n+\t// Check if the pods list is empty to avoid index out of range panic\n+\tif len(pods) == 0 {\n+\t\treturn corev1.Pod{}\n+\t}\n+\t\n \tvar statefulPodRegex = regexp.MustCompile(\"(.*)-([0-9]+)$\")\n \tmaxOrdinal := -1\n-\tmaxIndex := len(pods) - 1\n+\tmaxIndex := 0 // Default to first pod instead of len(pods)-1 which could be -1 for empty list\n \tfor k, pod := range pods {\n \t\tordinal := -1\n \t\tsubMatches := statefulPodRegex.FindStringSubmatch(pod.Name)\ndiff --git a/pkg/controller/cassandradatacenter/statefulset_test.go b/pkg/controller/cassandradatacenter/statefulset_test.go\nnew file mode 100644\nindex 0000000..ac35b91\n--- /dev/null\n+++ b/pkg/controller/cassandradatacenter/statefulset_test.go\n@@ -0,0 +1,96 @@\n+package cassandradatacenter\n+\n+import (\n+\t\"testing\"\n+\n+\tcorev1 \"k8s.io/api/core/v1\"\n+\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n+)\n+\n+func TestPodWithMaxOrdinal(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\tpods     []corev1.Pod\n+\t\texpected string\n+\t}{\n+\t\t{\n+\t\t\tname: \"empty pod list\",\n+\t\t\tpods: []corev1.Pod{},\n+\t\t\t// Empty pod should have empty name\n+\t\t\texpected: \"\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"single pod\",\n+\t\t\tpods: []corev1.Pod{\n+\t\t\t\t{\n+\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\t\tName: \"cassandra-0\",\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: \"cassandra-0\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"multiple pods with different ordinals\",\n+\t\t\tpods: []corev1.Pod{\n+\t\t\t\t{\n+\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\t\tName: \"cassandra-0\",\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\t\tName: \"cassandra-2\",\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\t\tName: \"cassandra-1\",\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: \"cassandra-2\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"pod without ordinal\",\n+\t\t\tpods: []corev1.Pod{\n+\t\t\t\t{\n+\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\t\tName: \"cassandra-without-ordinal\",\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: \"cassandra-without-ordinal\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"mixed pods with and without ordinals\",\n+\t\t\tpods: []corev1.Pod{\n+\t\t\t\t{\n+\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\t\tName: \"cassandra-without-ordinal\",\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\t\tName: \"cassandra-5\",\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\t\tName: \"cassandra-10\",\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: \"cassandra-10\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresult := podWithMaxOrdinal(tt.pods)\n+\t\t\tif result.Name != tt.expected {\n+\t\t\t\tt.Errorf(\"podWithMaxOrdinal() = %v, want %v\", result.Name, tt.expected)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n\\ No newline at end of file"},{"message":"Fix the createOrUpdateSeedNodesService function in pkg/controller/cassandradatacenter/services.go to properly merge annotations instead of overwriting them. Currently, at line 112, it completely overwrites the annotations set at line 102, which means any annotations from SeedNodesAnnotations(rctx.cdc) will be lost and replaced with only the \"service.alpha.kubernetes.io/tolerate-unready-endpoints\" annotation.","diff":"diff --git a/pkg/controller/cassandradatacenter/services.go b/pkg/controller/cassandradatacenter/services.go\nindex e3afe43..eb3efc0 100644\n--- a/pkg/controller/cassandradatacenter/services.go\n+++ b/pkg/controller/cassandradatacenter/services.go\n@@ -110,9 +110,9 @@ func createOrUpdateSeedNodesService(rctx *reconciliationRequestContext) (*corev1\n \t\t\tPublishNotReadyAddresses: true,\n \t\t}\n \n-\t\tseedNodesService.Annotations = map[string]string{\n+\t\tseedNodesService.Annotations = mergeLabelMaps(seedNodesService.Annotations, map[string]string{\n \t\t\t\"service.alpha.kubernetes.io/tolerate-unready-endpoints\": \"true\",\n-\t\t}\n+\t\t})\n \n \t\tif err := controllerutil.SetControllerReference(rctx.cdc, seedNodesService, rctx.scheme); err != nil {\n \t\t\treturn err"},{"message":"Fix the typo in the success event message in createOrUpdateSeedNodesService function in pkg/controller/cassandradatacenter/services.go. Currently, it says 'Seed nodes sevice' instead of 'Seed nodes service' at line 138, which could cause issues with logging or monitoring.","diff":"diff --git a/pkg/controller/cassandradatacenter/services.go b/pkg/controller/cassandradatacenter/services.go\nindex eb3efc0..3d48af5 100644\n--- a/pkg/controller/cassandradatacenter/services.go\n+++ b/pkg/controller/cassandradatacenter/services.go\n@@ -136,7 +136,7 @@ func createOrUpdateSeedNodesService(rctx *reconciliationRequestContext) (*corev1\n \t\t\tseedNodesService,\n \t\t\tcorev1.EventTypeNormal,\n \t\t\t\"SuccessEvent\",\n-\t\t\tfmt.Sprintf(\"Seed nodes sevice %s %s.\", seedNodesService.Name, opresult))\n+\t\t\tfmt.Sprintf(\"Seed nodes service %s %s.\", seedNodesService.Name, opresult))\n \t}\n \n \treturn seedNodesService, err"},{"message":"Fix the typo in the error message in scaleStatefulSet function in pkg/controller/cassandradatacenter/statefulset.go. Currently, at line 566, it says 'Unable to decommission a node as than one Cassandra node is already decommissioned.' It should be 'as more than one'. This could cause confusion for users trying to understand error messages.","diff":"diff --git a/pkg/controller/cassandradatacenter/statefulset.go b/pkg/controller/cassandradatacenter/statefulset.go\nindex 5e5009f..b638a03 100644\n--- a/pkg/controller/cassandradatacenter/statefulset.go\n+++ b/pkg/controller/cassandradatacenter/statefulset.go\n@@ -564,7 +564,7 @@ func scaleStatefulSet(\n \t\t\t\trctx.cdc,\n \t\t\t\tcorev1.EventTypeWarning,\n \t\t\t\t\"FailureEvent\",\n-\t\t\t\tfmt.Sprintf(\"Unable to decommission a node as than one Cassandra node is already decommissioned.\"))\n+\t\t\t\tfmt.Sprintf(\"Unable to decommission a node as more than one Cassandra node is already decommissioned.\"))\n \t\t}\n \t}\n "},{"message":"Fix the sortStatefulSetsAscending and sortStatefulSetsDescending functions in pkg/controller/cassandradatacenter/helpers.go to sort by Spec.Replicas instead of Status.Replicas. Currently, they sort by Status.Replicas which could lead to unexpected sorting if StatefulSets are in the process of scaling, as Status.Replicas reflects the current state while Spec.Replicas reflects the desired state.","diff":"diff --git a/pkg/controller/cassandradatacenter/helpers.go b/pkg/controller/cassandradatacenter/helpers.go\nindex 210c72b..b1d3880 100644\n--- a/pkg/controller/cassandradatacenter/helpers.go\n+++ b/pkg/controller/cassandradatacenter/helpers.go\n@@ -16,7 +16,9 @@ import (\n func sortStatefulSetsAscending(sets []v1.StatefulSet) (s []v1.StatefulSet) {\n \t// Sort sets from lowest to highest numerically by the number of the nodes in the set\n \tsort.SliceStable(sets, func(i, j int) bool {\n-\t\treturn sets[i].Status.Replicas < sets[j].Status.Replicas\n+\t\t// Use Spec.Replicas instead of Status.Replicas for more predictable sorting\n+\t\t// when StatefulSets are in the process of scaling\n+\t\treturn *sets[i].Spec.Replicas < *sets[j].Spec.Replicas\n \t})\n \treturn sets\n }\n@@ -24,7 +26,9 @@ func sortStatefulSetsAscending(sets []v1.StatefulSet) (s []v1.StatefulSet) {\n func sortStatefulSetsDescending(sets []v1.StatefulSet) (s []v1.StatefulSet) {\n \t// Sort sets from highest to lowest numerically by the number of the nodes in the set\n \tsort.SliceStable(sets, func(i, j int) bool {\n-\t\treturn sets[i].Status.Replicas > sets[j].Status.Replicas\n+\t\t// Use Spec.Replicas instead of Status.Replicas for more predictable sorting\n+\t\t// when StatefulSets are in the process of scaling\n+\t\treturn *sets[i].Spec.Replicas > *sets[j].Spec.Replicas\n \t})\n \treturn sets\n }\ndiff --git a/pkg/controller/cassandradatacenter/sort_statefulsets_test.go b/pkg/controller/cassandradatacenter/sort_statefulsets_test.go\nnew file mode 100644\nindex 0000000..f75b376\n--- /dev/null\n+++ b/pkg/controller/cassandradatacenter/sort_statefulsets_test.go\n@@ -0,0 +1,96 @@\n+package cassandradatacenter\n+\n+import (\n+\t\"reflect\"\n+\t\"testing\"\n+\n+\tv1 \"k8s.io/api/apps/v1\"\n+\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n+)\n+\n+func TestSortStatefulSetsAscending(t *testing.T) {\n+\t// Create test StatefulSets with different Spec.Replicas values\n+\treplicas1 := int32(1)\n+\treplicas2 := int32(2)\n+\treplicas3 := int32(3)\n+\n+\t// Create StatefulSets with different Spec.Replicas but mixed Status.Replicas\n+\t// to verify we're sorting by Spec.Replicas\n+\tsts1 := v1.StatefulSet{\n+\t\tObjectMeta: metav1.ObjectMeta{Name: \"sts1\"},\n+\t\tSpec:       v1.StatefulSetSpec{Replicas: &replicas2}, // Spec: 2\n+\t\tStatus:     v1.StatefulSetStatus{Replicas: 3},        // Status: 3 (different from Spec)\n+\t}\n+\tsts2 := v1.StatefulSet{\n+\t\tObjectMeta: metav1.ObjectMeta{Name: \"sts2\"},\n+\t\tSpec:       v1.StatefulSetSpec{Replicas: &replicas1}, // Spec: 1\n+\t\tStatus:     v1.StatefulSetStatus{Replicas: 2},        // Status: 2 (different from Spec)\n+\t}\n+\tsts3 := v1.StatefulSet{\n+\t\tObjectMeta: metav1.ObjectMeta{Name: \"sts3\"},\n+\t\tSpec:       v1.StatefulSetSpec{Replicas: &replicas3}, // Spec: 3\n+\t\tStatus:     v1.StatefulSetStatus{Replicas: 1},        // Status: 1 (different from Spec)\n+\t}\n+\n+\t// Create a slice with the StatefulSets in random order\n+\tsets := []v1.StatefulSet{sts1, sts3, sts2}\n+\n+\t// Sort the slice using sortStatefulSetsAscending\n+\tsorted := sortStatefulSetsAscending(sets)\n+\n+\t// Expected order: sts2 (Spec.Replicas=1), sts1 (Spec.Replicas=2), sts3 (Spec.Replicas=3)\n+\texpected := []v1.StatefulSet{sts2, sts1, sts3}\n+\n+\t// Check if the sorted slice matches the expected order\n+\tif !reflect.DeepEqual(sorted, expected) {\n+\t\tt.Errorf(\"sortStatefulSetsAscending() = %v, want %v\", getNames(sorted), getNames(expected))\n+\t}\n+}\n+\n+func TestSortStatefulSetsDescending(t *testing.T) {\n+\t// Create test StatefulSets with different Spec.Replicas values\n+\treplicas1 := int32(1)\n+\treplicas2 := int32(2)\n+\treplicas3 := int32(3)\n+\n+\t// Create StatefulSets with different Spec.Replicas but mixed Status.Replicas\n+\t// to verify we're sorting by Spec.Replicas\n+\tsts1 := v1.StatefulSet{\n+\t\tObjectMeta: metav1.ObjectMeta{Name: \"sts1\"},\n+\t\tSpec:       v1.StatefulSetSpec{Replicas: &replicas2}, // Spec: 2\n+\t\tStatus:     v1.StatefulSetStatus{Replicas: 1},        // Status: 1 (different from Spec)\n+\t}\n+\tsts2 := v1.StatefulSet{\n+\t\tObjectMeta: metav1.ObjectMeta{Name: \"sts2\"},\n+\t\tSpec:       v1.StatefulSetSpec{Replicas: &replicas1}, // Spec: 1\n+\t\tStatus:     v1.StatefulSetStatus{Replicas: 3},        // Status: 3 (different from Spec)\n+\t}\n+\tsts3 := v1.StatefulSet{\n+\t\tObjectMeta: metav1.ObjectMeta{Name: \"sts3\"},\n+\t\tSpec:       v1.StatefulSetSpec{Replicas: &replicas3}, // Spec: 3\n+\t\tStatus:     v1.StatefulSetStatus{Replicas: 2},        // Status: 2 (different from Spec)\n+\t}\n+\n+\t// Create a slice with the StatefulSets in random order\n+\tsets := []v1.StatefulSet{sts1, sts2, sts3}\n+\n+\t// Sort the slice using sortStatefulSetsDescending\n+\tsorted := sortStatefulSetsDescending(sets)\n+\n+\t// Expected order: sts3 (Spec.Replicas=3), sts1 (Spec.Replicas=2), sts2 (Spec.Replicas=1)\n+\texpected := []v1.StatefulSet{sts3, sts1, sts2}\n+\n+\t// Check if the sorted slice matches the expected order\n+\tif !reflect.DeepEqual(sorted, expected) {\n+\t\tt.Errorf(\"sortStatefulSetsDescending() = %v, want %v\", getNames(sorted), getNames(expected))\n+\t}\n+}\n+\n+// Helper function to get the names of StatefulSets for better error messages\n+func getNames(sets []v1.StatefulSet) []string {\n+\tnames := make([]string, len(sets))\n+\tfor i, set := range sets {\n+\t\tnames[i] = set.Name\n+\t}\n+\treturn names\n+}\n\\ No newline at end of file"},{"message":"Fix the newSysctlLimitsContainer function in pkg/controller/cassandradatacenter/statefulset.go to use a specific version tag for the busybox image instead of 'latest'. Currently, it uses 'busybox:latest' as the default image if no InitImage is specified, which can lead to unexpected behavior if the image changes. Use a specific version like 'busybox:1.33.1' to ensure consistent behavior.","diff":"diff --git a/pkg/controller/cassandradatacenter/statefulset.go b/pkg/controller/cassandradatacenter/statefulset.go\nindex b638a03..f3b1bf1 100644\n--- a/pkg/controller/cassandradatacenter/statefulset.go\n+++ b/pkg/controller/cassandradatacenter/statefulset.go\n@@ -293,7 +293,7 @@ func newSidecarContainer(cdc *cassandraoperatorv1alpha1.CassandraDataCenter,\n \n func newSysctlLimitsContainer(cdc *cassandraoperatorv1alpha1.CassandraDataCenter) *corev1.Container {\n \n-\tvar image = \"busybox:latest\"\n+\tvar image = \"busybox:1.33.1\"\n \n \tif len(cdc.Spec.InitImage) != 0 {\n \t\timage = cdc.Spec.InitImage\ndiff --git a/pkg/controller/cassandradatacenter/sysctlcontainer_test.go b/pkg/controller/cassandradatacenter/sysctlcontainer_test.go\nnew file mode 100644\nindex 0000000..5324fda\n--- /dev/null\n+++ b/pkg/controller/cassandradatacenter/sysctlcontainer_test.go\n@@ -0,0 +1,48 @@\n+package cassandradatacenter\n+\n+import (\n+\t\"testing\"\n+\n+\tcassandraoperatorv1alpha1 \"github.com/instaclustr/cassandra-operator/pkg/apis/cassandraoperator/v1alpha1\"\n+\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n+)\n+\n+func TestNewSysctlLimitsContainer(t *testing.T) {\n+\ttests := []struct {\n+\t\tname           string\n+\t\tcdc            *cassandraoperatorv1alpha1.CassandraDataCenter\n+\t\texpectedImage  string\n+\t}{\n+\t\t{\n+\t\t\tname: \"default image when InitImage not specified\",\n+\t\t\tcdc: &cassandraoperatorv1alpha1.CassandraDataCenter{\n+\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\tName: \"test-dc\",\n+\t\t\t\t},\n+\t\t\t\tSpec: cassandraoperatorv1alpha1.CassandraDataCenterSpec{},\n+\t\t\t},\n+\t\t\texpectedImage: \"busybox:1.33.1\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"custom image when InitImage is specified\",\n+\t\t\tcdc: &cassandraoperatorv1alpha1.CassandraDataCenter{\n+\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\tName: \"test-dc\",\n+\t\t\t\t},\n+\t\t\t\tSpec: cassandraoperatorv1alpha1.CassandraDataCenterSpec{\n+\t\t\t\t\tInitImage: \"custom-image:1.0\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedImage: \"custom-image:1.0\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tcontainer := newSysctlLimitsContainer(tt.cdc)\n+\t\t\tif container.Image != tt.expectedImage {\n+\t\t\t\tt.Errorf(\"newSysctlLimitsContainer() image = %v, want %v\", container.Image, tt.expectedImage)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n\\ No newline at end of file"},{"message":"Fix the youngGen function in pkg/controller/cassandradatacenter/configmap.go to dynamically determine the number of available CPU cores instead of using a hardcoded value of 4. This hardcoded value could be inaccurate for different environments, leading to suboptimal JVM tuning. Use runtime.NumCPU() or a similar approach to get the actual number of cores available to the container.","diff":"diff --git a/pkg/controller/cassandradatacenter/configmap.go b/pkg/controller/cassandradatacenter/configmap.go\nindex 793adce..9f5b117 100644\n--- a/pkg/controller/cassandradatacenter/configmap.go\n+++ b/pkg/controller/cassandradatacenter/configmap.go\n@@ -4,6 +4,7 @@ import (\n \t\"context\"\n \t\"fmt\"\n \t\"regexp\"\n+\t\"runtime\"\n \t\"strings\"\n \n \tcassandraoperatorv1alpha1 \"github.com/instaclustr/cassandra-operator/pkg/apis/cassandraoperator/v1alpha1\"\n@@ -272,8 +273,8 @@ func addCassandraJVMOptions(cdc *cassandraoperatorv1alpha1.CassandraDataCenter,\n }\n \n func youngGen(jvmHeapSize int64) int64 {\n-\n-\tcoreCount := int64(4) // TODO\n+\t// Use runtime.NumCPU() to dynamically determine the number of available CPU cores\n+\tcoreCount := int64(runtime.NumCPU())\n \n \treturn minInt64(coreCount*MEBIBYTE, jvmHeapSize/4)\n }\ndiff --git a/pkg/controller/cassandradatacenter/configmap_test.go b/pkg/controller/cassandradatacenter/configmap_test.go\nnew file mode 100644\nindex 0000000..4ae3422\n--- /dev/null\n+++ b/pkg/controller/cassandradatacenter/configmap_test.go\n@@ -0,0 +1,39 @@\n+package cassandradatacenter\n+\n+import (\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+func TestYoungGen(t *testing.T) {\n+\t// Test with a very large heap size to ensure we're testing the coreCount*MEBIBYTE part\n+\t// of the min function in youngGen\n+\tlargeHeapSize := int64(100 * GIBIBYTE)\n+\t\n+\t// Get the expected value based on runtime.NumCPU()\n+\texpectedCoreCount := int64(runtime.NumCPU())\n+\texpectedYoungGen := expectedCoreCount * MEBIBYTE\n+\t\n+\t// Call the youngGen function\n+\tresult := youngGen(largeHeapSize)\n+\t\n+\t// Verify the result matches our expectation\n+\tif result != expectedYoungGen {\n+\t\tt.Errorf(\"youngGen returned %d, expected %d (based on %d cores)\", \n+\t\t\tresult, expectedYoungGen, expectedCoreCount)\n+\t}\n+\t\n+\t// Test with a small heap size to ensure we're testing the jvmHeapSize/4 part\n+\t// of the min function in youngGen\n+\tsmallHeapSize := int64(1 * MEBIBYTE)\n+\texpectedSmallYoungGen := smallHeapSize / 4\n+\t\n+\t// Call the youngGen function with small heap\n+\tsmallResult := youngGen(smallHeapSize)\n+\t\n+\t// Verify the result matches our expectation for small heap\n+\tif smallResult != expectedSmallYoungGen {\n+\t\tt.Errorf(\"youngGen with small heap returned %d, expected %d\", \n+\t\t\tsmallResult, expectedSmallYoungGen)\n+\t}\n+}\n\\ No newline at end of file"},{"message":"Fix the isCassandra4 function in pkg/controller/cassandradatacenter/configmap.go to handle different image naming formats. The current implementation assumes a specific format and checks if the last part of the image name (after splitting by \"/\") starts with \"cassandra-4\". This could lead to incorrect results if the image name doesn't follow the expected pattern. Implement a more robust approach that can handle various image naming conventions.","diff":"diff --git a/pkg/controller/cassandradatacenter/configmap.go b/pkg/controller/cassandradatacenter/configmap.go\nindex 9f5b117..fa54c0a 100644\n--- a/pkg/controller/cassandradatacenter/configmap.go\n+++ b/pkg/controller/cassandradatacenter/configmap.go\n@@ -195,9 +195,46 @@ func addCassandraYamlOverrides(cdc *cassandraoperatorv1alpha1.CassandraDataCente\n \treturn nil\n }\n \n+// isCassandra4 determines if the Cassandra image is version 4.x\n+// It handles various image naming formats:\n+// 1. Standard format: \"cassandra-4.x\" (e.g., \"instaclustr/cassandra-4.0.1\")\n+// 2. Registry with image: \"registry/repo/cassandra-4.x\" (e.g., \"docker.io/instaclustr/cassandra-4.0.1\")\n+// 3. Tag format: \"cassandra:4.x\" (e.g., \"cassandra:4.0.1\")\n+// 4. Registry with tag: \"registry/repo/cassandra:4.x\" (e.g., \"docker.io/library/cassandra:4.0.1\")\n+// 5. Custom formats with version in tag: \"image:tag-with-4.x\" (e.g., \"cassandra:latest-4.0.1\")\n func isCassandra4(cdc *cassandraoperatorv1alpha1.CassandraDataCenter) bool {\n-\tsplit := strings.Split(cdc.Spec.CassandraImage, \"/\")\n-\treturn strings.HasPrefix(split[len(split)-1], \"cassandra-4\")\n+\t// Get the full image name\n+\timageName := cdc.Spec.CassandraImage\n+\t\n+\t// First check for the original format: ends with \"cassandra-4*\"\n+\t// This handles cases like \"instaclustr/cassandra-4.0.1\"\n+\tsplit := strings.Split(imageName, \"/\")\n+\tlastPart := split[len(split)-1]\n+\tif strings.HasPrefix(lastPart, \"cassandra-4\") {\n+\t\treturn true\n+\t}\n+\t\n+\t// Check for image:tag format where tag starts with 4 (like cassandra:4.0)\n+\t// This handles cases like \"cassandra:4.0.1\" or \"library/cassandra:4.0\"\n+\tif parts := strings.Split(lastPart, \":\"); len(parts) > 1 {\n+\t\ttag := parts[1]\n+\t\t// Check if the tag starts with 4 or contains 4.x\n+\t\tif strings.HasPrefix(tag, \"4\") || strings.Contains(tag, \"-4.\") || strings.Contains(tag, \".4.\") {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\t\n+\t// Use regex to find any occurrence of \"cassandra\" followed by a version starting with 4\n+\t// This will match patterns like cassandra4, apache-cassandra-4.0, etc.\n+\tcassandra4Regex := regexp.MustCompile(`cassandra[-_]?4`)\n+\tif cassandra4Regex.MatchString(imageName) {\n+\t\treturn true\n+\t}\n+\t\n+\t// Use regex to find version 4 in the image name\n+\t// This catches any remaining formats where \"4\" appears after a colon or slash\n+\tversionRegex := regexp.MustCompile(`[:/]4(\\.\\d+)*`)\n+\treturn versionRegex.MatchString(imageName)\n }\n \n func addCassandraJVMOptions(cdc *cassandraoperatorv1alpha1.CassandraDataCenter, addFileFn func(path string, data string)) {\ndiff --git a/pkg/controller/cassandradatacenter/iscassandra4_test.go b/pkg/controller/cassandradatacenter/iscassandra4_test.go\nnew file mode 100644\nindex 0000000..55ca341\n--- /dev/null\n+++ b/pkg/controller/cassandradatacenter/iscassandra4_test.go\n@@ -0,0 +1,75 @@\n+package cassandradatacenter\n+\n+import (\n+\t\"testing\"\n+\n+\tcassandraoperatorv1alpha1 \"github.com/instaclustr/cassandra-operator/pkg/apis/cassandraoperator/v1alpha1\"\n+\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n+)\n+\n+func TestIsCassandra4(t *testing.T) {\n+\ttests := []struct {\n+\t\tname          string\n+\t\tcassandraImage string\n+\t\texpected      bool\n+\t}{\n+\t\t{\n+\t\t\tname:          \"Standard Cassandra 4 image\",\n+\t\t\tcassandraImage: \"instaclustr/cassandra-4.0.1\",\n+\t\t\texpected:      true,\n+\t\t},\n+\t\t{\n+\t\t\tname:          \"Standard Cassandra 3 image\",\n+\t\t\tcassandraImage: \"instaclustr/cassandra-3.11.10\",\n+\t\t\texpected:      false,\n+\t\t},\n+\t\t{\n+\t\t\tname:          \"Registry with Cassandra 4 image\",\n+\t\t\tcassandraImage: \"docker.io/instaclustr/cassandra-4.0.1\",\n+\t\t\texpected:      true,\n+\t\t},\n+\t\t{\n+\t\t\tname:          \"Registry with port and Cassandra 4 image\",\n+\t\t\tcassandraImage: \"registry.example.com:5000/instaclustr/cassandra-4.0.1\",\n+\t\t\texpected:      true,\n+\t\t},\n+\t\t{\n+\t\t\tname:          \"Cassandra 4 with different naming format\",\n+\t\t\tcassandraImage: \"cassandra:4.0.1\",\n+\t\t\texpected:      true,\n+\t\t},\n+\t\t{\n+\t\t\tname:          \"Cassandra 4 with different naming format and registry\",\n+\t\t\tcassandraImage: \"docker.io/library/cassandra:4.0.1\",\n+\t\t\texpected:      true,\n+\t\t},\n+\t\t{\n+\t\t\tname:          \"Cassandra 4 with tag that doesn't start with 4\",\n+\t\t\tcassandraImage: \"instaclustr/cassandra:latest-4.0.1\",\n+\t\t\texpected:      true,\n+\t\t},\n+\t\t{\n+\t\t\tname:          \"Non-Cassandra 4 image\",\n+\t\t\tcassandraImage: \"instaclustr/cassandra:3.11\",\n+\t\t\texpected:      false,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tcdc := &cassandraoperatorv1alpha1.CassandraDataCenter{\n+\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\tName: \"test-dc\",\n+\t\t\t\t},\n+\t\t\t\tSpec: cassandraoperatorv1alpha1.CassandraDataCenterSpec{\n+\t\t\t\t\tCassandraImage: tt.cassandraImage,\n+\t\t\t\t},\n+\t\t\t}\n+\n+\t\t\tresult := isCassandra4(cdc)\n+\t\t\tif result != tt.expected {\n+\t\t\t\tt.Errorf(\"isCassandra4() = %v, want %v for image %s\", result, tt.expected, tt.cassandraImage)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n\\ No newline at end of file"}]}]}