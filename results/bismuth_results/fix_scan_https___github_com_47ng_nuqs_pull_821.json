{"scanned_subsystems":[{"name":"Core Library","files":["packages/nuqs/server.d.ts","packages/nuqs/src/adapters/custom.ts","packages/nuqs/src/adapters/lib/context.ts","packages/nuqs/src/adapters/lib/defs.ts","packages/nuqs/src/adapters/lib/patch-history.test.ts","packages/nuqs/src/adapters/lib/patch-history.ts","packages/nuqs/src/adapters/lib/react-router.ts","packages/nuqs/src/adapters/next.ts","packages/nuqs/src/adapters/next/app.ts","packages/nuqs/src/adapters/next/impl.app.ts","packages/nuqs/src/adapters/next/impl.pages.ts","packages/nuqs/src/adapters/next/pages.ts","packages/nuqs/src/adapters/next/shared.ts","packages/nuqs/src/adapters/react-router.ts","packages/nuqs/src/adapters/react-router/v6.ts","packages/nuqs/src/adapters/react-router/v7.ts","packages/nuqs/src/adapters/react.ts","packages/nuqs/src/adapters/remix.ts","packages/nuqs/src/adapters/testing.ts","packages/nuqs/src/cache.test.ts","packages/nuqs/src/cache.ts","packages/nuqs/src/debug.test.ts","packages/nuqs/src/debug.ts","packages/nuqs/src/defs.ts","packages/nuqs/src/errors.ts","packages/nuqs/src/index.server.ts","packages/nuqs/src/index.ts","packages/nuqs/src/parsers.test.ts","packages/nuqs/src/parsers.ts","packages/nuqs/src/serializer.test.ts","packages/nuqs/src/serializer.ts","packages/nuqs/src/sync.test.tsx","packages/nuqs/src/sync.ts","packages/nuqs/src/tests/cache.test-d.ts","packages/nuqs/src/tests/parsers.test-d.ts","packages/nuqs/src/tests/serializer.test-d.ts","packages/nuqs/src/tests/useQueryState.test-d.ts","packages/nuqs/src/tests/useQueryStates.test-d.ts","packages/nuqs/src/update-queue.test.ts","packages/nuqs/src/update-queue.ts","packages/nuqs/src/url-encoding.test.ts","packages/nuqs/src/url-encoding.ts","packages/nuqs/src/useQueryState.test.ts","packages/nuqs/src/useQueryState.ts","packages/nuqs/src/useQueryStates.test.ts","packages/nuqs/src/useQueryStates.ts","packages/nuqs/src/utils.ts"]}],"changesets":[{"title":"Security and Internationalization Improvements in NuQS Library","body":"## Overview of Changes\n\nThis pull request addresses several critical security vulnerabilities and internationalization issues in the NuQS library:\n\n### Security Improvements\n1. **URL Encoding Security**\n   - Fixed `renderQueryString` and `encodeQueryValue` functions to use `encodeURIComponent` for comprehensive character encoding\n   - Prevents potential URL manipulation and security risks by ensuring all characters are properly encoded\n\n2. **Prototype Pollution Prevention**\n   - Added robust sanitization in `parseAsJson` to prevent prototype pollution attacks\n   - Implemented a `sanitizeObject` function that removes dangerous properties like `__proto__`, `constructor`, and `prototype`\n   - Added comprehensive test cases to verify protection against various prototype pollution techniques\n\n3. **URL Length Handling**\n   - Enhanced `warnIfURLIsTooLong` to handle URL length checks in both development and production environments\n   - Made URL max length configurable with browser-specific defaults\n   - Added ability to set custom URL length limits\n\n### Internationalization Improvements\n1. **Decimal Separator Handling**\n   - Updated `parseAsFloat` to handle both period and comma decimal separators\n   - Replaces all commas with periods to support international number formats\n   - Ensures consistent parsing of floating-point numbers across different locales\n\n### Key Changes\n- Comprehensive security fixes for URL encoding and JSON parsing\n- Browser-specific URL length detection and configuration\n- Improved internationalization support for number parsing\n- Added extensive test coverage for new security features\n\n### Breaking Changes\n- The behavior of `parseAsFloat` now normalizes comma-separated decimals\n- URL length warning/error mechanism has been updated\n\n### Recommended Actions\n- Review and update any custom parsing or URL handling code\n- Test thoroughly in different locales and with various input types\n\nFixes #NUQS-414, #NUQS-599, and related security vulnerabilities.","commits":[{"message":"Fix the security vulnerability in the NuQS library where the renderQueryString function in url-encoding.ts manually encodes only a few specific characters in the key instead of using encodeURIComponent, which could miss encoding characters that need to be encoded, potentially leading to malformed URLs or security issues. The function should be updated to use encodeURIComponent for comprehensive encoding of all keys.","diff":"diff --git a/packages/nuqs/src/url-encoding.ts b/packages/nuqs/src/url-encoding.ts\nindex 5ea4bf7..9c13b0e 100644\n--- a/packages/nuqs/src/url-encoding.ts\n+++ b/packages/nuqs/src/url-encoding.ts\n@@ -6,14 +6,10 @@ export function renderQueryString(search: URLSearchParams) {\n   }\n   const query: string[] = []\n   for (const [key, value] of search.entries()) {\n-    // Replace disallowed characters in keys,\n+    // Use encodeURIComponent to properly encode all characters in keys\n+    // This is more secure than manually encoding specific characters\n     // see https://github.com/47ng/nuqs/issues/599\n-    const safeKey = key\n-      .replace(/#/g, '%23')\n-      .replace(/&/g, '%26')\n-      .replace(/\\+/g, '%2B')\n-      .replace(/=/g, '%3D')\n-      .replace(/\\?/g, '%3F')\n+    const safeKey = encodeURIComponent(key)\n     query.push(`${safeKey}=${encodeQueryValue(value)}`)\n   }\n   const queryString = '?' + query.join('&')"},{"message":"Fix the security vulnerability in the NuQS library where the encodeQueryValue function in url-encoding.ts manually encodes only specific characters instead of using encodeURIComponent for all characters. This could miss encoding some characters that need to be encoded, potentially leading to malformed URLs or security issues. Update the function to use encodeURIComponent for the entire string and then replace %20 with + if needed for spaces.","diff":"diff --git a/packages/nuqs/src/url-encoding.ts b/packages/nuqs/src/url-encoding.ts\nindex 9c13b0e..d8d589f 100644\n--- a/packages/nuqs/src/url-encoding.ts\n+++ b/packages/nuqs/src/url-encoding.ts\n@@ -18,29 +18,10 @@ export function renderQueryString(search: URLSearchParams) {\n }\n \n export function encodeQueryValue(input: string) {\n-  return (\n-    input\n-      // Encode existing % signs first to avoid appearing\n-      // as an incomplete escape sequence:\n-      .replace(/%/g, '%25')\n-      // Note: spaces are encoded as + in RFC 3986,\n-      // so we pre-encode existing + signs to avoid confusion\n-      // before converting spaces to + signs.\n-      .replace(/\\+/g, '%2B')\n-      .replace(/ /g, '+')\n-      // Encode other URI-reserved characters\n-      .replace(/#/g, '%23')\n-      .replace(/&/g, '%26')\n-      // Encode characters that break URL detection on some platforms\n-      // and would drop the tail end of the querystring:\n-      .replace(/\"/g, '%22')\n-      .replace(/'/g, '%27')\n-      .replace(/`/g, '%60')\n-      .replace(/</g, '%3C')\n-      .replace(/>/g, '%3E')\n-      // Encode invisible ASCII control characters\n-      .replace(/[\\x00-\\x1F]/g, char => encodeURIComponent(char))\n-  )\n+  // Use encodeURIComponent to properly encode all characters\n+  // This is more secure than manually encoding specific characters\n+  // Then replace %20 with + for spaces as per RFC 3986\n+  return encodeURIComponent(input).replace(/%20/g, '+')\n }\n \n // Note: change error documentation (NUQS-414) when changing this value."},{"message":"Fix the potential prototype pollution vulnerability in the parseAsJson function in the NuQS library. Currently, when used with a simple identity function (x => x) as the runtime parser, it could allow malicious JSON data to cause prototype pollution. Modify the function to include safeguards against prototype pollution by implementing a sanitization step that removes or neutralizes dangerous properties like __proto__, constructor, and prototype before returning the parsed object.","diff":"diff --git a/packages/nuqs/src/parsers.prototype-pollution.test.ts b/packages/nuqs/src/parsers.prototype-pollution.test.ts\nnew file mode 100644\nindex 0000000..69463fc\n--- /dev/null\n+++ b/packages/nuqs/src/parsers.prototype-pollution.test.ts\n@@ -0,0 +1,88 @@\n+import { describe, expect, test } from 'vitest'\n+import { parseAsJson } from './parsers'\n+\n+describe('parseAsJson prototype pollution protection', () => {\n+  test('should prevent __proto__ pollution', () => {\n+    // Create a malicious JSON string that attempts to pollute Object.prototype\n+    const maliciousJson = '{\"__proto__\": {\"polluted\": true}}'\n+    \n+    // Use the identity function as the runtime parser\n+    const parser = parseAsJson(x => x)\n+    \n+    // Parse the malicious JSON\n+    const result = parser.parse(maliciousJson)\n+    \n+    // Verify the parsed object doesn't have the __proto__ property\n+    expect(Object.keys(result as object)).not.toContain('__proto__')\n+    \n+    // Verify that Object.prototype wasn't polluted\n+    expect((Object.prototype as any).polluted).toBeUndefined()\n+  })\n+\n+  test('should prevent constructor pollution', () => {\n+    const maliciousJson = '{\"constructor\": {\"prototype\": {\"polluted\": true}}}'\n+    \n+    const parser = parseAsJson(x => x)\n+    const result = parser.parse(maliciousJson)\n+    \n+    expect(Object.keys(result as object)).not.toContain('constructor')\n+    expect((Object.prototype as any).polluted).toBeUndefined()\n+  })\n+\n+  test('should prevent prototype property pollution', () => {\n+    const maliciousJson = '{\"prototype\": {\"polluted\": true}}'\n+    \n+    const parser = parseAsJson(x => x)\n+    const result = parser.parse(maliciousJson)\n+    \n+    expect(Object.keys(result as object)).not.toContain('prototype')\n+    expect((Object.prototype as any).polluted).toBeUndefined()\n+  })\n+\n+  test('should handle nested objects with dangerous properties', () => {\n+    const maliciousJson = '{\"nested\": {\"__proto__\": {\"polluted\": true}}}'\n+    \n+    const parser = parseAsJson(x => x)\n+    const result = parser.parse(maliciousJson) as any\n+    \n+    // The nested object should exist\n+    expect(result.nested).toBeDefined()\n+    \n+    // But it shouldn't have the __proto__ property\n+    expect(Object.keys(result.nested)).not.toContain('__proto__')\n+    \n+    // And Object.prototype shouldn't be polluted\n+    expect((Object.prototype as any).polluted).toBeUndefined()\n+  })\n+\n+  test('should handle arrays with objects containing dangerous properties', () => {\n+    const maliciousJson = '{\"array\": [{\"__proto__\": {\"polluted\": true}}]}'\n+    \n+    const parser = parseAsJson(x => x)\n+    const result = parser.parse(maliciousJson) as any\n+    \n+    // The array should exist\n+    expect(Array.isArray(result.array)).toBe(true)\n+    \n+    // The object in the array should exist\n+    expect(result.array[0]).toBeDefined()\n+    \n+    // But it shouldn't have the __proto__ property\n+    expect(Object.keys(result.array[0])).not.toContain('__proto__')\n+    \n+    // And Object.prototype shouldn't be polluted\n+    expect((Object.prototype as any).polluted).toBeUndefined()\n+  })\n+\n+  test('should preserve normal object properties', () => {\n+    const normalJson = '{\"id\": 1, \"name\": \"test\", \"nested\": {\"value\": 42}}'\n+    \n+    const parser = parseAsJson(x => x)\n+    const result = parser.parse(normalJson) as any\n+    \n+    // All normal properties should be preserved\n+    expect(result.id).toBe(1)\n+    expect(result.name).toBe('test')\n+    expect(result.nested.value).toBe(42)\n+  })\n+})\n\\ No newline at end of file\ndiff --git a/packages/nuqs/src/parsers.ts b/packages/nuqs/src/parsers.ts\nindex 9a94681..7ca0655 100644\n--- a/packages/nuqs/src/parsers.ts\n+++ b/packages/nuqs/src/parsers.ts\n@@ -342,6 +342,41 @@ export function parseAsNumberLiteral<Literal extends number>(\n   })\n }\n \n+/**\n+ * Sanitizes an object to prevent prototype pollution by removing dangerous properties\n+ * like __proto__, constructor, and prototype.\n+ * \n+ * @param obj The object to sanitize\n+ * @returns A sanitized copy of the object\n+ */\n+function sanitizeObject(obj: unknown): unknown {\n+  // If not an object or null, return as is\n+  if (obj === null || typeof obj !== 'object') {\n+    return obj;\n+  }\n+\n+  // Handle arrays\n+  if (Array.isArray(obj)) {\n+    return obj.map(item => sanitizeObject(item));\n+  }\n+\n+  // Create a new object to avoid modifying the original\n+  const sanitized: Record<string, unknown> = {};\n+  \n+  // Copy all safe properties\n+  for (const [key, value] of Object.entries(obj)) {\n+    // Skip dangerous properties\n+    if (['__proto__', 'constructor', 'prototype'].includes(key)) {\n+      continue;\n+    }\n+    \n+    // Recursively sanitize nested objects\n+    sanitized[key] = sanitizeObject(value);\n+  }\n+  \n+  return sanitized;\n+}\n+\n /**\n  * Encode any object shape into the querystring value as JSON.\n  * Note: you may want to use `useQueryStates` for finer control over\n@@ -353,16 +388,18 @@ export function parseAsJson<T>(runtimeParser: (value: unknown) => T) {\n   return createParser({\n     parse: query => {\n       try {\n-        const obj = JSON.parse(query)\n-        return runtimeParser(obj)\n+        const obj = JSON.parse(query);\n+        // Sanitize the object to prevent prototype pollution\n+        const sanitizedObj = sanitizeObject(obj);\n+        return runtimeParser(sanitizedObj);\n       } catch {\n-        return null\n+        return null;\n       }\n     },\n     serialize: value => JSON.stringify(value),\n     eq(a, b) {\n       // Check for referential equality first\n-      return a === b || JSON.stringify(a) === JSON.stringify(b)\n+      return a === b || JSON.stringify(a) === JSON.stringify(b);\n     }\n   })\n }"},{"message":"Fix the encodeQueryValue function in the NuQS library to properly handle spaces in URL encoding. Currently, it encodes spaces as '+' which is valid for application/x-www-form-urlencoded format but could cause issues if used in other parts of a URL where spaces should be encoded as '%20'. Update the function to use encodeURIComponent for all characters (which encodes spaces as '%20') and then only replace '%20' with '+' if specifically needed for query parameters.","diff":"diff --git a/packages/nuqs/src/url-encoding.test.ts b/packages/nuqs/src/url-encoding.test.ts\nindex c2b45b0..3e123df 100644\n--- a/packages/nuqs/src/url-encoding.test.ts\n+++ b/packages/nuqs/src/url-encoding.test.ts\n@@ -2,9 +2,12 @@ import { describe, expect, test, vi } from 'vitest'\n import { encodeQueryValue, renderQueryString } from './url-encoding'\n \n describe('url-encoding/encodeQueryValue', () => {\n-  test('spaces are encoded as +', () => {\n+  test('spaces are encoded as + by default (for query parameters)', () => {\n     expect(encodeQueryValue(' ')).toBe('+')\n   })\n+  test('spaces are encoded as %20 when useQueryFormat is false', () => {\n+    expect(encodeQueryValue(' ', false)).toBe('%20')\n+  })\n   test('+ are encoded', () => {\n     expect(encodeQueryValue('+')).toBe(encodeURIComponent('+'))\n   })\n@@ -46,6 +49,10 @@ describe('url-encoding/encodeQueryValue', () => {\n     expect(e('100%')).toBe('100%25')\n     expect(e('kool&thegang')).toBe('kool%26thegang')\n     expect(e('a&b=c')).toBe('a%26b=c')\n+    \n+    // Test with useQueryFormat=false for non-query parameter contexts\n+    expect(e('a b', false)).toBe('a%20b')\n+    expect(e('path/with spaces', false)).toBe('path/with%20spaces')\n   })\n })\n \ndiff --git a/packages/nuqs/src/url-encoding.ts b/packages/nuqs/src/url-encoding.ts\nindex d8d589f..9295b4c 100644\n--- a/packages/nuqs/src/url-encoding.ts\n+++ b/packages/nuqs/src/url-encoding.ts\n@@ -17,11 +17,13 @@ export function renderQueryString(search: URLSearchParams) {\n   return queryString\n }\n \n-export function encodeQueryValue(input: string) {\n+export function encodeQueryValue(input: string, useQueryFormat: boolean = true) {\n   // Use encodeURIComponent to properly encode all characters\n   // This is more secure than manually encoding specific characters\n-  // Then replace %20 with + for spaces as per RFC 3986\n-  return encodeURIComponent(input).replace(/%20/g, '+')\n+  const encoded = encodeURIComponent(input)\n+  // Only replace %20 with + for spaces when specifically needed for query parameters\n+  // as per application/x-www-form-urlencoded format\n+  return useQueryFormat ? encoded.replace(/%20/g, '+') : encoded\n }\n \n // Note: change error documentation (NUQS-414) when changing this value."},{"message":"Fix the parseAsFloat parser in the NuQS library to handle comma-separated decimals for users in locales that use commas as decimal separators. Currently, it only recognizes periods (.) as decimal separators, which causes incorrect parsing for users from many European and other countries. Update the parser to replace commas with periods before passing the string to parseFloat, ensuring proper support for international number formats.","diff":"diff --git a/packages/nuqs/src/parsers.test.ts b/packages/nuqs/src/parsers.test.ts\nindex 74d9d3d..ad5bbe9 100644\n--- a/packages/nuqs/src/parsers.test.ts\n+++ b/packages/nuqs/src/parsers.test.ts\n@@ -22,7 +22,7 @@ describe('parsers', () => {\n     expect(parseAsFloat.parse('')).toBeNull()\n     expect(parseAsFloat.parse('1')).toBe(1)\n     expect(parseAsFloat.parse('3.14')).toBe(3.14)\n-    expect(parseAsFloat.parse('3,14')).toBe(3)\n+    expect(parseAsFloat.parse('3,14')).toBe(3.14) // Now correctly parses comma as decimal separator\n     expect(parseAsFloat.serialize(3.14)).toBe('3.14')\n     // https://0.30000000000000004.com/\n     expect(parseAsFloat.serialize(0.1 + 0.2)).toBe('0.30000000000000004')\ndiff --git a/packages/nuqs/src/parsers.ts b/packages/nuqs/src/parsers.ts\nindex 7ca0655..6830964 100644\n--- a/packages/nuqs/src/parsers.ts\n+++ b/packages/nuqs/src/parsers.ts\n@@ -171,7 +171,9 @@ export const parseAsHex = createParser({\n \n export const parseAsFloat = createParser({\n   parse: v => {\n-    const float = parseFloat(v)\n+    // Replace comma with period to support international number formats\n+    const normalized = v.replace(',', '.')\n+    const float = parseFloat(normalized)\n     if (Number.isNaN(float)) {\n       return null\n     }"},{"message":"Fix the warnIfURLIsTooLong function in the NuQS library to handle URL length checking in production environments. Currently, it only warns if the URL is too long in non-production environments, which means URLs could silently exceed the maximum length without any warning in production. Update the function to always check the URL length regardless of environment, and implement a more robust handling mechanism for production that logs the error to a monitoring system or provides a fallback mechanism for handling excessively long URLs.","diff":"diff --git a/packages/nuqs/src/url-encoding.test.ts b/packages/nuqs/src/url-encoding.test.ts\nindex 3e123df..524dcc0 100644\n--- a/packages/nuqs/src/url-encoding.test.ts\n+++ b/packages/nuqs/src/url-encoding.test.ts\n@@ -137,14 +137,48 @@ describe('url-encoding/renderQueryString', () => {\n       '?a %26b%3Fc%3Dd%23e%f%2Bg\"h\\'i`j<k>l(m)n*o,p.q:r;s/t=value'\n     )\n   })\n-  test('emits a warning if the URL is too long', () => {\n+  test('emits a warning if the URL is too long in development environment', () => {\n     const search = new URLSearchParams()\n     search.set('a', 'a'.repeat(2000))\n     const warn = console.warn\n+    const error = console.error\n     console.warn = vi.fn()\n+    console.error = vi.fn()\n+    \n+    // Mock NODE_ENV as development\n+    const originalNodeEnv = process.env.NODE_ENV\n+    process.env.NODE_ENV = 'development'\n+    \n     renderQueryString(search)\n     expect(console.warn).toHaveBeenCalledTimes(1)\n+    expect(console.error).not.toHaveBeenCalled()\n+    \n+    // Restore mocks\n+    console.warn = warn\n+    console.error = error\n+    process.env.NODE_ENV = originalNodeEnv\n+  })\n+  \n+  test('emits an error if the URL is too long in production environment', () => {\n+    const search = new URLSearchParams()\n+    search.set('a', 'a'.repeat(2000))\n+    const warn = console.warn\n+    const error = console.error\n+    console.warn = vi.fn()\n+    console.error = vi.fn()\n+    \n+    // Mock NODE_ENV as production\n+    const originalNodeEnv = process.env.NODE_ENV\n+    process.env.NODE_ENV = 'production'\n+    \n+    renderQueryString(search)\n+    expect(console.error).toHaveBeenCalledTimes(1)\n+    expect(console.warn).not.toHaveBeenCalled()\n+    \n+    // Restore mocks\n     console.warn = warn\n+    console.error = error\n+    process.env.NODE_ENV = originalNodeEnv\n   })\n })\n \ndiff --git a/packages/nuqs/src/url-encoding.ts b/packages/nuqs/src/url-encoding.ts\nindex 9295b4c..183799b 100644\n--- a/packages/nuqs/src/url-encoding.ts\n+++ b/packages/nuqs/src/url-encoding.ts\n@@ -30,15 +30,26 @@ export function encodeQueryValue(input: string, useQueryFormat: boolean = true)\n export const URL_MAX_LENGTH = 2000\n \n export function warnIfURLIsTooLong(queryString: string) {\n-  if (process.env.NODE_ENV === 'production') {\n-    return\n-  }\n+  // Skip check if not in a browser environment\n   if (typeof location === 'undefined') {\n     return\n   }\n+  \n   const url = new URL(location.href)\n   url.search = queryString\n+  \n   if (url.href.length > URL_MAX_LENGTH) {\n-    console.warn(error(414))\n+    // In production, log to a monitoring system if available\n+    // or use a more discreet logging method\n+    if (process.env.NODE_ENV === 'production') {\n+      // Use console.error for production to ensure it's captured by monitoring systems\n+      console.error(error(414))\n+      \n+      // Here you could add integration with monitoring systems\n+      // Example: if (typeof window.__monitoring !== 'undefined') window.__monitoring.logError(error(414))\n+    } else {\n+      // In development, show a more visible warning\n+      console.warn(error(414))\n+    }\n   }\n }"},{"message":"Fix the URL_MAX_LENGTH constant in the NuQS library to be more appropriate for different browsers and servers. Currently, it's set to 2000 characters, which is overly conservative for most modern browsers and servers. Update the implementation to make the URL length limit configurable by the user of the library, provide different default limits based on detected browser/environment, and document the changes appropriately.","diff":"diff --git a/packages/nuqs/docs/url-length-configuration.md b/packages/nuqs/docs/url-length-configuration.md\nnew file mode 100644\nindex 0000000..e6829d8\n--- /dev/null\n+++ b/packages/nuqs/docs/url-length-configuration.md\n@@ -0,0 +1,79 @@\n+# URL Length Configuration in NuQS\n+\n+NuQS now provides browser-specific URL length limits and allows you to configure these limits to match your specific requirements.\n+\n+## Background\n+\n+Different browsers and servers have different maximum URL length limits. Previously, NuQS used a conservative limit of 2000 characters, which worked across all browsers but was unnecessarily restrictive for modern browsers that support much longer URLs.\n+\n+## Browser-Specific Defaults\n+\n+NuQS now automatically detects the browser environment and sets appropriate URL length limits:\n+\n+| Browser | Default Limit (characters) |\n+|---------|----------------------------|\n+| Chrome  | 8,000                      |\n+| Firefox | 65,536                     |\n+| Safari  | 80,000                     |\n+| Edge    | 8,000                      |\n+| IE      | 2,083                      |\n+| Opera   | 4,000                      |\n+| Default (unknown browsers) | 2,000   |\n+\n+## Configuring URL Length Limits\n+\n+You can configure the URL length limit in two ways:\n+\n+### 1. Using the `setUrlMaxLength` function\n+\n+```typescript\n+import { setUrlMaxLength } from 'nuqs';\n+\n+// Set a custom URL length limit (e.g., 10000 characters)\n+setUrlMaxLength(10000);\n+```\n+\n+### 2. Using the `urlMaxLength` option in query state hooks\n+\n+```typescript\n+import { useQueryState } from 'nuqs';\n+\n+const [value, setValue] = useQueryState('key', {\n+  urlMaxLength: 10000\n+});\n+```\n+\n+## Checking the Current URL Length Limit\n+\n+You can check the current URL length limit using the `getUrlMaxLength` function:\n+\n+```typescript\n+import { getUrlMaxLength } from 'nuqs';\n+\n+const currentLimit = getUrlMaxLength();\n+console.log(`Current URL length limit: ${currentLimit} characters`);\n+```\n+\n+## How It Works\n+\n+When a URL exceeds the configured length limit:\n+- In development mode: A warning is logged to the console\n+- In production mode: An error is logged to the console\n+\n+The warning/error message includes a link to the error documentation for more information.\n+\n+## Server Considerations\n+\n+While browsers may support longer URLs, some servers might have their own limitations. Common server limits include:\n+\n+- Apache: 8,192 characters (default)\n+- Nginx: 4,096 characters (default)\n+- IIS: 16,384 characters (default)\n+\n+If your application needs to work with specific server configurations, you should set the URL length limit accordingly.\n+\n+## Best Practices\n+\n+1. For most modern web applications, the browser-specific defaults should work well.\n+2. If you're targeting specific environments or servers, configure the limit explicitly.\n+3. Consider the needs of your application - storing large amounts of state in URLs may indicate that you should use a different state management approach.\n\\ No newline at end of file\ndiff --git a/packages/nuqs/src/defs.ts b/packages/nuqs/src/defs.ts\nindex 6e67e3e..d003d4c 100644\n--- a/packages/nuqs/src/defs.ts\n+++ b/packages/nuqs/src/defs.ts\n@@ -61,6 +61,22 @@ export type Options = {\n    * changes (prefer explicit URLs whose meaning don't change).\n    */\n   clearOnDefault?: boolean\n+\n+  /**\n+   * Maximum URL length in characters before a warning is shown.\n+   * \n+   * By default, this is automatically detected based on the browser:\n+   * - Chrome/Edge: 8000\n+   * - Firefox: 65536\n+   * - Safari: 80000\n+   * - IE: 2083\n+   * - Opera: 4000\n+   * - Default (unknown browsers): 2000\n+   * \n+   * You can override this with a custom value if needed for your specific\n+   * server or client environment.\n+   */\n+  urlMaxLength?: number\n }\n \n export type Nullable<T> = {\ndiff --git a/packages/nuqs/src/index.ts b/packages/nuqs/src/index.ts\nindex b8bc6f5..2f7ebf4 100644\n--- a/packages/nuqs/src/index.ts\n+++ b/packages/nuqs/src/index.ts\n@@ -3,3 +3,4 @@ export * from './parsers'\n export { createSerializer } from './serializer'\n export * from './useQueryState'\n export * from './useQueryStates'\n+export { setUrlMaxLength, getUrlMaxLength } from './url-encoding'\ndiff --git a/packages/nuqs/src/url-encoding.test.ts b/packages/nuqs/src/url-encoding.test.ts\nindex 524dcc0..2ea42cc 100644\n--- a/packages/nuqs/src/url-encoding.test.ts\n+++ b/packages/nuqs/src/url-encoding.test.ts\n@@ -1,5 +1,10 @@\n-import { describe, expect, test, vi } from 'vitest'\n-import { encodeQueryValue, renderQueryString } from './url-encoding'\n+import { describe, expect, test, vi, beforeEach, afterEach } from 'vitest'\n+import { \n+  encodeQueryValue, \n+  renderQueryString, \n+  setUrlMaxLength, \n+  getUrlMaxLength \n+} from './url-encoding'\n \n describe('url-encoding/encodeQueryValue', () => {\n   test('spaces are encoded as + by default (for query parameters)', () => {\n@@ -192,3 +197,75 @@ test.skip('encodeURI vs encodeURIComponent vs custom encoding', () => {\n   }))\n   console.table(table)\n })\n+\n+describe('url-encoding/URL max length configuration', () => {\n+  // Save original console methods\n+  let originalWarn: typeof console.warn\n+  let originalError: typeof console.error\n+  let originalLocation: any\n+  \n+  beforeEach(() => {\n+    // Mock console methods\n+    originalWarn = console.warn\n+    originalError = console.error\n+    console.warn = vi.fn()\n+    console.error = vi.fn()\n+    \n+    // Mock location for URL tests\n+    originalLocation = global.location\n+    // @ts-ignore - mocking location\n+    global.location = { href: 'http://example.com' }\n+    \n+    // Reset URL max length to default before each test\n+    setUrlMaxLength(0) // This will reset to default\n+  })\n+  \n+  afterEach(() => {\n+    // Restore console methods\n+    console.warn = originalWarn\n+    console.error = originalError\n+    \n+    // Restore location\n+    // @ts-ignore - restoring location\n+    global.location = originalLocation\n+  })\n+  \n+  test('setUrlMaxLength configures the URL max length', () => {\n+    const customLength = 5000\n+    setUrlMaxLength(customLength)\n+    expect(getUrlMaxLength()).toBe(customLength)\n+  })\n+  \n+  test('setUrlMaxLength with invalid value uses browser default', () => {\n+    setUrlMaxLength(-1) // Invalid value\n+    // Should use browser default, which we can't test directly\n+    // but we can verify it's not the invalid value\n+    expect(getUrlMaxLength()).not.toBe(-1)\n+  })\n+  \n+  test('warning is emitted based on configured URL length', () => {\n+    // Set a custom length that's higher than our test URL\n+    const customLength = 3000\n+    setUrlMaxLength(customLength)\n+    \n+    // Create a URL that would be too long with default limit but OK with custom limit\n+    const search = new URLSearchParams()\n+    search.set('a', 'a'.repeat(2500))\n+    \n+    // Mock NODE_ENV as development\n+    const originalNodeEnv = process.env.NODE_ENV\n+    process.env.NODE_ENV = 'development'\n+    \n+    // This should NOT trigger a warning since our custom length is higher\n+    renderQueryString(search)\n+    expect(console.warn).not.toHaveBeenCalled()\n+    \n+    // Now set a lower limit that will trigger the warning\n+    setUrlMaxLength(1000)\n+    renderQueryString(search)\n+    expect(console.warn).toHaveBeenCalledTimes(1)\n+    \n+    // Restore NODE_ENV\n+    process.env.NODE_ENV = originalNodeEnv\n+  })\n+})\ndiff --git a/packages/nuqs/src/url-encoding.ts b/packages/nuqs/src/url-encoding.ts\nindex 183799b..2689954 100644\n--- a/packages/nuqs/src/url-encoding.ts\n+++ b/packages/nuqs/src/url-encoding.ts\n@@ -1,4 +1,5 @@\n import { error } from './errors'\n+import type { Options } from './defs'\n \n export function renderQueryString(search: URLSearchParams) {\n   if (search.size === 0) {\n@@ -27,6 +28,83 @@ export function encodeQueryValue(input: string, useQueryFormat: boolean = true)\n }\n \n // Note: change error documentation (NUQS-414) when changing this value.\n+// Browser-specific URL length limits\n+// These values are based on common browser limitations\n+// See: https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers\n+const BROWSER_URL_LIMITS = {\n+  chrome: 8000,\n+  firefox: 65536,\n+  safari: 80000,\n+  edge: 8000,\n+  ie: 2083,\n+  opera: 4000,\n+  // Default conservative limit for unknown browsers\n+  default: 2000\n+}\n+\n+/**\n+ * Detects the current browser and returns the appropriate URL length limit\n+ */\n+function detectBrowserUrlLimit(): number {\n+  // Skip browser detection in non-browser environments\n+  if (typeof window === 'undefined') {\n+    return BROWSER_URL_LIMITS.default\n+  }\n+\n+  const userAgent = window.navigator.userAgent.toLowerCase()\n+  \n+  if (userAgent.includes('chrome') && !userAgent.includes('edge')) {\n+    return BROWSER_URL_LIMITS.chrome\n+  } else if (userAgent.includes('firefox')) {\n+    return BROWSER_URL_LIMITS.firefox\n+  } else if (userAgent.includes('safari') && !userAgent.includes('chrome')) {\n+    return BROWSER_URL_LIMITS.safari\n+  } else if (userAgent.includes('edge') || userAgent.includes('edg')) {\n+    return BROWSER_URL_LIMITS.edge\n+  } else if (userAgent.includes('msie') || userAgent.includes('trident')) {\n+    return BROWSER_URL_LIMITS.ie\n+  } else if (userAgent.includes('opera') || userAgent.includes('opr')) {\n+    return BROWSER_URL_LIMITS.opera\n+  }\n+  \n+  return BROWSER_URL_LIMITS.default\n+}\n+\n+// Global configuration for URL length limit\n+let _configuredUrlMaxLength: number | null = null\n+\n+/**\n+ * Sets the maximum URL length limit for the application\n+ * @param length The maximum URL length in characters\n+ */\n+export function setUrlMaxLength(length: number): void {\n+  if (length < 1) {\n+    console.warn('[nuqs] Invalid URL max length. Using default value instead.')\n+    _configuredUrlMaxLength = null\n+    return\n+  }\n+  _configuredUrlMaxLength = length\n+}\n+\n+/**\n+ * Configure URL max length from options\n+ * @param options The options object that may contain urlMaxLength\n+ */\n+export function configureUrlMaxLength(options?: Options): void {\n+  if (options?.urlMaxLength !== undefined) {\n+    setUrlMaxLength(options.urlMaxLength)\n+  }\n+}\n+\n+/**\n+ * Gets the current maximum URL length limit\n+ * This will return the user-configured value if set, or the browser-specific default\n+ */\n+export function getUrlMaxLength(): number {\n+  return _configuredUrlMaxLength !== null ? _configuredUrlMaxLength : detectBrowserUrlLimit()\n+}\n+\n+// For backward compatibility\n export const URL_MAX_LENGTH = 2000\n \n export function warnIfURLIsTooLong(queryString: string) {\n@@ -38,7 +116,10 @@ export function warnIfURLIsTooLong(queryString: string) {\n   const url = new URL(location.href)\n   url.search = queryString\n   \n-  if (url.href.length > URL_MAX_LENGTH) {\n+  // Use the configurable or browser-specific URL length limit\n+  const maxUrlLength = getUrlMaxLength()\n+  \n+  if (url.href.length > maxUrlLength) {\n     // In production, log to a monitoring system if available\n     // or use a more discreet logging method\n     if (process.env.NODE_ENV === 'production') {\ndiff --git a/packages/nuqs/src/useQueryState.ts b/packages/nuqs/src/useQueryState.ts\nindex faa9da5..6c7626f 100644\n--- a/packages/nuqs/src/useQueryState.ts\n+++ b/packages/nuqs/src/useQueryState.ts\n@@ -17,6 +17,7 @@ import {\n   scheduleFlushToURL\n } from './update-queue'\n import { safeParse } from './utils'\n+import { configureUrlMaxLength } from './url-encoding'\n \n export interface UseQueryStateOptions<T> extends Parser<T>, Options {}\n \n@@ -288,6 +289,10 @@ export function useQueryState<T = string>(\n       ) {\n         newValue = null\n       }\n+      \n+      // Configure URL max length from options\n+      configureUrlMaxLength(options)\n+      \n       queryRef.current = enqueueQueryStringUpdate(key, newValue, serialize, {\n         // Call-level options take precedence over hook declaration options.\n         history: options.history ?? history,"},{"message":"Fix the prototype pollution vulnerability in the parseAsJson function of the NuQS library. Currently, when used with a simple identity function (x => x) as the runtime parser, it could allow attackers to modify Object.prototype properties. Implement a sanitization step that removes dangerous properties like __proto__ and constructor before returning the parsed JSON data.","diff":""},{"message":"Fix the internationalization issue in the parseAsFloat parser of the NuQS library. Currently, it doesn't handle comma-separated decimals, which causes problems for users in locales that use commas as decimal separators. Update the parser to handle both period and comma decimal separators by replacing commas with periods before passing the string to parseFloat.","diff":"diff --git a/packages/nuqs/src/parsers.ts b/packages/nuqs/src/parsers.ts\nindex 6830964..4aa77dc 100644\n--- a/packages/nuqs/src/parsers.ts\n+++ b/packages/nuqs/src/parsers.ts\n@@ -171,8 +171,8 @@ export const parseAsHex = createParser({\n \n export const parseAsFloat = createParser({\n   parse: v => {\n-    // Replace comma with period to support international number formats\n-    const normalized = v.replace(',', '.')\n+    // Replace all commas with periods to support international number formats\n+    const normalized = v.replaceAll(',', '.')\n     const float = parseFloat(normalized)\n     if (Number.isNaN(float)) {\n       return null"}]}]}