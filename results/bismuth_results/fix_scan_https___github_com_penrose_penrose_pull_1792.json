{"scanned_subsystems":[{"name":"Editor UI","files":["packages/editor/src/App.tsx","packages/editor/src/components/BlueButton.tsx","packages/editor/src/components/DiagramOptions.tsx","packages/editor/src/components/DiagramPanel.tsx","packages/editor/src/components/DropdownButton.tsx","packages/editor/src/components/ExamplesBrowser.tsx","packages/editor/src/components/ExportButton.tsx","packages/editor/src/components/FileButton.tsx","packages/editor/src/components/GridPanel.tsx","packages/editor/src/components/LayoutTimelineSlider.tsx","packages/editor/src/components/Opt.tsx","packages/editor/src/components/ProgramEditor.tsx","packages/editor/src/components/RogerPanel.tsx","packages/editor/src/components/SavedBrowser.tsx","packages/editor/src/components/SegmentedSlider.tsx","packages/editor/src/components/Settings.tsx","packages/editor/src/components/StateInspector.tsx","packages/editor/src/components/SvgUploader.tsx","packages/editor/src/components/TopBar.tsx","packages/editor/src/index.css","packages/editor/src/main.tsx"]},{"name":"Editor State Management","files":["packages/editor/src/state/atoms.ts","packages/editor/src/state/callbacks.ts","packages/editor/src/state/variation.ts"]},{"name":"Editor Worker","files":["packages/editor/src/worker/OptimizerWorker.test.ts","packages/editor/src/worker/OptimizerWorker.ts","packages/editor/src/worker/common.ts","packages/editor/src/worker/errors.ts","packages/editor/src/worker/worker.ts"]}],"changesets":[{"title":"Fix Memory Leaks, Security Vulnerabilities, and Error Handling in Editor UI","body":"## Overview\nThis pull request addresses several critical issues in the Editor UI subsystem, including memory leaks, security vulnerabilities, and error handling improvements.\n\n### Key Fixes\n1. **Memory Leaks**\n   - Fixed WebSocket event listener memory leak in `RogerPanel.tsx`\n   - Added proper cleanup for event listeners in `App.tsx`\n   - Resolved potential memory leak in `DiagramPanel.tsx` with `requestAnimationFrame`\n   - Implemented safe unmounting handling in async operations\n\n2. **Security Vulnerabilities**\n   - Added JSON parsing validation in WebSocket message handlers\n   - Implemented input sanitization to prevent XSS attacks\n   - Added type checking and validation for error handling\n   - Prevented potential prototype pollution\n\n3. **Error Handling Improvements**\n   - Enhanced `ErrorBoundary` component to maintain error state\n   - Added fallback UI for component errors\n   - Improved logging and error reporting\n   - Implemented robust error type checking\n\n### Detailed Changes\n- Refactored WebSocket message parsing with strict validation\n- Added cleanup mechanisms for event listeners\n- Implemented safe error handling and reporting\n- Enhanced security checks in JSON parsing\n- Improved component unmounting logic\n\n### Testing Recommendations\n- Thoroughly test WebSocket communication\n- Verify memory usage and event listener cleanup\n- Check error handling and fallback UI rendering\n- Validate security improvements against potential attack vectors\n\n## Breaking Changes\nNone\n\n## Additional Notes\nPlease review the comprehensive changes to ensure all memory leaks, security vulnerabilities, and error handling issues are adequately addressed.","commits":[{"message":"Fix the memory leak in RogerPanel.tsx where WebSocket event listeners are added but never removed. The issue is at line 135-141 where a new event listener is added each time the trio dropdown changes, but these listeners are never cleaned up, leading to duplicate listeners and potential memory leaks.","diff":"diff --git a/packages/editor/src/components/RogerPanel.tsx b/packages/editor/src/components/RogerPanel.tsx\nindex d138a84..363d9f3 100644\n--- a/packages/editor/src/components/RogerPanel.tsx\n+++ b/packages/editor/src/components/RogerPanel.tsx\n@@ -1,5 +1,5 @@\n import localforage from \"localforage\";\n-import { useEffect, useState } from \"react\";\n+import { useEffect, useState, useRef } from \"react\";\n import Select from \"react-select\";\n import { useRecoilCallback, useRecoilValue } from \"recoil\";\n import { v4 as uuid } from \"uuid\";\n@@ -16,6 +16,7 @@ export default function RogerPanel({\n   ws: WebSocket | null;\n }) {\n   const [trio, setTrio] = useState(\".trio.json\");\n+  const [currentToken, setCurrentToken] = useState<string | null>(null);\n   const workspace = useRecoilValue(currentWorkspaceState);\n   const { substance, style, domain } = workspace.files;\n   const onSelection = useRecoilCallback(\n@@ -81,6 +82,29 @@ export default function RogerPanel({\n       })();\n     }\n   }, [rogerState.kind]);\n+  \n+  // Handle WebSocket messages for trio file responses\n+  useEffect(() => {\n+    if (!ws || !currentToken) return;\n+    \n+    // Define the message handler\n+    const handleMessage = (e: MessageEvent) => {\n+      const parsed = JSON.parse(e.data);\n+      if (parsed.kind !== \"trio_file\" || parsed.token !== currentToken) return;\n+      \n+      const key: \"substance\" | \"style\" | \"domain\" = parsed.type;\n+      const val = parsed.fileName;\n+      onSelection(val, key);\n+    };\n+    \n+    // Add the event listener\n+    ws.addEventListener(\"message\", handleMessage);\n+    \n+    // Clean up the event listener when the component unmounts or when the token changes\n+    return () => {\n+      ws.removeEventListener(\"message\", handleMessage);\n+    };\n+  }, [ws, currentToken, onSelection]);\n   if (rogerState.kind === \"disconnected\") {\n     return (\n       <div>\n@@ -126,6 +150,7 @@ export default function RogerPanel({\n           const token = uuid();\n           if (e?.val) {\n             setTrio(e?.val);\n+            setCurrentToken(token);\n             ws?.send(\n               JSON.stringify({\n                 kind: \"retrieve_trio\",\n@@ -133,13 +158,6 @@ export default function RogerPanel({\n                 token,\n               }),\n             );\n-            ws?.addEventListener(\"message\", (e) => {\n-              const parsed = JSON.parse(e.data);\n-              if (parsed.kind !== \"trio_file\" && parsed.token !== token) return;\n-              const key: \"substance\" | \"style\" | \"domain\" = parsed.type;\n-              const val = parsed.fileName;\n-              onSelection(val, key);\n-            });\n           }\n         }}\n         value={{ val: trio }}"},{"message":"Fix the logic error in RogerPanel.tsx at line 137 where the condition uses && instead of || when checking parsed.kind and parsed.token. The current condition requires both conditions to be true, but it should check if either the kind is not \"trio_file\" OR the token doesn't match.","diff":""},{"message":"Fix the memory leak in App.tsx at line 339 where an event listener for \"beforeunload\" is added in a useEffect hook but no cleanup function is provided to remove the listener when the component unmounts.","diff":"diff --git a/packages/editor/src/App.tsx b/packages/editor/src/App.tsx\nindex 5da6206..e77d390 100644\n--- a/packages/editor/src/App.tsx\n+++ b/packages/editor/src/App.tsx\n@@ -338,6 +338,11 @@ function App() {\n       }\n     };\n     window.addEventListener(\"beforeunload\", handleBeforeUnload);\n+    \n+    // Cleanup function to remove the event listener when component unmounts\n+    return () => {\n+      window.removeEventListener(\"beforeunload\", handleBeforeUnload);\n+    };\n   }, []);\n \n   useEffect(() => {"},{"message":"Fix the memory leak in DiagramPanel.tsx at lines 58-59 where requestAnimationFrame is used with a cleanup function that uses non-null assertion (!). If requestRef.current is null, this could cause a runtime error. Modify the code to safely handle the case where requestRef.current might be null.","diff":"diff --git a/packages/editor/src/components/DiagramPanel.tsx b/packages/editor/src/components/DiagramPanel.tsx\nindex 9a2f720..03bffd2 100644\n--- a/packages/editor/src/components/DiagramPanel.tsx\n+++ b/packages/editor/src/components/DiagramPanel.tsx\n@@ -57,7 +57,11 @@ export default function DiagramPanel() {\n       // request the next frame if the diagram state updates\n       requestRef.current = requestAnimationFrame(step);\n       // Make sure the effect runs only once. Otherwise there might be other `step` calls running in the background causing race conditions\n-      return () => cancelAnimationFrame(requestRef.current!);\n+      return () => {\n+        if (requestRef.current !== undefined) {\n+          cancelAnimationFrame(requestRef.current);\n+        }\n+      };\n     }\n   }, [diagram.state]);\n "},{"message":"Fix the potential security vulnerability in App.tsx where WebSocket messages are parsed using JSON.parse without validation. The issue is at line 307 where `const parsed = JSON.parse(e.data)` is used without any validation of the structure or content of the parsed data before using it. This could lead to prototype pollution or unexpected behavior if malicious data is received. Implement proper validation of the parsed JSON data before using it in the application.","diff":"diff --git a/packages/editor/src/App.tsx b/packages/editor/src/App.tsx\nindex e77d390..f6e96da 100644\n--- a/packages/editor/src/App.tsx\n+++ b/packages/editor/src/App.tsx\n@@ -305,18 +305,67 @@ function App() {\n       toast.success(\"Connected to Roger\");\n     };\n     ws.current.onmessage = (e) => {\n-      const parsed = JSON.parse(e.data);\n-      switch (parsed.kind) {\n-        case \"files\":\n-          setRogerState({ kind: \"connected\", ...parsed.files, ws: ws.current });\n-          break;\n-        case \"file_change\":\n-          updatedFile(parsed.fileName, parsed.contents);\n-          break;\n-        case \"trio_files\":\n-          updateTrio(parsed.files);\n-          updateExcludeWarnings(parsed.excludeWarnings);\n-          break;\n+      try {\n+        // Safely parse the JSON data\n+        const parsed = JSON.parse(e.data);\n+        \n+        // Validate the parsed data has the expected structure\n+        if (!parsed || typeof parsed !== 'object' || parsed === null) {\n+          console.error(\"Invalid message format: not an object\");\n+          return;\n+        }\n+        \n+        // Validate the kind property exists and is a string\n+        if (!parsed.kind || typeof parsed.kind !== 'string') {\n+          console.error(\"Invalid message format: missing or invalid 'kind' property\");\n+          return;\n+        }\n+        \n+        // Process based on validated message kind\n+        switch (parsed.kind) {\n+          case \"files\":\n+            // Validate files property exists and is an object\n+            if (!parsed.files || typeof parsed.files !== 'object') {\n+              console.error(\"Invalid 'files' message: missing or invalid 'files' property\");\n+              return;\n+            }\n+            setRogerState({ kind: \"connected\", ...parsed.files, ws: ws.current });\n+            break;\n+            \n+          case \"file_change\":\n+            // Validate required properties for file_change\n+            if (typeof parsed.fileName !== 'string' || typeof parsed.contents !== 'string') {\n+              console.error(\"Invalid 'file_change' message: missing or invalid 'fileName' or 'contents'\");\n+              return;\n+            }\n+            updatedFile(parsed.fileName, parsed.contents);\n+            break;\n+            \n+          case \"trio_files\":\n+            // Validate files property for trio_files\n+            if (!parsed.files || typeof parsed.files !== 'object') {\n+              console.error(\"Invalid 'trio_files' message: missing or invalid 'files' property\");\n+              return;\n+            }\n+            \n+            // Validate excludeWarnings is an array if present\n+            if (parsed.excludeWarnings !== undefined && !Array.isArray(parsed.excludeWarnings)) {\n+              console.error(\"Invalid 'trio_files' message: 'excludeWarnings' is not an array\");\n+              return;\n+            }\n+            \n+            updateTrio(parsed.files);\n+            if (Array.isArray(parsed.excludeWarnings)) {\n+              updateExcludeWarnings(parsed.excludeWarnings);\n+            }\n+            break;\n+            \n+          default:\n+            console.warn(`Unknown message kind: ${parsed.kind}`);\n+        }\n+      } catch (error) {\n+        // Handle JSON parsing errors\n+        console.error(\"Error parsing WebSocket message:\", error);\n       }\n     };\n   }, []);"},{"message":"Fix the issue in DiagramPanel.tsx where there's a risk of memory leaks due to the useEffect hook not having a cleanup function when the component unmounts while the async function is still running. The issue is at lines 28-51 where an async function is defined and immediately invoked to render the SVG, but there's no cleanup mechanism if the component unmounts during this operation. Implement a proper cleanup function to prevent memory leaks and React warnings about updates on unmounted components.","diff":"diff --git a/packages/editor/src/components/DiagramPanel.tsx b/packages/editor/src/components/DiagramPanel.tsx\nindex 03bffd2..d02d501 100644\n--- a/packages/editor/src/components/DiagramPanel.tsx\n+++ b/packages/editor/src/components/DiagramPanel.tsx\n@@ -29,26 +29,46 @@ export default function DiagramPanel() {\n   useEffect(() => {\n     const cur = canvasRef.current;\n     setCanvasState({ ref: canvasRef }); // required for downloading/exporting diagrams\n+    \n+    // Create a flag to track if component is mounted\n+    let isMounted = true;\n+    \n     if (state !== null && cur !== null) {\n       (async () => {\n-        const rendered = await stateToSVG(state, {\n-          pathResolver: (path: string) =>\n-            pathResolver(path, rogerState, workspace),\n-          width: \"100%\",\n-          height: \"100%\",\n-          texLabels: false,\n-        });\n-        rendered.setAttribute(\"width\", \"100%\");\n-        rendered.setAttribute(\"height\", \"100%\");\n-        if (cur.firstElementChild) {\n-          cur.replaceChild(rendered, cur.firstElementChild);\n-        } else {\n-          cur.appendChild(rendered);\n+        try {\n+          const rendered = await stateToSVG(state, {\n+            pathResolver: (path: string) =>\n+              pathResolver(path, rogerState, workspace),\n+            width: \"100%\",\n+            height: \"100%\",\n+            texLabels: false,\n+          });\n+          \n+          // Check if component is still mounted before updating DOM\n+          if (isMounted) {\n+            rendered.setAttribute(\"width\", \"100%\");\n+            rendered.setAttribute(\"height\", \"100%\");\n+            if (cur.firstElementChild) {\n+              cur.replaceChild(rendered, cur.firstElementChild);\n+            } else {\n+              cur.appendChild(rendered);\n+            }\n+          }\n+        } catch (error) {\n+          // Ignore errors if component is unmounted\n+          if (isMounted) {\n+            console.error(\"Error rendering SVG:\", error);\n+          }\n         }\n       })();\n     } else if (state === null && cur !== null) {\n       cur.innerHTML = \"\";\n     }\n+    \n+    // Cleanup function to prevent updates on unmounted component\n+    return () => {\n+      isMounted = false;\n+    };\n   }, [diagram.state]);\n \n   // TODO: since the diagram state is updated by the `onUpdate` callback provided to the worker, this effect will get triggered every time the diagram state updates, which in turn triggers another `onUpdate` again. Perhaps this is okay?"},{"message":"Fix the issue in main.tsx where the ErrorBoundary component doesn't maintain state to track errors and doesn't render a fallback UI when errors occur. Currently, the ErrorBoundary simply logs errors and displays a toast notification, but continues to render the broken component. Modify the ErrorBoundary component to maintain state tracking whether an error has occurred and render a fallback UI instead of the broken component when an error is detected.","diff":"diff --git a/packages/editor/src/main.tsx b/packages/editor/src/main.tsx\nindex 633d23c..047d14e 100644\n--- a/packages/editor/src/main.tsx\n+++ b/packages/editor/src/main.tsx\n@@ -6,15 +6,72 @@ import { RecoilRoot } from \"recoil\";\n import App from \"./App.js\";\n import \"./index.css\";\n \n-class ErrorBoundary extends Component<{ children: ReactElement }> {\n+class ErrorBoundary extends Component<{ children: ReactElement }, { hasError: boolean; error: Error | null }> {\n   constructor(props: any) {\n     super(props);\n+    this.state = {\n+      hasError: false,\n+      error: null\n+    };\n   }\n+  \n+  static getDerivedStateFromError(error: Error) {\n+    // Update state so the next render will show the fallback UI\n+    return { hasError: true, error };\n+  }\n+  \n   componentDidCatch(error: any, errorInfo: any) {\n+    // Log the error to console and show toast notification\n     console.error(error, errorInfo);\n-    toast.error(error);\n+    toast.error(error.toString());\n   }\n+  \n   render() {\n+    if (this.state.hasError) {\n+      // Render fallback UI when an error has occurred\n+      return (\n+        <div style={{ \n+          padding: '20px', \n+          margin: '20px', \n+          backgroundColor: '#ffdada', \n+          border: '1px solid #ee4e4e',\n+          borderRadius: '4px',\n+          color: '#333'\n+        }}>\n+          <h2 style={{ color: '#ee4e4e' }}>Something went wrong</h2>\n+          <p>The application encountered an error. Please try refreshing the page.</p>\n+          {this.state.error && (\n+            <details style={{ marginTop: '10px', cursor: 'pointer' }}>\n+              <summary>Error Details</summary>\n+              <pre style={{ \n+                padding: '10px', \n+                backgroundColor: '#f8f8f8', \n+                borderRadius: '4px',\n+                overflow: 'auto',\n+                marginTop: '10px'\n+              }}>\n+                {this.state.error.toString()}\n+              </pre>\n+            </details>\n+          )}\n+          <button \n+            onClick={() => this.setState({ hasError: false, error: null })}\n+            style={{\n+              marginTop: '15px',\n+              padding: '8px 16px',\n+              backgroundColor: '#4e4eee',\n+              color: 'white',\n+              border: 'none',\n+              borderRadius: '4px',\n+              cursor: 'pointer'\n+            }}\n+          >\n+            Try Again\n+          </button>\n+        </div>\n+      );\n+    }\n+    \n     return this.props.children;\n   }\n }"},{"message":"Fix the issue in App.tsx where the switch statement in the WebSocket onmessage handler (lines 308-319) doesn't have a default case. This means unexpected message types are silently ignored without any error handling or logging. Add a default case to properly handle unexpected message types, including logging the unexpected message for debugging purposes.","diff":"diff --git a/packages/editor/src/App.tsx b/packages/editor/src/App.tsx\nindex f6e96da..90fed51 100644\n--- a/packages/editor/src/App.tsx\n+++ b/packages/editor/src/App.tsx\n@@ -361,7 +361,9 @@ function App() {\n             break;\n             \n           default:\n+            // Log the unexpected message type for debugging purposes\n             console.warn(`Unknown message kind: ${parsed.kind}`);\n+            console.debug('Unexpected WebSocket message:', parsed);\n         }\n       } catch (error) {\n         // Handle JSON parsing errors"},{"message":"Fix the issue in RogerPanel.tsx where the WebSocket message handler is vulnerable to prototype pollution by parsing JSON without validation. The issue is at line 136 where `const parsed = JSON.parse(e.data)` is used without any validation of the structure or content of the parsed data before using it. Implement proper validation of the parsed JSON data before using it in the application to prevent prototype pollution and other security vulnerabilities.","diff":"diff --git a/packages/editor/src/components/RogerPanel.tsx b/packages/editor/src/components/RogerPanel.tsx\nindex 363d9f3..646a1dd 100644\n--- a/packages/editor/src/components/RogerPanel.tsx\n+++ b/packages/editor/src/components/RogerPanel.tsx\n@@ -8,6 +8,66 @@ import {\n   RogerState,\n   currentWorkspaceState,\n } from \"../state/atoms.js\";\n+\n+// Define the expected structure of trio file messages\n+interface TrioFileMessage {\n+  kind: string;\n+  token: string;\n+  type: ProgramType;\n+  fileName: string;\n+}\n+/**\n+ * Safely parses and validates WebSocket message data to prevent prototype pollution\n+ * @param data The raw message data from WebSocket\n+ * @param expectedToken The token to validate against\n+ * @returns A validated TrioFileMessage object or null if validation fails\n+ */\n+function safeParseTrioFileMessage(data: string, expectedToken: string): TrioFileMessage | null {\n+  try {\n+    // Try to parse the JSON data\n+    const parsed = JSON.parse(data);\n+    \n+    // Basic type checks\n+    if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) {\n+      console.warn('Invalid message format: not an object');\n+      return null;\n+    }\n+    \n+    // Validate required properties and their types\n+    if (typeof parsed.kind !== 'string' || parsed.kind !== 'trio_file') {\n+      return null;\n+    }\n+    \n+    if (typeof parsed.token !== 'string' || parsed.token !== expectedToken) {\n+      return null;\n+    }\n+    \n+    // Validate type is one of the expected ProgramType values\n+    if (typeof parsed.type !== 'string' || \n+        !['substance', 'style', 'domain'].includes(parsed.type)) {\n+      console.warn('Invalid message: type property is not valid');\n+      return null;\n+    }\n+    \n+    if (typeof parsed.fileName !== 'string') {\n+      console.warn('Invalid message: fileName is not a string');\n+      return null;\n+    }\n+    \n+    // Return a new object with only the validated properties\n+    // This prevents any unexpected properties from being used\n+    return {\n+      kind: parsed.kind,\n+      token: parsed.token,\n+      type: parsed.type as ProgramType,\n+      fileName: parsed.fileName\n+    };\n+  } catch (error) {\n+    console.warn('Failed to parse WebSocket message:', error);\n+    return null;\n+  }\n+}\n+\n export default function RogerPanel({\n   rogerState,\n   ws,\n@@ -89,11 +149,15 @@ export default function RogerPanel({\n     \n     // Define the message handler\n     const handleMessage = (e: MessageEvent) => {\n-      const parsed = JSON.parse(e.data);\n-      if (parsed.kind !== \"trio_file\" || parsed.token !== currentToken) return;\n+      // Use the safe parsing function instead of direct JSON.parse\n+      const validatedMessage = safeParseTrioFileMessage(e.data, currentToken);\n+      \n+      // Only proceed if validation passed\n+      if (!validatedMessage) return;\n       \n-      const key: \"substance\" | \"style\" | \"domain\" = parsed.type;\n-      const val = parsed.fileName;\n+      // Use the validated properties\n+      const key = validatedMessage.type;\n+      const val = validatedMessage.fileName;\n       onSelection(val, key);\n     };\n     "},{"message":"Fix the issue in App.tsx where the updatedFile function silently fails when fileName doesn't match any expected files. Currently, in lines 221-245, the function checks if the fileName matches workspace.files.domain.name, workspace.files.style.name, or workspace.files.substance.name, and updates the corresponding file contents if there's a match. However, if the fileName doesn't match any of these, the function silently returns without any error handling or logging. Add proper error handling to log or notify when a file update is attempted for an unknown file name.","diff":"diff --git a/packages/editor/src/App.tsx b/packages/editor/src/App.tsx\nindex 90fed51..3dd3eee 100644\n--- a/packages/editor/src/App.tsx\n+++ b/packages/editor/src/App.tsx\n@@ -240,6 +240,10 @@ function App() {\n             contents,\n           }));\n           await compileDiagram();\n+        } else {\n+          // Log error when attempting to update an unknown file\n+          console.error(`Attempted to update unknown file: ${fileName}`);\n+          toast.error(`Failed to update unknown file: ${fileName}`);\n         }\n       },\n     [],"},{"message":"Fix the issue in DiagramPanel.tsx where error and warning messages are directly rendered without sanitization, which could lead to XSS vulnerabilities. The issue is at lines 122-123 and 145-148 where error and warning messages are directly rendered using `{showError(error).toString()}` and `{unexcludedWarnings.map((w) => showError(w).toString()).join(\"\\n\")}` without any sanitization. Implement proper sanitization of these error and warning messages before rendering them to prevent potential XSS attacks.","diff":"diff --git a/packages/editor/src/components/DiagramPanel.tsx b/packages/editor/src/components/DiagramPanel.tsx\nindex d02d501..d307fbe 100644\n--- a/packages/editor/src/components/DiagramPanel.tsx\n+++ b/packages/editor/src/components/DiagramPanel.tsx\n@@ -14,6 +14,20 @@ import { pathResolver } from \"../utils/downloadUtils.js\";\n import { stateToSVG } from \"../utils/renderUtils.js\";\n import { LayoutTimelineSlider } from \"./LayoutTimelineSlider.js\";\n \n+/**\n+ * Sanitizes HTML content to prevent XSS attacks by escaping special characters\n+ * @param html The string that might contain HTML\n+ * @returns Sanitized string with HTML special characters escaped\n+ */\n+const sanitizeHtml = (html: string): string => {\n+  return html\n+    .replace(/&/g, \"&amp;\")\n+    .replace(/</g, \"&lt;\")\n+    .replace(/>/g, \"&gt;\")\n+    .replace(/\"/g, \"&quot;\")\n+    .replace(/'/g, \"&#039;\");\n+};\n+\n export default function DiagramPanel() {\n   const canvasRef = useRef<HTMLDivElement>(null);\n   const [diagram, setDiagram] = useRecoilState(diagramState);\n@@ -143,9 +157,9 @@ export default function DiagramPanel() {\n             >\n               error ({error.errorType})\n             </span>\n-            <pre style={{ whiteSpace: \"pre-wrap\" }}>\n-              {showError(error).toString()}\n-            </pre>\n+            <pre style={{ whiteSpace: \"pre-wrap\" }}\n+              dangerouslySetInnerHTML={{ __html: sanitizeHtml(showError(error).toString()) }}\n+            ></pre>\n           </div>\n         )}\n         {unexcludedWarnings.length > 0 && (\n@@ -166,11 +180,15 @@ export default function DiagramPanel() {\n             >\n               warnings\n             </span>\n-            <pre style={{ whiteSpace: \"pre-wrap\" }}>\n-              {unexcludedWarnings\n-                .map((w) => showError(w).toString())\n-                .join(\"\\n\")}\n-            </pre>\n+            <pre style={{ whiteSpace: \"pre-wrap\" }}\n+              dangerouslySetInnerHTML={{ \n+                __html: sanitizeHtml(\n+                  unexcludedWarnings\n+                    .map((w) => showError(w).toString())\n+                    .join(\"\\n\")\n+                )\n+              }}\n+            ></pre>\n           </div>\n         )}\n         <div"},{"message":"Fix the issue in DiagramPanel.tsx where the type assertion (error: any) is used without proper type checking in the catch block. The issue is at line 74 where the catch block uses `catch (error: any)` to catch any errors that might occur during the optimization process, but doesn't perform any type checking or validation on the caught error before using it. Implement proper type checking and validation for the caught error to ensure it has the expected structure before using it.","diff":"diff --git a/packages/editor/src/components/DiagramPanel.tsx b/packages/editor/src/components/DiagramPanel.tsx\nindex d307fbe..42d4517 100644\n--- a/packages/editor/src/components/DiagramPanel.tsx\n+++ b/packages/editor/src/components/DiagramPanel.tsx\n@@ -1,4 +1,4 @@\n-import { showError } from \"@penrose/core\";\n+import { showError, PenroseError, RuntimeError } from \"@penrose/core\";\n import { useEffect, useRef, useState } from \"react\";\n import { useRecoilState, useRecoilValue } from \"recoil\";\n import {\n@@ -28,6 +28,21 @@ const sanitizeHtml = (html: string): string => {\n     .replace(/'/g, \"&#039;\");\n };\n \n+/**\n+ * Type guard to check if an error is a PenroseError\n+ * @param error Any error object to check\n+ * @returns Boolean indicating if the error is a valid PenroseError\n+ */\n+const isPenroseError = (error: unknown): error is PenroseError => {\n+  return (\n+    typeof error === 'object' && \n+    error !== null && \n+    'errorType' in error && \n+    typeof (error as PenroseError).errorType === 'string' &&\n+    ['DomainError', 'SubstanceError', 'StyleError', 'RuntimeError'].includes((error as PenroseError).errorType)\n+  );\n+};\n+\n export default function DiagramPanel() {\n   const canvasRef = useRef<HTMLDivElement>(null);\n   const [diagram, setDiagram] = useRecoilState(diagramState);\n@@ -110,11 +125,37 @@ export default function DiagramPanel() {\n             state: info.state,\n           });\n         }\n-      } catch (error: any) {\n-        setDiagram({\n-          ...diagram,\n-          error,\n-        });\n+      } catch (error: unknown) {\n+        // Validate the error structure before using it\n+        if (isPenroseError(error)) {\n+          // If it's a valid PenroseError, use it directly\n+          setDiagram({\n+            ...diagram,\n+            error,\n+          });\n+        } else {\n+          // If it's not a valid PenroseError, create a generic RuntimeError\n+          console.error(\"Caught non-PenroseError during optimization:\", error);\n+          \n+          // Check if it's a standard Error object\n+          const isErrorInstance = (err: unknown): err is { message: string } => \n+            typeof err === 'object' && \n+            err !== null && \n+            'message' in err && \n+            typeof (err as { message: unknown }).message === 'string';\n+          \n+          const genericError: RuntimeError = {\n+            tag: \"RuntimeError\",\n+            errorType: \"RuntimeError\",\n+            message: isErrorInstance(error) \n+              ? error.message \n+              : \"Unknown error during optimization\"\n+          };\n+          setDiagram({\n+            ...diagram,\n+            error: genericError,\n+          });\n+        }\n       }\n     }\n   };"}]},{"title":"Fix Critical Bugs in Editor Worker Subsystem","body":"## Overview\nThis pull request addresses several critical bugs and potential vulnerabilities in the Editor Worker subsystem across multiple files. The fixes cover race conditions, runtime errors, memory leaks, XSS vulnerabilities, and type inconsistencies.\n\n## Key Fixes\n1. **DiagramPanel.tsx**: \n   - Fixed race condition in animation frame handling\n   - Implemented proper cleanup mechanism for animation frames\n   - Ensured only one animation frame is active at a time\n\n2. **worker.ts**:\n   - Added robust null checks for `optState` and `unoptState`\n   - Implemented error handling for potential runtime errors\n   - Added memory leak prevention by limiting history size\n   - Improved error handling in optimization process\n\n3. **errors.ts**:\n   - Fixed type inconsistency in WorkerError union type\n   - Implemented XSS prevention with error message sanitization\n   - Added `sanitizeErrorMessage` function to prevent potential security risks\n\n4. **common.ts**:\n   - Added null checking for `svgCache` to prevent runtime errors\n   - Improved handling of missing rendered elements\n\n5. **OptimizerWorker.ts**:\n   - Refactored compile method to prevent potential stack overflow\n   - Improved state transition handling\n   - Added more robust error handling\n\n## Impact\n- Improved system stability\n- Prevented potential memory leaks\n- Enhanced security against XSS attacks\n- More robust error handling\n- Better type safety\n\n## Testing\nComprehensive testing should be performed to verify:\n- Animation frame handling\n- Error scenarios\n- Memory usage during long optimization runs\n- Error message rendering\n\nResolves potential runtime errors and improves overall system reliability.","commits":[{"message":"Fix the race condition in DiagramPanel.tsx where multiple step calls could be running in the background. The issue is at line 58 where requestAnimationFrame(step) is called when the diagram state updates, but there's no proper cleanup mechanism if multiple updates happen in quick succession. Implement a proper solution that ensures only one animation frame is active at a time.","diff":"diff --git a/packages/editor/src/components/DiagramPanel.tsx b/packages/editor/src/components/DiagramPanel.tsx\nindex 9a2f720..bbcb843 100644\n--- a/packages/editor/src/components/DiagramPanel.tsx\n+++ b/packages/editor/src/components/DiagramPanel.tsx\n@@ -51,15 +51,27 @@ export default function DiagramPanel() {\n     }\n   }, [diagram.state]);\n \n-  // TODO: since the diagram state is updated by the `onUpdate` callback provided to the worker, this effect will get triggered every time the diagram state updates, which in turn triggers another `onUpdate` again. Perhaps this is okay?\n+  // This effect handles the animation frame lifecycle for diagram optimization\n   useEffect(() => {\n     if (workerState.optimizing) {\n-      // request the next frame if the diagram state updates\n+      // Cancel any existing animation frame before creating a new one\n+      if (requestRef.current !== undefined) {\n+        cancelAnimationFrame(requestRef.current);\n+      }\n+      \n+      // Request the next frame if the diagram state updates\n       requestRef.current = requestAnimationFrame(step);\n-      // Make sure the effect runs only once. Otherwise there might be other `step` calls running in the background causing race conditions\n-      return () => cancelAnimationFrame(requestRef.current!);\n+      \n+      // Clean up function to cancel the animation frame when the component unmounts\n+      // or when the diagram state changes\n+      return () => {\n+        if (requestRef.current !== undefined) {\n+          cancelAnimationFrame(requestRef.current);\n+          requestRef.current = undefined;\n+        }\n+      };\n     }\n-  }, [diagram.state]);\n+  }, [diagram.state, workerState.optimizing]);\n \n   const step = async () => {\n     if (state) {"},{"message":"Fix the potential runtime error in worker.ts where optState is used without proper null checks. In the respondShapes and respondUpdate functions, there's a risk that both optState and unoptState could be undefined or null, which would cause runtime errors. Implement proper null checks and error handling to prevent these issues.","diff":"diff --git a/packages/editor/src/worker/worker.ts b/packages/editor/src/worker/worker.ts\nindex 0c9f35c..f0d22cd 100644\n--- a/packages/editor/src/worker/worker.ts\n+++ b/packages/editor/src/worker/worker.ts\n@@ -90,6 +90,15 @@ self.onmessage = async ({ data }: MessageEvent<Req>) => {\n       switch (data.tag) {\n         case \"OptimizingReq\":\n           log.info(\"Received OptimizingReq in state Compiled\");\n+          \n+          if (!unoptState) {\n+            respondError({\n+              tag: \"FatalWorkerError\",\n+              error: runtimeError(\"UnoptState is null in OptimizingReq handler\"),\n+            });\n+            return;\n+          }\n+          \n           const stateWithoutLabels: PartialState = unoptState;\n           unoptState = {\n             ...stateWithoutLabels,\n@@ -104,7 +113,15 @@ self.onmessage = async ({ data }: MessageEvent<Req>) => {\n \n         case \"UpdateReq\":\n           log.info(\"Received UpdateReq in state Compiled\");\n-          respondUpdate(stateToLayoutState(optState ?? unoptState), stats);\n+          const compiledState = optState ?? unoptState;\n+          if (!compiledState) {\n+            respondError({\n+              tag: \"FatalWorkerError\",\n+              error: runtimeError(\"Both optState and unoptState are null in UpdateReq handler\"),\n+            });\n+            return;\n+          }\n+          respondUpdate(stateToLayoutState(compiledState), stats);\n           break;\n \n         case \"ComputeShapesReq\":\n@@ -120,6 +137,15 @@ self.onmessage = async ({ data }: MessageEvent<Req>) => {\n         case \"ResampleReq\":\n           log.info(\"Received ResampleReq in state Compiled\");\n           const { variation } = data;\n+          \n+          if (!unoptState) {\n+            respondError({\n+              tag: \"FatalWorkerError\",\n+              error: runtimeError(\"UnoptState is null in ResampleReq handler\"),\n+            });\n+            return;\n+          }\n+          \n           // resample can fail, but doesn't return a result. Hence, try/catch\n           try {\n             const resampled = resample({ ...unoptState, variation });\n@@ -156,6 +182,13 @@ self.onmessage = async ({ data }: MessageEvent<Req>) => {\n       switch (data.tag) {\n         case \"UpdateReq\":\n           log.info(\"Received UpdateReq in state Optimizing\");\n+          if (!optState) {\n+            respondError({\n+              tag: \"FatalWorkerError\",\n+              error: runtimeError(\"OptState is null in UpdateReq handler during optimization\"),\n+            });\n+            return;\n+          }\n           respondUpdate(stateToLayoutState(optState), stats);\n           break;\n \n@@ -212,14 +245,21 @@ const respondShapes = (index: number) => {\n     });\n     return;\n   }\n-  {\n-    const state = optState ?? unoptState;\n-    const newShapes: LayoutState = stateToLayoutState({\n-      ...state,\n-      varyingValues: history[index],\n+  \n+  const state = optState ?? unoptState;\n+  if (!state) {\n+    respondError({\n+      tag: \"FatalWorkerError\",\n+      error: runtimeError(\"Both optState and unoptState are null in respondShapes\"),\n     });\n-    respondUpdate(newShapes, stats);\n+    return;\n   }\n+  \n+  const newShapes: LayoutState = stateToLayoutState({\n+    ...state,\n+    varyingValues: history[index],\n+  });\n+  respondUpdate(newShapes, stats);\n };\n \n const respondInit = () => {\n@@ -244,6 +284,14 @@ const respondOptimizing = () => {\n };\n \n const respondUpdate = (state: LayoutState, stats: LayoutStats) => {\n+  if (!state) {\n+    respondError({\n+      tag: \"FatalWorkerError\",\n+      error: runtimeError(\"State is null in respondUpdate\"),\n+    });\n+    return;\n+  }\n+  \n   respond({\n     tag: \"UpdateResp\",\n     state,\n@@ -252,6 +300,14 @@ const respondUpdate = (state: LayoutState, stats: LayoutStats) => {\n };\n \n const respondFinished = (state: PenroseState, stats: LayoutStats) => {\n+  if (!state) {\n+    respondError({\n+      tag: \"FatalWorkerError\",\n+      error: runtimeError(\"State is null in respondFinished\"),\n+    });\n+    return;\n+  }\n+  \n   respond({\n     tag: \"FinishedResp\",\n     state: stateToLayoutState(state),\n@@ -260,6 +316,14 @@ const respondFinished = (state: PenroseState, stats: LayoutStats) => {\n };\n \n const optimize = async (state: PenroseState) => {\n+  if (!state) {\n+    respondError({\n+      tag: \"FatalWorkerError\",\n+      error: runtimeError(\"State is null in optimize function\"),\n+    });\n+    return;\n+  }\n+  \n   optState = state;\n   // reset history and stats per optimization run\n   // TODO: actually return them?"},{"message":"Fix the type inconsistency in errors.ts where OptimizationError has a specific nextWorkerState of type WorkerState.Compiled while the WorkerError union type adds a generic nextWorkerState property. This could lead to runtime errors if the specific type is overridden. Update the type definitions to ensure consistency and type safety.","diff":"diff --git a/packages/editor/src/worker/errors.ts b/packages/editor/src/worker/errors.ts\nindex bca73f6..7711f19 100644\n--- a/packages/editor/src/worker/errors.ts\n+++ b/packages/editor/src/worker/errors.ts\n@@ -34,10 +34,10 @@ export type WorkerError =\n       | BadStateError\n       | HistoryIndexOutOfRangeError\n       | CompileError\n-      | OptimizationError\n     ) & {\n       nextWorkerState: WorkerState;\n     })\n+  | OptimizationError\n   | FatalWorkerError;\n \n export const showWorkerError = (error: WorkerError): string => {"},{"message":"Fix the potential XSS vulnerability in the showWorkerError function in errors.ts where error.error is used directly in string interpolation for OptimizationError and FatalWorkerError without sanitization. Implement proper error sanitization to prevent XSS attacks if these error messages are displayed in a UI.","diff":"diff --git a/packages/editor/src/worker/errors.ts b/packages/editor/src/worker/errors.ts\nindex 7711f19..c837d7b 100644\n--- a/packages/editor/src/worker/errors.ts\n+++ b/packages/editor/src/worker/errors.ts\n@@ -40,6 +40,28 @@ export type WorkerError =\n   | OptimizationError\n   | FatalWorkerError;\n \n+/**\n+ * Sanitizes error messages to prevent XSS attacks\n+ * @param message The error message to sanitize\n+ * @returns A sanitized string safe for rendering in HTML\n+ */\n+const sanitizeErrorMessage = (message: unknown): string => {\n+  if (message === null || message === undefined) {\n+    return '';\n+  }\n+  \n+  // Convert to string if it's not already\n+  const str = String(message);\n+  \n+  // Replace HTML special characters with their entity equivalents\n+  return str\n+    .replace(/&/g, '&amp;')\n+    .replace(/</g, '&lt;')\n+    .replace(/>/g, '&gt;')\n+    .replace(/\"/g, '&quot;')\n+    .replace(/'/g, '&#039;');\n+};\n+\n export const showWorkerError = (error: WorkerError): string => {\n   switch (error.tag) {\n     case \"BadStateError\":\n@@ -52,10 +74,10 @@ export const showWorkerError = (error: WorkerError): string => {\n       return showError(error.error);\n \n     case \"OptimizationError\":\n-      return `Error during optimization: ${error.error}`;\n+      return `Error during optimization: ${sanitizeErrorMessage(error.error)}`;\n \n     case \"FatalWorkerError\":\n-      return `Fatal worker error: ${error.error}`;\n+      return `Fatal worker error: ${sanitizeErrorMessage(error.error)}`;\n   }\n };\n "},{"message":"Fix the potential runtime error in common.ts where the addRenderedLabels function uses a non-null assertion operator (!) when retrieving the rendered property from svgCache with svgCache.get(key)!. This assumes the key exists in svgCache without validation. Implement proper null checking to prevent runtime errors if the key doesn't exist in svgCache.","diff":"diff --git a/packages/editor/src/worker/common.ts b/packages/editor/src/worker/common.ts\nindex 1ee0548..228a66a 100644\n--- a/packages/editor/src/worker/common.ts\n+++ b/packages/editor/src/worker/common.ts\n@@ -172,14 +172,20 @@ export const addRenderedLabels = (\n \n   optLabelCache.forEach((value, key) => {\n     if (value.tag === \"EquationData\") {\n-      labelCache.set(key, {\n-        tag: \"EquationData\",\n-        width: value.width,\n-        height: value.height,\n-        rendered: svgCache.get(key)!,\n-        descent: value.descent,\n-        ascent: value.ascent,\n-      });\n+      const renderedElement = svgCache.get(key);\n+      if (renderedElement) {\n+        labelCache.set(key, {\n+          tag: \"EquationData\",\n+          width: value.width,\n+          height: value.height,\n+          rendered: renderedElement,\n+          descent: value.descent,\n+          ascent: value.ascent,\n+        });\n+      } else {\n+        // Skip this entry or create a fallback if the rendered element doesn't exist\n+        console.warn(`Rendered element not found in svgCache for key: ${key}`);\n+      }\n     } else {\n       labelCache.set(key, value);\n     }"},{"message":"Fix the memory leak issue in worker.ts where the history array could potentially grow very large if many optimization steps are taken. Implement a mechanism to limit its size or clear it when it's no longer needed to prevent memory issues during long optimization runs.","diff":"diff --git a/packages/editor/src/worker/worker.ts b/packages/editor/src/worker/worker.ts\nindex f0d22cd..577e78f 100644\n--- a/packages/editor/src/worker/worker.ts\n+++ b/packages/editor/src/worker/worker.ts\n@@ -39,6 +39,9 @@ let optState: PenroseState | null = null;\n // the UUID of the current task\n let currentTask: string;\n \n+// Maximum number of frames to keep in history to prevent memory leaks\n+const MAX_HISTORY_SIZE = 1000;\n+\n let history: Frame[] = [];\n let stats: LayoutStats = [];\n let workerState: WorkerState = WorkerState.Init;\n@@ -236,6 +239,8 @@ const compileAndRespond = async (data: CompiledReq) => {\n };\n \n const respondShapes = (index: number) => {\n+  // The history array is limited to MAX_HISTORY_SIZE frames to prevent memory leaks\n+  // Older frames may have been removed if the history exceeded the maximum size\n   if (index >= history.length) {\n     respondError({\n       tag: \"HistoryIndexOutOfRangeError\",\n@@ -356,7 +361,15 @@ const optimize = async (state: PenroseState) => {\n \n       log.info(i);\n       let j = 0;\n+      \n+      // Add new frame to history and maintain maximum size to prevent memory leaks\n       history.push(state.varyingValues);\n+      if (history.length > MAX_HISTORY_SIZE) {\n+        // Remove oldest frames when exceeding the maximum size\n+        const removedCount = history.length - MAX_HISTORY_SIZE;\n+        log.info(`History size limit reached. Removing ${removedCount} oldest frames to prevent memory leaks.`);\n+        history = history.slice(-MAX_HISTORY_SIZE);\n+      }\n       const steppedState = step(state, {\n         until: (): boolean => j++ >= numStepsPerHistory,\n       });"},{"message":"Fix the incomplete implementation in the OptimizerWorker class's onMessage method where there's a case for OptimizingToCompiled that handles UpdateResp but doesn't do anything with it (lines 431-432). Either implement proper handling for this case or remove the empty case statement to improve code clarity.","diff":"diff --git a/packages/editor/src/worker/OptimizerWorker.ts b/packages/editor/src/worker/OptimizerWorker.ts\nindex fb2bd97..5109a0e 100644\n--- a/packages/editor/src/worker/OptimizerWorker.ts\n+++ b/packages/editor/src/worker/OptimizerWorker.ts\n@@ -429,7 +429,9 @@ export default class OptimizerWorker {\n             });\n             break;\n \n-          case \"UpdateResp\":\n+          default:\n+            logErrorBadState();\n+            break;\n         }\n         break;\n "},{"message":"Fix the potential stack overflow issue in the OptimizerWorker class's compile method where it calls interruptOptimizing and then compile again recursively. This could lead to a stack overflow if there are many nested calls. Implement a non-recursive solution to handle the case when compilation is requested while in the Optimizing state.","diff":"diff --git a/packages/editor/src/worker/OptimizerWorker.ts b/packages/editor/src/worker/OptimizerWorker.ts\nindex 5109a0e..91cf6f6 100644\n--- a/packages/editor/src/worker/OptimizerWorker.ts\n+++ b/packages/editor/src/worker/OptimizerWorker.ts\n@@ -540,6 +540,68 @@ export default class OptimizerWorker {\n     });\n   }\n \n+  /**\n+   * Compile a diagram. Places optimizer into 'Compiled' state.\n+   * @param domain\n+   * @param style\n+   * @param substance\n+   * @param variation\n+   */\n+  /**\n+   * Helper method to send a compilation request\n+   * @private\n+   */\n+  private sendCompileRequest(\n+    domain: string,\n+    style: string,\n+    substance: string,\n+    variation: string,\n+    resolve: (value: CompiledInfo | PromiseLike<CompiledInfo>) => void,\n+    reject: (reason?: any) => void\n+  ): void {\n+    const jobId: string = uuid();\n+    const req: CompiledReq = {\n+      tag: \"CompiledReq\",\n+      substance,\n+      style,\n+      domain,\n+      variation,\n+      jobId,\n+    };\n+    \n+    // Create a safe previous state that's either Init or Compiled\n+    let safeState: Init | Compiled;\n+    \n+    if (this.state.tag === \"Init\") {\n+      // If we're already in Init state, use it directly\n+      safeState = this.state;\n+    } else if (this.state.tag === \"Compiled\") {\n+      // If we're already in Compiled state, use it directly\n+      safeState = this.state;\n+    } else if (this.state.tag === \"Optimizing\") {\n+      // Convert Optimizing to Compiled with necessary properties\n+      safeState = {\n+        tag: \"Compiled\",\n+        svgCache: this.state.svgCache,\n+        labelCache: this.state.labelCache,\n+        layoutStats: [],\n+        polled: false\n+      };\n+    } else {\n+      // For any other state, create a basic Init state\n+      safeState = { tag: \"Init\" };\n+    }\n+    \n+    this.setState({\n+      tag: \"InitToCompiled\",\n+      waiting: true,\n+      previous: safeState,\n+      resolve,\n+      reject,\n+    });\n+    this.request(req);\n+  }\n+\n   /**\n    * Compile a diagram. Places optimizer into 'Compiled' state.\n    * @param domain\n@@ -555,40 +617,29 @@ export default class OptimizerWorker {\n   ): Promise<CompiledInfo> {\n     log.info(`compile called from state ${this.state.tag}`);\n     return new Promise(async (resolve, reject) => {\n+      // Wait for any pending state transitions to complete\n       while (isWaiting(this.state)) await this.waitForNextState();\n \n       log.info(`compile running from state ${this.state.tag}`);\n-      switch (this.state.tag) {\n-        case \"Init\":\n-        case \"Compiled\": {\n-          const jobId: string = uuid();\n-          const req: CompiledReq = {\n-            tag: \"CompiledReq\",\n-            substance,\n-            style,\n-            domain,\n-            variation,\n-            jobId,\n-          };\n-          this.setState({\n-            tag: \"InitToCompiled\",\n-            waiting: true,\n-            previous: this.state,\n-            resolve,\n-            reject,\n-          });\n-          this.request(req);\n-          break;\n-        }\n-\n-        case \"Optimizing\": {\n+      \n+      // Handle the Optimizing state first - we need to interrupt before compiling\n+      if (this.state.tag === \"Optimizing\") {\n+        try {\n+          // First interrupt the optimization process\n           await this.interruptOptimizing();\n-          const jobId = await this.compile(domain, style, substance, variation);\n-          resolve(jobId);\n-          break;\n+          \n+          // After interrupting, we should be in Compiled state\n+          // Now we can send the compile request directly\n+          this.sendCompileRequest(domain, style, substance, variation, resolve, reject);\n+        } catch (error) {\n+          reject(error);\n         }\n-\n-        // exhaustive\n+      } else if (this.state.tag === \"Init\" || this.state.tag === \"Compiled\") {\n+        // For Init or Compiled states, we can directly send the compile request\n+        this.sendCompileRequest(domain, style, substance, variation, resolve, reject);\n+      } else {\n+        // Handle any other unexpected states\n+        reject(runtimeError(`Cannot compile from state ${this.state.tag}`));\n       }\n     });\n   }"},{"message":"Fix the error handling in worker.ts where in the WorkerState.Compiled case, when handling a ResampleReq, there's a catch block that catches any error (err: any) and passes it directly to respondError without checking if it's a WorkerError. Implement proper error type checking and conversion to ensure that only valid WorkerError objects are passed to respondError.","diff":"diff --git a/packages/editor/src/worker/worker.ts b/packages/editor/src/worker/worker.ts\nindex 577e78f..f30ab0b 100644\n--- a/packages/editor/src/worker/worker.ts\n+++ b/packages/editor/src/worker/worker.ts\n@@ -22,7 +22,7 @@ import {\n   stateToLayoutState,\n   WorkerState,\n } from \"./common.js\";\n-import { WorkerError } from \"./errors.js\";\n+import { WorkerError, isWorkerError } from \"./errors.js\";\n \n type Frame = number[];\n \n@@ -156,7 +156,15 @@ self.onmessage = async ({ data }: MessageEvent<Req>) => {\n             respondOptimizing();\n             optimize(insertPending(resampled));\n           } catch (err: any) {\n-            respondError(err);\n+            if (isWorkerError(err)) {\n+              respondError(err);\n+            } else {\n+              respondError({\n+                tag: \"OptimizationError\",\n+                error: err,\n+                nextWorkerState: WorkerState.Compiled\n+              });\n+            }\n           }\n           break;\n \n@@ -409,7 +417,15 @@ const optimize = async (state: PenroseState) => {\n       log.info(\"Optimization failed. Quitting without finishing...\");\n       workerState = WorkerState.Compiled;\n       optState = null;\n-      respondError(err);\n+      if (isWorkerError(err)) {\n+        respondError(err);\n+      } else {\n+        respondError({\n+          tag: \"OptimizationError\",\n+          error: err,\n+          nextWorkerState: WorkerState.Compiled\n+        });\n+      }\n       return;\n     }\n   };"}]}]}