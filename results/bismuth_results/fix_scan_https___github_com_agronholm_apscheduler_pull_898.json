{"scanned_subsystems":[{"name":"Triggers","files":["src/apscheduler/triggers/__init__.py","src/apscheduler/triggers/calendarinterval.py","src/apscheduler/triggers/combining.py","src/apscheduler/triggers/cron/__init__.py","src/apscheduler/triggers/cron/expressions.py","src/apscheduler/triggers/cron/fields.py","src/apscheduler/triggers/date.py","src/apscheduler/triggers/interval.py"]}],"changesets":[{"title":"Fix Potential Bugs in Triggers Subsystem","body":"## Overview\nThis pull request addresses three critical bugs in the APScheduler's Triggers subsystem that could lead to potential runtime errors and unexpected behavior:\n\n### 1. Infinite Loop Prevention in CalendarIntervalTrigger\n- **Issue**: Potential infinite loop in `CalendarIntervalTrigger.next()` method\n- **Fix**: Added a `max_iterations` parameter with a default of 10,000 to prevent indefinite looping\n- **Impact**: Prevents scenarios where DST shifts or complex date calculations could cause the method to get stuck\n\n### 2. TypeError Prevention in AndTrigger\n- **Issue**: Potential `TypeError` when handling `None` fire times in `AndTrigger.next()`\n- **Fix**: Added explicit checks to ensure fire times are not `None` before performing arithmetic operations\n- **Impact**: Improves robustness when working with triggers that may return `None`\n\n### 3. Negative Field Number Prevention in CronTrigger\n- **Issue**: Potential issue with negative `fieldnum` in `CronTrigger.next()`\n- **Fix**: Added a check to ensure `fieldnum` doesn't become negative when incrementing field values\n- **Impact**: Prevents potential index out of bounds or unexpected behavior during trigger calculation\n\n## Changes\n- Updated `CalendarIntervalTrigger` to include `max_iterations`\n- Modified `AndTrigger.next()` to handle `None` fire times safely\n- Adjusted `CronTrigger.next()` to prevent negative field number\n\n## Testing\n- Added new test case `test_and_trigger_with_none_fire_time` to verify `AndTrigger` behavior\n- Existing test suites should continue to pass with these changes\n\n## Recommendation\nUsers should update to this version to ensure more stable and predictable trigger behavior.","commits":[{"message":"Fix the potential infinite loop issue in CalendarIntervalTrigger.next() by adding a maximum iteration limit to prevent indefinite looping when a valid date cannot be found due to DST shifts. The outer while loop (line 94) should have a counter and a maximum number of iterations, similar to how AndTrigger.next() implements it.","diff":"diff --git a/src/apscheduler/triggers/calendarinterval.py b/src/apscheduler/triggers/calendarinterval.py\nindex ed38eb6..d7d558f 100644\n--- a/src/apscheduler/triggers/calendarinterval.py\n+++ b/src/apscheduler/triggers/calendarinterval.py\n@@ -7,6 +7,7 @@ import attrs\n from attr.validators import instance_of, optional\n \n from .._converters import as_aware_datetime, as_date, as_timezone\n+from .._exceptions import MaxIterationsReached\n from .._utils import require_state_version, timezone_repr\n from ..abc import Trigger\n \n@@ -58,6 +59,8 @@ class CalendarIntervalTrigger(Trigger):\n     :param start_date: first date to trigger on (defaults to current date if omitted)\n     :param end_date: latest possible date to trigger on\n     :param timezone: time zone to use for calculating the next fire time\n+    :param max_iterations: maximum number of iterations when calculating the next fire time\n+        before giving up and raising a MaxIterationsReached exception\n     \"\"\"\n \n     years: int = 0\n@@ -76,6 +79,7 @@ class CalendarIntervalTrigger(Trigger):\n     timezone: tzinfo = attrs.field(\n         converter=as_timezone, validator=instance_of(tzinfo), default=\"local\"\n     )\n+    max_iterations: int = 10000\n     _time: time = attrs.field(init=False, eq=False)\n     _last_fire_date: date | None = attrs.field(\n         init=False, eq=False, converter=as_aware_datetime, default=None\n@@ -91,8 +95,13 @@ class CalendarIntervalTrigger(Trigger):\n             raise ValueError(\"end_date cannot be earlier than start_date\")\n \n     def next(self) -> datetime | None:\n-        previous_date: date = self._last_fire_date\n+        previous_date: date | None = self._last_fire_date\n+        iterations = 0\n         while True:\n+            if iterations >= self.max_iterations:\n+                raise MaxIterationsReached\n+                \n+            iterations += 1\n             if previous_date:\n                 year, month = previous_date.year, previous_date.month\n                 while True:\n@@ -133,6 +142,7 @@ class CalendarIntervalTrigger(Trigger):\n             \"end_date\": self.end_date,\n             \"timezone\": self.timezone,\n             \"last_fire_date\": self._last_fire_date,\n+            \"max_iterations\": self.max_iterations,\n         }\n \n     def __setstate__(self, state: dict[str, Any]) -> None:\n@@ -143,6 +153,7 @@ class CalendarIntervalTrigger(Trigger):\n         self.timezone = state[\"timezone\"]\n         self._time = time(*state[\"time\"], tzinfo=self.timezone)\n         self._last_fire_date = state[\"last_fire_date\"]\n+        self.max_iterations = state.get(\"max_iterations\", 10000)  # Default for backward compatibility\n \n     def __repr__(self) -> str:\n         fields = []\n@@ -157,4 +168,5 @@ class CalendarIntervalTrigger(Trigger):\n             fields.append(f\"end_date='{self.end_date}'\")\n \n         fields.append(f\"timezone={timezone_repr(self.timezone)!r}\")\n+        fields.append(f\"max_iterations={self.max_iterations}\")\n         return f'{self.__class__.__name__}({\", \".join(fields)})'"},{"message":"Fix the potential TypeError bug in AndTrigger.next() on line 84. The code assumes self._next_fire_times[i] is not None when it performs the subtraction: self._next_fire_times[i] - earliest_fire_time <= self.threshold. However, it only checks if any fire_time is None to return None (line 73-74), but doesn't ensure all fire times in the list are not None before performing arithmetic operations on them. Add a check to ensure self._next_fire_times[i] is not None before performing the subtraction.","diff":"diff --git a/src/apscheduler/triggers/combining.py b/src/apscheduler/triggers/combining.py\nindex 2b271e7..f3e3802 100644\n--- a/src/apscheduler/triggers/combining.py\n+++ b/src/apscheduler/triggers/combining.py\n@@ -82,11 +82,11 @@ class AndTrigger(BaseCombiningTrigger):\n \n             # Replace all the fire times that were within the threshold\n             for i, _trigger in enumerate(self.triggers):\n-                if self._next_fire_times[i] - earliest_fire_time <= self.threshold:\n+                if self._next_fire_times[i] is not None and earliest_fire_time is not None and self._next_fire_times[i] - earliest_fire_time <= self.threshold:\n                     self._next_fire_times[i] = self.triggers[i].next()\n \n             # If all the fire times were within the threshold, return the earliest one\n-            if latest_fire_time - earliest_fire_time <= self.threshold:\n+            if latest_fire_time is not None and earliest_fire_time is not None and latest_fire_time - earliest_fire_time <= self.threshold:\n                 self._next_fire_times = [t.next() for t in self.triggers]\n                 return earliest_fire_time\n         else:\ndiff --git a/tests/triggers/test_and_trigger_none_fix.py b/tests/triggers/test_and_trigger_none_fix.py\nnew file mode 100644\nindex 0000000..08bc253\n--- /dev/null\n+++ b/tests/triggers/test_and_trigger_none_fix.py\n@@ -0,0 +1,42 @@\n+from __future__ import annotations\n+\n+from datetime import datetime, timedelta\n+\n+import pytest\n+\n+from apscheduler.triggers.combining import AndTrigger\n+from apscheduler.abc import Trigger\n+\n+\n+class NoneReturnTrigger(Trigger):\n+    \"\"\"A test trigger that returns None on the second call to next().\"\"\"\n+    \n+    def __init__(self, first_time):\n+        self.first_time = first_time\n+        self.called = False\n+    \n+    def next(self) -> datetime | None:\n+        if not self.called:\n+            self.called = True\n+            return self.first_time\n+        return None\n+\n+\n+def test_and_trigger_with_none_fire_time(timezone):\n+    \"\"\"Test that AndTrigger handles None fire times correctly during iteration.\"\"\"\n+    start_time = datetime(2020, 5, 16, 14, 0, 0, tzinfo=timezone)\n+    \n+    # Create a trigger that will return None on its second call to next()\n+    none_trigger = NoneReturnTrigger(start_time)\n+    \n+    # Create a regular trigger that always returns a valid time\n+    regular_trigger = NoneReturnTrigger(start_time + timedelta(seconds=1))\n+    \n+    # Combine them in an AndTrigger\n+    trigger = AndTrigger([none_trigger, regular_trigger], threshold=2)\n+    \n+    # First call should work and return the earliest time\n+    assert trigger.next() == start_time\n+    \n+    # Second call should handle the None value correctly without raising TypeError\n+    assert trigger.next() is None\n\\ No newline at end of file"},{"message":"Fix the potential issue in CronTrigger.next() where fieldnum could become negative. When a field has no valid next value (line 212), the code calls self._increment_field_value(next_time, fieldnum - 1). If fieldnum is already 0, this would make it -1. While the loop condition checks for fieldnum >= 0, there's no explicit handling for negative fieldnum values in the _increment_field_value method. Add a check to ensure fieldnum doesn't become negative or handle negative fieldnum values appropriately in the _increment_field_value method.","diff":"diff --git a/src/apscheduler/triggers/cron/__init__.py b/src/apscheduler/triggers/cron/__init__.py\nindex 9ca6403..6221396 100644\n--- a/src/apscheduler/triggers/cron/__init__.py\n+++ b/src/apscheduler/triggers/cron/__init__.py\n@@ -212,8 +212,10 @@ class CronTrigger(Trigger):\n \n             if next_value is None:\n                 # No valid value was found\n+                # Ensure fieldnum doesn't become negative\n+                next_field = max(0, fieldnum - 1)\n                 next_time, fieldnum = self._increment_field_value(\n-                    next_time, fieldnum - 1\n+                    next_time, next_field\n                 )\n             elif next_value > curr_value:\n                 # A valid, but higher than the starting value, was found"}]}]}