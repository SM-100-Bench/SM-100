{"scanned_subsystems":[{"name":"EPUB Viewer","files":["src/dom/epub/cfi.ts","src/dom/epub/defines.ts","src/dom/epub/epub-view.ts","src/dom/epub/find.ts","src/dom/epub/flow.ts","src/dom/epub/lib/page-mapping.ts","src/dom/epub/lib/sanitize-and-render.ts","src/dom/epub/section-view.ts","src/dom/epub/stylesheets/content.css"]}],"changesets":[{"title":"Bismuth: fix 15 bugs in EPUB Viewer","body":"Fixes:\n- Fix the bug in SectionView's NodeFilter function (lines 93-98) where there's ambiguous operator precedence in the condition: 'node.nodeType == Node.TEXT_NODE && node.nodeValue?.trim().length || (node as Element).tagName === 'IMG''. This could lead to unexpected filtering behavior if a text node is empty but the code still tries to check its tagName property. The fix should ensure proper type checking before accessing element-specific properties.\n- Fix the bug in ScrolledFlow's scrollIntoView method (lines 210-244) where it calls getBoundingClientRect() before checking the type of the target. This could cause runtime errors if the target is not a valid Range or HTMLElement. Rewrite the method to first check the type of the target and then call the appropriate methods based on the type.\n- Fix the bug in StyleScoper's _visitRule method (lines 152-199) where it relies on constructor.name to determine the type of CSS rule. This approach is not reliable across all browsers and can be affected by minification. Replace the constructor.name checks with more reliable type checking using instanceof or the type property of CSS rules.\n- Fix the security vulnerability in StyleScoper's addByURL method (lines 134-144) where it fetches CSS from a URL without validating the URL or the content. Implement proper URL validation to ensure it's from a trusted source or within the EPUB package, add error handling for failed fetches, and consider adding basic CSS content validation before applying it.\n- Fix the security vulnerability in the sanitizeAndRender function where it doesn't properly sanitize potentially dangerous HTML elements like script, iframe, or object, nor does it sanitize URLs in attributes like href or src. Implement proper HTML sanitization to prevent XSS attacks by: 1) Adding a whitelist of allowed elements, 2) Sanitizing all URLs to prevent JavaScript execution, 3) Removing all script and event handler attributes, and 4) Implementing proper attribute sanitization.\n- Fix the security vulnerability in EPUBView's setFontFamily method (lines 562-565) where it directly sets a CSS variable with user input without proper sanitization. Implement proper validation to ensure the input is a legitimate font family name, escape any special characters that could break out of the CSS property value context, and consider using a whitelist of allowed font families to prevent CSS injection attacks.\n- Fix the bug in EPUBView's getRange method (lines 240-267) where it creates a new EpubCFI object from a string but immediately tries to access cfi.spinePos without checking if the conversion was successful. Implement proper error handling by adding a try-catch block around the EpubCFI construction, validating that the created object has a valid spinePos property, and handling conversion failures gracefully.\n- Fix the bug in AbstractFlow's visibleViews getter (lines 141-151) where it doesn't validate the indexOf results when finding _cachedStartView and _cachedEndView in the views array. This could lead to unexpected slicing behavior if either view is not found (indexOf returns -1). Implement proper validation to check if either view wasn't found and handle that case appropriately.\n- Fix the security vulnerability in EPUBView's navigate method (lines 663-665) where it uses querySelector with a user-provided hash. While the code does replace double quotes with escaped quotes, there could be other injection vectors. Implement proper validation to ensure the hash is a valid HTML5 ID and use a safer method like getElementById or CSS.escape() to prevent selector injection attacks.\n- Fix the issue in the sanitizeAndRender function's tree walker loop (lines 17-48) where it modifies the DOM while traversing it, which could lead to unexpected behavior or missed elements. Refactor the function to first collect all elements that need modification without changing the DOM, and then apply the modifications after the traversal is complete.\n- Fix the issue in the shortenCFI and lengthenCFI functions where they don't validate that the input is a valid CFI string. Implement proper validation to check if the input is a valid CFI string before processing it, handle edge cases like null, undefined, or non-string inputs, and provide consistent behavior for invalid inputs.\n- Fix the accessibility issue in PaginatedFlow's _handleTouchMove method (lines 547-566) where it calls event.preventDefault() unconditionally, which could interfere with other touch interactions and break accessibility features. Modify the method to only prevent default behavior when it's determined that the touch movement is actually being used for page navigation, and implement a threshold before claiming the touch event.\n- Fix the issue in PaginatedFlow's constructor (line 357) where it assumes that the .sections element exists in the DOM without proper error handling. Implement proper error handling to check if the element exists before assigning it, and provide a fallback mechanism to create the element if it doesn't exist.\n- Fix the issue in EPUBFindProcessor's _processViews method (lines 112-119) where it checks if this._totalResults > maxResults but doesn't check if adding the current batch would exceed maxResults. Implement a better approach that checks the number of results after processing each view and breaks the loop if the limit has been reached or exceeded, and consider modifying the _getOrCreateProcessor method to accept a remainingResults parameter to limit the number of results it adds.\n- Fix the inefficiency issue in EPUBFindProcessor's prev and next methods (lines 37-94) where they loop through all processors and return null if there are no search results, which could be inefficient for large documents with many sections. Implement a more efficient approach by adding a property to track if we've already determined there are no results, and modify the methods to return early in that case.","commits":[{"message":"Fix the bug in SectionView's NodeFilter function (lines 93-98) where there's ambiguous operator precedence in the condition: 'node.nodeType == Node.TEXT_NODE && node.nodeValue?.trim().length || (node as Element).tagName === 'IMG''. This could lead to unexpected filtering behavior if a text node is empty but the code still tries to check its tagName property. The fix should ensure proper type checking before accessing element-specific properties.","diff":"diff --git a/src/dom/epub/section-view.ts b/src/dom/epub/section-view.ts\nindex b085197..6a09cd2 100644\n--- a/src/dom/epub/section-view.ts\n+++ b/src/dom/epub/section-view.ts\n@@ -92,10 +92,10 @@ class SectionView {\n \t\tlet viewportEnd = isHorizontal ? this._window.frameElement!.clientWidth : this._window.frameElement!.clientHeight;\n \t\tlet filter = NodeFilter.SHOW_TEXT | (textNodesOnly ? 0 : NodeFilter.SHOW_ELEMENT);\n \t\tlet iter = this._document.createNodeIterator(this.container, filter, (node) => {\n-\t\t\treturn node.nodeType == Node.TEXT_NODE && node.nodeValue?.trim().length\n-\t\t\t\t\t|| (node as Element).tagName === 'IMG'\n-\t\t\t\t? NodeFilter.FILTER_ACCEPT\n-\t\t\t\t: NodeFilter.FILTER_SKIP;\n+\t\t\treturn (\n+\t\t\t\t(node.nodeType == Node.TEXT_NODE && node.nodeValue?.trim().length) || \n+\t\t\t\t(node.nodeType == Node.ELEMENT_NODE && (node as Element)?.tagName === 'IMG')\n+\t\t\t) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n \t\t});\n \t\tlet node = null;\n \t\tlet bestRange = null;"},{"message":"Fix the bug in ScrolledFlow's scrollIntoView method (lines 210-244) where it calls getBoundingClientRect() before checking the type of the target. This could cause runtime errors if the target is not a valid Range or HTMLElement. Rewrite the method to first check the type of the target and then call the appropriate methods based on the type.","diff":"diff --git a/src/dom/epub/flow.ts b/src/dom/epub/flow.ts\nindex c6b4b52..46496e8 100644\n--- a/src/dom/epub/flow.ts\n+++ b/src/dom/epub/flow.ts\n@@ -209,6 +209,15 @@ export class ScrolledFlow extends AbstractFlow {\n \t}\n \n \tscrollIntoView(target: Range | HTMLElement, options?: CustomScrollIntoViewOptions): void {\n+\t\t// First check the type of the target\n+\t\tif ('nodeType' in target) {\n+\t\t\t// Handle HTMLElement\n+\t\t\ttarget.scrollIntoView(options);\n+\t\t\tthis.invalidate();\n+\t\t\treturn;\n+\t\t}\n+\t\t\n+\t\t// Now we know it's a Range, safe to call getBoundingClientRect()\n \t\tlet rect = target.getBoundingClientRect();\n \n \t\tif (options?.ifNeeded && (rect.top >= 0 && rect.bottom < this._iframe.clientHeight)) {\n@@ -221,12 +230,6 @@ export class ScrolledFlow extends AbstractFlow {\n \t\t\toptions.behavior = 'auto';\n \t\t}\n \n-\t\tif ('nodeType' in target) {\n-\t\t\ttarget.scrollIntoView(options);\n-\t\t\tthis.invalidate();\n-\t\t\treturn;\n-\t\t}\n-\n \t\tlet x = rect.x + rect.width / 2;\n \t\tlet y = rect.y;\n \t\tif (options && options.block == 'center') {"},{"message":"Fix the bug in StyleScoper's _visitRule method (lines 152-199) where it relies on constructor.name to determine the type of CSS rule. This approach is not reliable across all browsers and can be affected by minification. Replace the constructor.name checks with more reliable type checking using instanceof or the type property of CSS rules.","diff":"diff --git a/src/dom/epub/lib/sanitize-and-render.ts b/src/dom/epub/lib/sanitize-and-render.ts\nindex 4e72483..2f40353 100644\n--- a/src/dom/epub/lib/sanitize-and-render.ts\n+++ b/src/dom/epub/lib/sanitize-and-render.ts\n@@ -151,10 +151,12 @@ export class StyleScoper {\n \t}\n \n \tprivate _visitRule(rule: CSSRule, scopeClass: string) {\n-\t\tif (rule.constructor.name === 'CSSStyleRule') {\n+\t\t// Use rule.type instead of constructor.name for more reliable type checking\n+\t\t// CSSStyleRule.type === 1\n+\t\tif (rule.type === 1) {\n \t\t\tlet styleRule = rule as CSSStyleRule;\n-\t\t\tstyleRule.selectorText = parser((selectors) => {\n-\t\t\t\tselectors.each((selector) => {\n+\t\t\tstyleRule.selectorText = parser((selectors: any) => {\n+\t\t\t\tselectors.each((selector: any) => {\n \t\t\t\t\tselector.replaceWith(\n \t\t\t\t\t\tparser.selector({\n \t\t\t\t\t\t\tvalue: '',\n@@ -163,7 +165,7 @@ export class StyleScoper {\n \t\t\t\t\t\t\t\tparser.combinator({ value: ' ' }),\n \t\t\t\t\t\t\t\tparser.selector({\n \t\t\t\t\t\t\t\t\t...selector,\n-\t\t\t\t\t\t\t\t\tnodes: selector.nodes.map((node) => {\n+\t\t\t\t\t\t\t\t\tnodes: selector.nodes.map((node: any) => {\n \t\t\t\t\t\t\t\t\t\tif (node.type === 'tag' && REPLACE_TAGS.has(node.value.toLowerCase())) {\n \t\t\t\t\t\t\t\t\t\t\treturn parser.tag({\n \t\t\t\t\t\t\t\t\t\t\t\t...node,\n@@ -186,9 +188,12 @@ export class StyleScoper {\n \t\t\t\tthis.tableSelectors.add(styleRule.selectorText);\n \t\t\t}\n \t\t}\n-\t\telse if (rule.constructor.name === 'CSSImportRule') {\n+\t\t// CSSImportRule.type === 3\n+\t\telse if (rule.type === 3) {\n \t\t\tlet importRule = rule as CSSImportRule;\n-\t\t\tthis._visitStyleSheet(importRule.styleSheet, scopeClass);\n+\t\t\tif (importRule.styleSheet) {\n+\t\t\t\tthis._visitStyleSheet(importRule.styleSheet, scopeClass);\n+\t\t\t}\n \t\t}\n \n \t\t// If this rule contains child rules, visit each of them"},{"message":"Fix the security vulnerability in StyleScoper's addByURL method (lines 134-144) where it fetches CSS from a URL without validating the URL or the content. Implement proper URL validation to ensure it's from a trusted source or within the EPUB package, add error handling for failed fetches, and consider adding basic CSS content validation before applying it.","diff":"diff --git a/src/dom/epub/lib/sanitize-and-render.ts b/src/dom/epub/lib/sanitize-and-render.ts\nindex 2f40353..1ca52fa 100644\n--- a/src/dom/epub/lib/sanitize-and-render.ts\n+++ b/src/dom/epub/lib/sanitize-and-render.ts\n@@ -86,11 +86,19 @@ export class StyleScoper {\n \t/**\n \t * @param css CSS stylesheet code\n \t * @return A class to add to the scope element\n+\t * @throws Error if CSS content is unsafe\n \t */\n \tasync add(css: string): Promise<string> {\n \t\tif (this._sheets.has(css)) {\n \t\t\treturn this._sheets.get(css)!.scopeClass;\n \t\t}\n+\t\t\n+\t\t// Validate CSS content before processing\n+\t\tif (!this._isCssSafe(css)) {\n+\t\t\tconsole.error('Unsafe CSS content rejected');\n+\t\t\tthrow new Error('CSS content contains potentially unsafe patterns');\n+\t\t}\n+\t\t\n \t\tlet scopeClass = `__scope_${this._sheets.size}`;\n \t\tthis._sheets.set(css, { scopeClass });\n \n@@ -128,19 +136,107 @@ export class StyleScoper {\n \t\treturn scopeClass;\n \t}\n \n+\t/**\n+\t * Validates if a URL is safe to fetch from\n+\t * @param url The URL to validate\n+\t * @return boolean indicating if the URL is safe\n+\t */\n+\tprivate _isUrlSafe(url: string): boolean {\n+\t\ttry {\n+\t\t\tconst urlObj = new URL(url);\n+\t\t\t\n+\t\t\t// Check if URL is relative (part of the EPUB package)\n+\t\t\tif (urlObj.protocol === 'blob:') {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\t\n+\t\t\t// Check if URL is from the same origin\n+\t\t\tif (urlObj.origin === window.location.origin) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\t\n+\t\t\t// Check if URL has a data: scheme (only allow data:text/css)\n+\t\t\tif (urlObj.protocol === 'data:') {\n+\t\t\t\treturn url.startsWith('data:text/css');\n+\t\t\t}\n+\t\t\t\n+\t\t\t// Check for allowed domains (can be expanded based on requirements)\n+\t\t\tconst allowedDomains = ['fonts.googleapis.com', 'cdn.jsdelivr.net'];\n+\t\t\treturn allowedDomains.some(domain => urlObj.hostname === domain || urlObj.hostname.endsWith(`.${domain}`));\n+\t\t} catch (e) {\n+\t\t\t// If URL parsing fails, check if it's a relative path\n+\t\t\t// Relative paths are considered safe as they're within the EPUB package\n+\t\t\treturn !url.includes('://') && !url.startsWith('//');\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Validates if CSS content is safe\n+\t * @param css The CSS content to validate\n+\t * @return boolean indicating if the CSS is safe\n+\t */\n+\tprivate _isCssSafe(css: string): boolean {\n+\t\t// Basic validation to prevent common CSS-based attacks\n+\t\tconst dangerousPatterns = [\n+\t\t\t/@import\\s+url/i,                // Prevent nested imports\n+\t\t\t/expression\\s*\\(/i,              // Prevent CSS expressions (IE)\n+\t\t\t/-moz-binding/i,                 // Prevent XBL bindings\n+\t\t\t/behavior\\s*:/i,                 // Prevent behavior (IE)\n+\t\t\t/<\\/style>/i,                    // Prevent style tag closing\n+\t\t\t/<script/i,                      // Prevent script injection\n+\t\t\t/javascript:/i,                  // Prevent javascript: URLs\n+\t\t\t/data:\\s*text\\/html/i,           // Prevent data: HTML URLs\n+\t\t\t/url\\s*\\(\\s*[\"']?\\s*data:text\\/html/i, // Prevent data:text/html in url()\n+\t\t\t/url\\s*\\(\\s*[\"']?\\s*javascript:/i,     // Prevent javascript: in url()\n+\t\t\t/url\\s*\\(\\s*[\"']?\\s*https?:\\/\\/(?!fonts\\.googleapis\\.com|cdn\\.jsdelivr\\.net)/i, // Only allow specific external domains in url()\n+\t\t\t/@document/i,                    // Prevent @document rules which can be used for attacks\n+\t\t\t/@namespace/i,                   // Restrict @namespace which can be abused\n+\t\t\t/position\\s*:\\s*fixed/i,         // Prevent fixed positioning which can be used for UI redressing\n+\t\t\t/z-index\\s*:\\s*\\d{4,}/i          // Prevent very high z-index values which can be used for overlay attacks\n+\t\t];\n+\t\t\n+\t\treturn !dangerousPatterns.some(pattern => pattern.test(css));\n+\t}\n+\n \t/**\n \t * @param url The URL of a CSS stylesheet\n \t * @return A class to add to the scope element\n+\t * @throws Error if URL is invalid, fetch fails, or CSS content is unsafe\n \t */\n \tasync addByURL(url: string): Promise<string> {\n+\t\t// Validate URL before fetching\n+\t\tif (!this._isUrlSafe(url)) {\n+\t\t\tconsole.error('Unsafe CSS URL rejected:', url);\n+\t\t\tthrow new Error(`Unsafe CSS URL: ${url}`);\n+\t\t}\n+\t\t\n \t\tlet css;\n \t\tif (this._textCache.has(url)) {\n \t\t\tcss = this._textCache.get(url)!;\n \t\t}\n \t\telse {\n-\t\t\tcss = await (await fetch(url)).text();\n-\t\t\tthis._textCache.set(url, css);\n+\t\t\ttry {\n+\t\t\t\tconst response = await fetch(url);\n+\t\t\t\t\n+\t\t\t\t// Check if fetch was successful\n+\t\t\t\tif (!response.ok) {\n+\t\t\t\t\tthrow new Error(`Failed to fetch CSS: ${response.status} ${response.statusText}`);\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t\tcss = await response.text();\n+\t\t\t\t\n+\t\t\t\t// Validate CSS content before caching and applying\n+\t\t\t\tif (!this._isCssSafe(css)) {\n+\t\t\t\t\tthrow new Error('CSS content contains potentially unsafe patterns');\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t\tthis._textCache.set(url, css);\n+\t\t\t} catch (error) {\n+\t\t\t\tconsole.error('Error fetching or processing CSS:', error);\n+\t\t\t\tthrow error; // Re-throw to be handled by caller\n+\t\t\t}\n \t\t}\n+\t\t\n \t\treturn this.add(css);\n \t}\n "},{"message":"Fix the security vulnerability in the sanitizeAndRender function where it doesn't properly sanitize potentially dangerous HTML elements like script, iframe, or object, nor does it sanitize URLs in attributes like href or src. Implement proper HTML sanitization to prevent XSS attacks by: 1) Adding a whitelist of allowed elements, 2) Sanitizing all URLs to prevent JavaScript execution, 3) Removing all script and event handler attributes, and 4) Implementing proper attribute sanitization.","diff":"diff --git a/src/dom/epub/lib/sanitize-and-render.ts b/src/dom/epub/lib/sanitize-and-render.ts\nindex 1ca52fa..e14e0ce 100644\n--- a/src/dom/epub/lib/sanitize-and-render.ts\n+++ b/src/dom/epub/lib/sanitize-and-render.ts\n@@ -1,10 +1,125 @@\n+// Type declaration for postcss-selector-parser\n+declare module \"postcss-selector-parser\" {\n+  function parser(callback: (selectors: any) => void): { processSync: (selector: string) => string };\n+  namespace parser {\n+    function selector(options: any): any;\n+    function className(options: any): any;\n+    function combinator(options: any): any;\n+    function tag(options: any): any;\n+  }\n+  export = parser;\n+}\n+\n import parser from \"postcss-selector-parser\";\n \n+// Tags that should be replaced with custom elements\n const REPLACE_TAGS = new Set(['html', 'head', 'body', 'base', 'meta']);\n \n+// Whitelist of allowed HTML elements\n+const ALLOWED_ELEMENTS = new Set([\n+\t'a', 'abbr', 'address', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'blockquote', \n+\t'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', \n+\t'dd', 'del', 'details', 'dfn', 'div', 'dl', 'dt', 'em', 'figcaption', 'figure', 'footer', \n+\t'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'i', 'img', 'input', \n+\t'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'menu', 'meter', 'nav', \n+\t'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', \n+\t'rt', 'ruby', 's', 'samp', 'section', 'select', 'small', 'source', 'span', 'strong', \n+\t'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', \n+\t'time', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr'\n+]);\n+\n+// Attributes that are event handlers (to be removed)\n+const EVENT_HANDLER_ATTRIBUTES = new Set([\n+\t'onabort', 'onafterprint', 'onauxclick', 'onbeforeprint', 'onbeforeunload', 'onblur', \n+\t'oncancel', 'oncanplay', 'oncanplaythrough', 'onchange', 'onclick', 'onclose', 'oncontextmenu', \n+\t'oncopy', 'oncuechange', 'oncut', 'ondblclick', 'ondrag', 'ondragend', 'ondragenter', \n+\t'ondragleave', 'ondragover', 'ondragstart', 'ondrop', 'ondurationchange', 'onemptied', \n+\t'onended', 'onerror', 'onfocus', 'onformdata', 'onhashchange', 'oninput', 'oninvalid', \n+\t'onkeydown', 'onkeypress', 'onkeyup', 'onlanguagechange', 'onload', 'onloadeddata', \n+\t'onloadedmetadata', 'onloadstart', 'onmessage', 'onmessageerror', 'onmousedown', \n+\t'onmouseenter', 'onmouseleave', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', \n+\t'onoffline', 'ononline', 'onpagehide', 'onpageshow', 'onpaste', 'onpause', 'onplay', \n+\t'onplaying', 'onpopstate', 'onprogress', 'onratechange', 'onreset', 'onresize', \n+\t'onscroll', 'onsecuritypolicyviolation', 'onseeked', 'onseeking', 'onselect', \n+\t'onslotchange', 'onstalled', 'onstorage', 'onsubmit', 'onsuspend', 'ontimeupdate', \n+\t'ontoggle', 'onunload', 'onvolumechange', 'onwaiting', 'onwheel'\n+]);\n+\n+// Attributes that need URL sanitization\n+const URL_ATTRIBUTES = new Set(['href', 'src', 'xlink:href', 'poster', 'background', 'cite', 'action', 'formaction', 'longdesc', 'profile']);\n+\n+// Dangerous attributes that should be removed\n+const DANGEROUS_ATTRIBUTES = new Set(['srcdoc', 'sandbox', 'allowscriptaccess', 'allowpaymentrequest', 'allowfullscreen']);\n+\n+/**\n+ * Sanitizes a URL to prevent JavaScript execution\n+ * @param url The URL to sanitize\n+ * @returns Sanitized URL or empty string if unsafe\n+ */\n+function sanitizeUrl(url: string): string {\n+\t// Remove whitespace\n+\turl = url.trim();\n+\t\n+\t// Check for javascript: and data: URLs (except safe data: types)\n+\tif (/^javascript:/i.test(url) || \n+\t\t/^data:/i.test(url) && !/^data:image\\/(png|gif|jpeg|jpg|webp|bmp);/i.test(url)) {\n+\t\treturn '';\n+\t}\n+\t\n+\t// Allow relative URLs and http/https\n+\tif (url.startsWith('/') || url.startsWith('./') || url.startsWith('../') || \n+\t\t/^https?:\\/\\//i.test(url) || url.startsWith('#')) {\n+\t\treturn url;\n+\t}\n+\t\n+\t// Default to empty if we can't determine safety\n+\treturn '';\n+}\n+\n+/**\n+ * Sanitizes an attribute value\n+ * @param name Attribute name\n+ * @param value Attribute value\n+ * @returns Sanitized attribute value or null if attribute should be removed\n+ */\n+function sanitizeAttribute(name: string, value: string): string | null {\n+\t// Convert to lowercase for comparison\n+\tconst lowerName = name.toLowerCase();\n+\t\n+\t// Remove event handlers\n+\tif (EVENT_HANDLER_ATTRIBUTES.has(lowerName) || lowerName.startsWith('on')) {\n+\t\treturn null;\n+\t}\n+\t\n+\t// Remove dangerous attributes\n+\tif (DANGEROUS_ATTRIBUTES.has(lowerName)) {\n+\t\treturn null;\n+\t}\n+\t\n+\t// Sanitize URL attributes\n+\tif (URL_ATTRIBUTES.has(lowerName)) {\n+\t\treturn sanitizeUrl(value);\n+\t}\n+\t\n+\t// Remove javascript: from any attribute\n+\tif (typeof value === 'string' && /javascript:/i.test(value)) {\n+\t\treturn null;\n+\t}\n+\t\n+\t// Allow other attributes\n+\treturn value;\n+}\n+\n+// Forward declaration for TypeScript\n+interface StyleScoperInterface {\n+\tadd(css: string): Promise<string>;\n+\taddByURL(url: string): Promise<string>;\n+\ttableSelectors: Set<string>;\n+}\n+\n export async function sanitizeAndRender(xhtml: string, options: {\n \tcontainer: Element,\n-\tstyleScoper: StyleScoper,\n+\tstyleScoper: StyleScoperInterface,\n }): Promise<HTMLElement> {\n \tlet { container, styleScoper } = options;\n \n@@ -16,24 +131,34 @@ export async function sanitizeAndRender(xhtml: string, options: {\n \tlet elem: Element | null = null;\n \t// eslint-disable-next-line no-unmodified-loop-condition\n \twhile ((elem = walker.nextNode() as Element)) {\n-\t\tif (REPLACE_TAGS.has(elem.tagName)) {\n-\t\t\tlet newElem = doc.createElement('replaced-' + elem.tagName);\n+\t\tconst tagName = elem.tagName.toLowerCase();\n+\t\t\n+\t\t// Handle special tags that need to be replaced\n+\t\tif (REPLACE_TAGS.has(tagName)) {\n+\t\t\tlet newElem = doc.createElement('replaced-' + tagName);\n+\t\t\t// Sanitize attributes when replacing\n \t\t\tfor (let attr of elem.getAttributeNames()) {\n-\t\t\t\tnewElem.setAttribute(attr, elem.getAttribute(attr)!);\n+\t\t\t\tconst sanitizedValue = sanitizeAttribute(attr, elem.getAttribute(attr)!);\n+\t\t\t\tif (sanitizedValue !== null) {\n+\t\t\t\t\tnewElem.setAttribute(attr, sanitizedValue);\n+\t\t\t\t}\n \t\t\t}\n \t\t\tnewElem.append(...elem.childNodes);\n \t\t\telem.replaceWith(newElem);\n \t\t\twalker.currentNode = newElem;\n \t\t}\n-\t\telse if (elem.tagName == 'style') {\n+\t\t// Handle style elements\n+\t\telse if (tagName === 'style') {\n \t\t\tcontainer.classList.add(\n \t\t\t\tawait styleScoper.add(elem.innerHTML || '')\n \t\t\t);\n \t\t\ttoRemove.push(elem);\n \t\t}\n-\t\telse if (elem.tagName == 'link' && elem.getAttribute('rel')?.toLowerCase() == 'stylesheet') {\n+\t\t// Handle stylesheet links\n+\t\telse if (tagName === 'link' && elem.getAttribute('rel')?.toLowerCase() === 'stylesheet') {\n \t\t\tlet link = elem as HTMLLinkElement;\n \t\t\ttry {\n+\t\t\t\t// href will be sanitized in addByURL method\n \t\t\t\tcontainer.classList.add(\n \t\t\t\t\tawait styleScoper.addByURL(link.href)\n \t\t\t\t);\n@@ -43,9 +168,27 @@ export async function sanitizeAndRender(xhtml: string, options: {\n \t\t\t}\n \t\t\ttoRemove.push(elem);\n \t\t}\n-\t\telse if (elem.tagName == 'title') {\n+\t\t// Handle title elements\n+\t\telse if (tagName === 'title') {\n+\t\t\ttoRemove.push(elem);\n+\t\t}\n+\t\t// Remove disallowed elements\n+\t\telse if (!ALLOWED_ELEMENTS.has(tagName)) {\n \t\t\ttoRemove.push(elem);\n \t\t}\n+\t\t// Sanitize attributes of allowed elements\n+\t\telse {\n+\t\t\t// Get all attributes and sanitize them\n+\t\t\tconst attributes = Array.from(elem.attributes);\n+\t\t\tfor (const attr of attributes) {\n+\t\t\t\tconst sanitizedValue = sanitizeAttribute(attr.name, attr.value);\n+\t\t\t\tif (sanitizedValue === null) {\n+\t\t\t\t\telem.removeAttribute(attr.name);\n+\t\t\t\t} else if (sanitizedValue !== attr.value) {\n+\t\t\t\t\telem.setAttribute(attr.name, sanitizedValue);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n \n \tfor (let elem of toRemove) {"},{"message":"Fix the security vulnerability in EPUBView's setFontFamily method (lines 562-565) where it directly sets a CSS variable with user input without proper sanitization. Implement proper validation to ensure the input is a legitimate font family name, escape any special characters that could break out of the CSS property value context, and consider using a whitelist of allowed font families to prevent CSS injection attacks.","diff":"diff --git a/src/dom/epub/epub-view.ts b/src/dom/epub/epub-view.ts\nindex 24e4139..48f9886 100644\n--- a/src/dom/epub/epub-view.ts\n+++ b/src/dom/epub/epub-view.ts\n@@ -560,8 +560,60 @@ class EPUBView extends DOMView<EPUBViewState, EPUBViewData> {\n \t\t}\n \t}\n \n+\t/**\n+\t * Validates and sanitizes a font family name to prevent CSS injection\n+\t * @param fontFamily The font family name to validate\n+\t * @returns Sanitized font family name or a default font if invalid\n+\t */\n+\tprivate _validateFontFamily(fontFamily: string): string {\n+\t\t// Whitelist of allowed font families\n+\t\tconst allowedFonts = [\n+\t\t\t'Georgia', 'Times', 'Times New Roman', 'Arial', 'Helvetica', \n+\t\t\t'Verdana', 'Courier', 'Courier New', 'Tahoma', 'Geneva', \n+\t\t\t'Trebuchet MS', 'Palatino', 'Palatino Linotype', 'Garamond',\n+\t\t\t'Bookman', 'Avant Garde', 'Calibri', 'Cambria', 'Candara',\n+\t\t\t'Constantia', 'Segoe UI', 'Optima', 'Didot', 'Futura',\n+\t\t\t'Franklin Gothic', 'Copperplate', 'Baskerville', 'Monaco'\n+\t\t];\n+\n+\t\t// Check if the font is in our whitelist (case-insensitive)\n+\t\tconst normalizedInput = fontFamily.trim();\n+\t\tfor (const font of allowedFonts) {\n+\t\t\tif (font.toLowerCase() === normalizedInput.toLowerCase()) {\n+\t\t\t\treturn font; // Return the properly cased version from our whitelist\n+\t\t\t}\n+\t\t}\n+\n+\t\t// If the font contains any potentially dangerous characters, reject it\n+\t\tif (/[\\\\<>\\/\\(\\)\\{\\};:'\"!]/.test(normalizedInput)) {\n+\t\t\tconsole.warn(`Rejected potentially unsafe font family: ${fontFamily}`);\n+\t\t\treturn 'Georgia'; // Default fallback\n+\t\t}\n+\n+\t\t// For fonts not in whitelist but without dangerous characters, \n+\t\t// escape any remaining special characters and wrap in quotes if it contains spaces\n+\t\tlet sanitized = normalizedInput.replace(/['\"]/g, '');\n+\t\t\n+\t\t// If after all our checks the font name is empty, use the default\n+\t\tif (!sanitized) {\n+\t\t\treturn 'Georgia';\n+\t\t}\n+\t\t\n+\t\t// Wrap in quotes if it contains spaces\n+\t\tif (sanitized.includes(' ')) {\n+\t\t\tsanitized = `\"${sanitized}\"`;\n+\t\t}\n+\t\t\n+\t\treturn sanitized;\n+\t}\n+\n+\t/**\n+\t * Sets the font family for the content\n+\t * @param fontFamily The font family to use\n+\t */\n \tsetFontFamily(fontFamily: string) {\n-\t\tthis._iframeDocument.documentElement.style.setProperty('--content-font-family', fontFamily);\n+\t\tconst sanitizedFontFamily = this._validateFontFamily(fontFamily);\n+\t\tthis._iframeDocument.documentElement.style.setProperty('--content-font-family', sanitizedFontFamily);\n \t\tthis._renderAnnotations();\n \t}\n "},{"message":"Fix the bug in EPUBView's getRange method (lines 240-267) where it creates a new EpubCFI object from a string but immediately tries to access cfi.spinePos without checking if the conversion was successful. Implement proper error handling by adding a try-catch block around the EpubCFI construction, validating that the created object has a valid spinePos property, and handling conversion failures gracefully.","diff":"diff --git a/src/dom/epub/epub-view.ts b/src/dom/epub/epub-view.ts\nindex 48f9886..ea3f605 100644\n--- a/src/dom/epub/epub-view.ts\n+++ b/src/dom/epub/epub-view.ts\n@@ -244,9 +244,23 @@ class EPUBView extends DOMView<EPUBViewState, EPUBViewData> {\n \t\t\treturn null;\n \t\t}\n \t\tlet cfiString = cfi.toString();\n+\t\t\n+\t\t// Convert string to EpubCFI object with proper error handling\n \t\tif (typeof cfi === 'string') {\n-\t\t\tcfi = new EpubCFI(cfi);\n+\t\t\ttry {\n+\t\t\t\tcfi = new EpubCFI(cfi);\n+\t\t\t\t\n+\t\t\t\t// Validate that the created object has a valid spinePos property\n+\t\t\t\tif (cfi.spinePos === undefined || cfi.spinePos === null) {\n+\t\t\t\t\tconsole.error('Invalid CFI: missing spinePos property', cfiString);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t} catch (error) {\n+\t\t\t\tconsole.error('Failed to parse CFI string', cfiString, error);\n+\t\t\t\treturn null;\n+\t\t\t}\n \t\t}\n+\t\t\n \t\tlet view = this._sectionViews[cfi.spinePos];\n \t\tif (!view) {\n \t\t\tconsole.error('Unable to find view for CFI', cfiString);\n@@ -258,11 +272,19 @@ class EPUBView extends DOMView<EPUBViewState, EPUBViewData> {\n \t\tif (this._rangeCache.has(cfiString)) {\n \t\t\treturn this._rangeCache.get(cfiString)!.toRange();\n \t\t}\n-\t\tlet range = cfi.toRange(view.container.ownerDocument, undefined, view.container);\n-\t\tif (!range) {\n-\t\t\tconsole.error('Unable to get range for CFI', cfiString);\n+\t\t\n+\t\tlet range;\n+\t\ttry {\n+\t\t\trange = cfi.toRange(view.container.ownerDocument, undefined, view.container);\n+\t\t\tif (!range) {\n+\t\t\t\tconsole.error('Unable to get range for CFI', cfiString);\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t} catch (error) {\n+\t\t\tconsole.error('Error converting CFI to range', cfiString, error);\n \t\t\treturn null;\n \t\t}\n+\t\t\n \t\tthis._rangeCache.set(cfiString, new PersistentRange(range));\n \t\treturn range;\n \t}"},{"message":"Fix the bug in AbstractFlow's visibleViews getter (lines 141-151) where it doesn't validate the indexOf results when finding _cachedStartView and _cachedEndView in the views array. This could lead to unexpected slicing behavior if either view is not found (indexOf returns -1). Implement proper validation to check if either view wasn't found and handle that case appropriately.","diff":"diff --git a/src/dom/epub/flow.ts b/src/dom/epub/flow.ts\nindex 46496e8..2683d8b 100644\n--- a/src/dom/epub/flow.ts\n+++ b/src/dom/epub/flow.ts\n@@ -148,6 +148,13 @@ abstract class AbstractFlow implements Flow {\n \t\t}\n \t\tlet startIdx = this._view.views.indexOf(this._cachedStartView);\n \t\tlet endIdx = this._view.views.indexOf(this._cachedEndView);\n+\t\t\n+\t\t// Validate indexOf results - if either view is not found (indexOf returns -1),\n+\t\t// we can't determine the valid range of views\n+\t\tif (startIdx === -1 || endIdx === -1) {\n+\t\t\treturn [];\n+\t\t}\n+\t\t\n \t\treturn this._view.views.slice(startIdx, endIdx + 1);\n \t}\n "},{"message":"Fix the security vulnerability in EPUBView's navigate method (lines 663-665) where it uses querySelector with a user-provided hash. While the code does replace double quotes with escaped quotes, there could be other injection vectors. Implement proper validation to ensure the hash is a valid HTML5 ID and use a safer method like getElementById or CSS.escape() to prevent selector injection attacks.","diff":"diff --git a/src/dom/epub/epub-view.ts b/src/dom/epub/epub-view.ts\nindex ea3f605..42b0ecf 100644\n--- a/src/dom/epub/epub-view.ts\n+++ b/src/dom/epub/epub-view.ts\n@@ -735,8 +735,23 @@ class EPUBView extends DOMView<EPUBViewState, EPUBViewData> {\n \t\t\t\tconsole.error('Unable to find section for pathname', pathname);\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\tlet target = hash && this._sectionViews[section.index].container\n-\t\t\t\t.querySelector('[id=\"' + hash.replace(/\"/g, '\\\\\"') + '\"]');\n+\t\t\t// Validate hash is a valid HTML5 ID before using it\n+\t\t\tlet target = null;\n+\t\t\tif (hash) {\n+\t\t\t\t// First try using getElementById which is safer than querySelector\n+\t\t\t\ttarget = this._sectionViews[section.index].container.ownerDocument.getElementById(hash);\n+\t\t\t\t\n+\t\t\t\t// If not found and the hash is a valid HTML5 ID, try with CSS.escape for safety\n+\t\t\t\tif (!target && this._isValidHTML5Id(hash)) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\t// Use CSS.escape to properly escape the ID for use in a selector\n+\t\t\t\t\t\ttarget = this._sectionViews[section.index].container\n+\t\t\t\t\t\t\t.querySelector(`#${CSS.escape(hash)}`);\n+\t\t\t\t\t} catch (error) {\n+\t\t\t\t\t\tconsole.error('Error using CSS.escape with hash:', hash, error);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tif (target) {\n \t\t\t\tthis.flow.scrollIntoView(target as HTMLElement, options);\n \t\t\t}\n@@ -823,6 +838,40 @@ class EPUBView extends DOMView<EPUBViewState, EPUBViewData> {\n \tsetSidebarOpen(_sidebarOpen: boolean) {\n \t\twindow.dispatchEvent(new Event('resize'));\n \t}\n+\t\n+\t/**\n+\t * Validates if a string is a valid HTML5 ID\n+\t * @param id The ID to validate\n+\t * @returns True if the ID is valid according to HTML5 spec\n+\t */\n+\tprivate _isValidHTML5Id(id: string): boolean {\n+\t\tif (!id || typeof id !== 'string') {\n+\t\t\treturn false;\n+\t\t}\n+\t\t\n+\t\t// HTML5 ID must not contain whitespace\n+\t\tif (/\\s/.test(id)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t\n+\t\t// Check for potentially dangerous characters that could be used for XSS\n+\t\tif (/[<>(){}[\\]\"'\\/\\\\=;]/.test(id)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t\n+\t\t// Additional check for common XSS patterns\n+\t\tconst dangerousPatterns = [\n+\t\t\t'javascript:', 'data:', 'vbscript:', 'file:', \n+\t\t\t'onerror', 'onload', 'onclick', 'onmouseover'\n+\t\t];\n+\t\t\n+\t\tconst lowerCaseId = id.toLowerCase();\n+\t\tif (dangerousPatterns.some(pattern => lowerCaseId.includes(pattern))) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t\n+\t\treturn true;\n+\t}\n \n \tstatic getContainingSectionIndex(rangeOrNode: Range | Node): number | null {\n \t\tlet elem;"},{"message":"Fix the issue in the sanitizeAndRender function's tree walker loop (lines 17-48) where it modifies the DOM while traversing it, which could lead to unexpected behavior or missed elements. Refactor the function to first collect all elements that need modification without changing the DOM, and then apply the modifications after the traversal is complete.","diff":"diff --git a/src/dom/epub/lib/sanitize-and-render.ts b/src/dom/epub/lib/sanitize-and-render.ts\nindex e14e0ce..11aade7 100644\n--- a/src/dom/epub/lib/sanitize-and-render.ts\n+++ b/src/dom/epub/lib/sanitize-and-render.ts\n@@ -126,73 +126,136 @@ export async function sanitizeAndRender(xhtml: string, options: {\n \tlet doc = container.ownerDocument;\n \tlet sectionDoc = new DOMParser().parseFromString(xhtml, 'application/xhtml+xml');\n \tlet walker = doc.createTreeWalker(sectionDoc, NodeFilter.SHOW_ELEMENT);\n-\tlet toRemove = [];\n-\n+\t\n+\t// Define types for our element modifications\n+\ttype ElementToRemove = Element;\n+\ttype ElementToReplace = {\n+\t\telement: Element;\n+\t\treplacement: Element;\n+\t};\n+\ttype ElementAttributesToModify = {\n+\t\telement: Element;\n+\t\tattributesToRemove: string[];\n+\t\tattributesToSet: {name: string, value: string}[];\n+\t};\n+\ttype StyleToAdd = string;\n+\ttype StyleURLToAdd = string;\n+\t\n+\t// Collection arrays for modifications\n+\tlet elementsToRemove: ElementToRemove[] = [];\n+\tlet elementsToReplace: ElementToReplace[] = [];\n+\tlet elementsAttributesToModify: ElementAttributesToModify[] = [];\n+\tlet stylesToAdd: StyleToAdd[] = [];\n+\tlet styleURLsToAdd: StyleURLToAdd[] = [];\n+\n+\t// First pass: collect all modifications without changing the DOM\n \tlet elem: Element | null = null;\n-\t// eslint-disable-next-line no-unmodified-loop-condition\n \twhile ((elem = walker.nextNode() as Element)) {\n \t\tconst tagName = elem.tagName.toLowerCase();\n \t\t\n \t\t// Handle special tags that need to be replaced\n \t\tif (REPLACE_TAGS.has(tagName)) {\n \t\t\tlet newElem = doc.createElement('replaced-' + tagName);\n-\t\t\t// Sanitize attributes when replacing\n+\t\t\t// Collect attributes to set on the new element\n \t\t\tfor (let attr of elem.getAttributeNames()) {\n \t\t\t\tconst sanitizedValue = sanitizeAttribute(attr, elem.getAttribute(attr)!);\n \t\t\t\tif (sanitizedValue !== null) {\n \t\t\t\t\tnewElem.setAttribute(attr, sanitizedValue);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tnewElem.append(...elem.childNodes);\n-\t\t\telem.replaceWith(newElem);\n-\t\t\twalker.currentNode = newElem;\n+\t\t\telementsToReplace.push({\n+\t\t\t\telement: elem,\n+\t\t\t\treplacement: newElem\n+\t\t\t});\n \t\t}\n \t\t// Handle style elements\n \t\telse if (tagName === 'style') {\n-\t\t\tcontainer.classList.add(\n-\t\t\t\tawait styleScoper.add(elem.innerHTML || '')\n-\t\t\t);\n-\t\t\ttoRemove.push(elem);\n+\t\t\tstylesToAdd.push(elem.innerHTML || '');\n+\t\t\telementsToRemove.push(elem);\n \t\t}\n \t\t// Handle stylesheet links\n \t\telse if (tagName === 'link' && elem.getAttribute('rel')?.toLowerCase() === 'stylesheet') {\n \t\t\tlet link = elem as HTMLLinkElement;\n-\t\t\ttry {\n-\t\t\t\t// href will be sanitized in addByURL method\n-\t\t\t\tcontainer.classList.add(\n-\t\t\t\t\tawait styleScoper.addByURL(link.href)\n-\t\t\t\t);\n-\t\t\t}\n-\t\t\tcatch (e) {\n-\t\t\t\tconsole.error(e);\n-\t\t\t}\n-\t\t\ttoRemove.push(elem);\n+\t\t\tstyleURLsToAdd.push(link.href);\n+\t\t\telementsToRemove.push(elem);\n \t\t}\n \t\t// Handle title elements\n \t\telse if (tagName === 'title') {\n-\t\t\ttoRemove.push(elem);\n+\t\t\telementsToRemove.push(elem);\n \t\t}\n \t\t// Remove disallowed elements\n \t\telse if (!ALLOWED_ELEMENTS.has(tagName)) {\n-\t\t\ttoRemove.push(elem);\n+\t\t\telementsToRemove.push(elem);\n \t\t}\n \t\t// Sanitize attributes of allowed elements\n \t\telse {\n-\t\t\t// Get all attributes and sanitize them\n+\t\t\t// Collect attribute modifications\n+\t\t\tconst attributesToRemove: string[] = [];\n+\t\t\tconst attributesToSet: {name: string, value: string}[] = [];\n+\t\t\t\n \t\t\tconst attributes = Array.from(elem.attributes);\n \t\t\tfor (const attr of attributes) {\n \t\t\t\tconst sanitizedValue = sanitizeAttribute(attr.name, attr.value);\n \t\t\t\tif (sanitizedValue === null) {\n-\t\t\t\t\telem.removeAttribute(attr.name);\n+\t\t\t\t\tattributesToRemove.push(attr.name);\n \t\t\t\t} else if (sanitizedValue !== attr.value) {\n-\t\t\t\t\telem.setAttribute(attr.name, sanitizedValue);\n+\t\t\t\t\tattributesToSet.push({name: attr.name, value: sanitizedValue});\n \t\t\t\t}\n \t\t\t}\n+\t\t\t\n+\t\t\tif (attributesToRemove.length > 0 || attributesToSet.length > 0) {\n+\t\t\t\telementsAttributesToModify.push({\n+\t\t\t\t\telement: elem,\n+\t\t\t\t\tattributesToRemove,\n+\t\t\t\t\tattributesToSet\n+\t\t\t\t});\n+\t\t\t}\n \t\t}\n \t}\n \n-\tfor (let elem of toRemove) {\n-\t\telem.remove();\n+\t// Second pass: Apply all collected modifications\n+\t\n+\t// 1. Process styles first (doesn't modify DOM structure)\n+\tfor (const css of stylesToAdd) {\n+\t\ttry {\n+\t\t\tcontainer.classList.add(\n+\t\t\t\tawait styleScoper.add(css)\n+\t\t\t);\n+\t\t} catch (e) {\n+\t\t\tconsole.error('Error processing style:', e);\n+\t\t}\n+\t}\n+\t\n+\t// 2. Process style URLs\n+\tfor (const url of styleURLsToAdd) {\n+\t\ttry {\n+\t\t\tcontainer.classList.add(\n+\t\t\t\tawait styleScoper.addByURL(url)\n+\t\t\t);\n+\t\t} catch (e) {\n+\t\t\tconsole.error('Error processing style URL:', e);\n+\t\t}\n+\t}\n+\t\n+\t// 3. Modify attributes\n+\tfor (const {element, attributesToRemove, attributesToSet} of elementsAttributesToModify) {\n+\t\tfor (const attrName of attributesToRemove) {\n+\t\t\telement.removeAttribute(attrName);\n+\t\t}\n+\t\tfor (const {name, value} of attributesToSet) {\n+\t\t\telement.setAttribute(name, value);\n+\t\t}\n+\t}\n+\t\n+\t// 4. Replace elements\n+\tfor (const {element, replacement} of elementsToReplace) {\n+\t\treplacement.append(...element.childNodes);\n+\t\telement.replaceWith(replacement);\n+\t}\n+\t\n+\t// 5. Remove elements (do this last to ensure proper structure)\n+\tfor (const element of elementsToRemove) {\n+\t\telement.remove();\n \t}\n \n \tcontainer.append(...sectionDoc.childNodes);"},{"message":"Fix the issue in the shortenCFI and lengthenCFI functions where they don't validate that the input is a valid CFI string. Implement proper validation to check if the input is a valid CFI string before processing it, handle edge cases like null, undefined, or non-string inputs, and provide consistent behavior for invalid inputs.","diff":"diff --git a/src/dom/epub/cfi.ts b/src/dom/epub/cfi.ts\nindex a435c7b..6d0596c 100644\n--- a/src/dom/epub/cfi.ts\n+++ b/src/dom/epub/cfi.ts\n@@ -1,8 +1,92 @@\n+/**\n+ * Validates if a string is a valid CFI\n+ * @param cfi The CFI string to validate\n+ * @returns true if the CFI is valid, false otherwise\n+ */\n+function isValidCFI(cfi: any): boolean {\n+\t// Check if input is a string\n+\tif (typeof cfi !== 'string') {\n+\t\treturn false;\n+\t}\n+\t\n+\t// Check if string is empty\n+\tif (cfi.trim() === '') {\n+\t\treturn false;\n+\t}\n+\t\n+\t// Special case for '_start' which is used in the codebase\n+\tif (cfi === '_start') {\n+\t\treturn true;\n+\t}\n+\t\n+\t// Basic CFI format validation\n+\t// A valid CFI either starts with 'epubcfi(' and ends with ')'\n+\t// or contains path segments separated by '/'\n+\tconst hasValidWrapper = cfi.startsWith('epubcfi(') && cfi.endsWith(')');\n+\tconst hasValidContent = /^(epubcfi\\()?([0-9]+\\/[0-9!]+(\\:[0-9]+)?(\\[[^\\]]+\\])?)+(\\))?$/.test(cfi);\n+\t\n+\treturn hasValidContent || hasValidWrapper;\n+}\n+\n+/**\n+ * Removes the 'epubcfi()' wrapper from a CFI string\n+ * @param cfi The CFI string to shorten\n+ * @returns The shortened CFI string, or the original input if it's already shortened or invalid\n+ */\n export function shortenCFI(cfi: string): string {\n+\t// Handle null, undefined, or non-string inputs\n+\tif (typeof cfi !== 'string') {\n+\t\tconsole.warn(`Invalid CFI passed to shortenCFI: ${cfi}`);\n+\t\treturn '';\n+\t}\n+\t\n+\t// Handle empty strings\n+\tif (cfi.trim() === '') {\n+\t\treturn '';\n+\t}\n+\t\n+\t// Special case for '_start' which is used in the codebase\n+\tif (cfi === '_start') {\n+\t\treturn cfi;\n+\t}\n+\t\n+\t// If it doesn't look like a CFI at all, return the original to avoid breaking things\n+\tif (!cfi.includes('/') && !cfi.startsWith('epubcfi(')) {\n+\t\tconsole.warn(`Potentially invalid CFI passed to shortenCFI: ${cfi}`);\n+\t\treturn cfi;\n+\t}\n+\t\n \treturn cfi.replace(/^epubcfi\\((.+)\\)$/, '$1');\n }\n \n+/**\n+ * Adds the 'epubcfi()' wrapper to a CFI string if it doesn't already have it\n+ * @param cfi The CFI string to lengthen\n+ * @returns The lengthened CFI string, or the original input if it's already lengthened or invalid\n+ */\n export function lengthenCFI(cfi: string): string {\n+\t// Handle null, undefined, or non-string inputs\n+\tif (typeof cfi !== 'string') {\n+\t\tconsole.warn(`Invalid CFI passed to lengthenCFI: ${cfi}`);\n+\t\treturn '';\n+\t}\n+\t\n+\t// Handle empty strings\n+\tif (cfi.trim() === '') {\n+\t\treturn '';\n+\t}\n+\t\n+\t// Special case for '_start' which is used in the codebase\n+\tif (cfi === '_start') {\n+\t\treturn cfi;\n+\t}\n+\t\n+\t// If it doesn't look like a CFI at all, return the original to avoid breaking things\n+\tif (!cfi.includes('/')) {\n+\t\tconsole.warn(`Potentially invalid CFI passed to lengthenCFI: ${cfi}`);\n+\t\treturn cfi;\n+\t}\n+\t\n \tif (cfi.startsWith('epubcfi(') && cfi.endsWith(')')) {\n \t\treturn cfi;\n \t}"},{"message":"Fix the accessibility issue in PaginatedFlow's _handleTouchMove method (lines 547-566) where it calls event.preventDefault() unconditionally, which could interfere with other touch interactions and break accessibility features. Modify the method to only prevent default behavior when it's determined that the touch movement is actually being used for page navigation, and implement a threshold before claiming the touch event.","diff":"diff --git a/src/dom/epub/flow.ts b/src/dom/epub/flow.ts\nindex 2683d8b..19d8959 100644\n--- a/src/dom/epub/flow.ts\n+++ b/src/dom/epub/flow.ts\n@@ -563,8 +563,31 @@ export class PaginatedFlow extends AbstractFlow {\n \t\tif (!touch) {\n \t\t\treturn;\n \t\t}\n-\t\tevent.preventDefault();\n-\t\tlet swipeAmount = (touch.clientX - this._touchStartX) / 100;\n+\t\t\n+\t\t// Calculate horizontal movement distance\n+\t\tconst touchDeltaX = touch.clientX - this._touchStartX;\n+\t\tconst absMovement = Math.abs(touchDeltaX);\n+\t\t\n+\t\t// Define a threshold (in pixels) before we consider this a page navigation gesture\n+\t\t// This allows small movements without triggering navigation\n+\t\tconst SWIPE_THRESHOLD = 20;\n+\t\t\n+\t\t// Only prevent default behavior if we've determined this is a page navigation gesture\n+\t\tif (absMovement >= SWIPE_THRESHOLD) {\n+\t\t\t// Check if we're in a scrollable element that should handle this touch natively\n+\t\t\tconst target = event.target as Element;\n+\t\t\tconst scrollableParent = target.closest('table, .table-like, [data-scrollable]');\n+\t\t\t\n+\t\t\t// Only prevent default if we're not in a scrollable element that needs horizontal scrolling\n+\t\t\tif (!scrollableParent || \n+\t\t\t\t!(scrollableParent.scrollWidth > scrollableParent.clientWidth && \n+\t\t\t\t  (touchDeltaX < 0 ? scrollableParent.scrollLeft < scrollableParent.scrollWidth - scrollableParent.clientWidth : \n+\t\t\t\t                     scrollableParent.scrollLeft > 0))) {\n+\t\t\t\tevent.preventDefault();\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tlet swipeAmount = touchDeltaX / 100;\n \t\t// If on the first/last page, clamp the CSS variable so the indicator doesn't expand all the way\n \t\tif (swipeAmount < 0 && !this.canNavigateToNextPage()) {\n \t\t\tswipeAmount = Math.max(swipeAmount, -0.6);\n@@ -572,8 +595,12 @@ export class PaginatedFlow extends AbstractFlow {\n \t\telse if (swipeAmount > 0 && !this.canNavigateToPreviousPage()) {\n \t\t\tswipeAmount = Math.min(swipeAmount, 0.6);\n \t\t}\n-\t\tthis._iframeDocument.body.classList.add('swiping');\n-\t\tthis._iframeDocument.documentElement.style.setProperty('--swipe-amount', swipeAmount.toString());\n+\t\t\n+\t\t// Only add swiping class if we've passed the threshold\n+\t\tif (absMovement >= SWIPE_THRESHOLD) {\n+\t\t\tthis._iframeDocument.body.classList.add('swiping');\n+\t\t\tthis._iframeDocument.documentElement.style.setProperty('--swipe-amount', swipeAmount.toString());\n+\t\t}\n \t};\n \n \tprivate _handleTouchEnd = (event: TouchEvent) => {\n@@ -584,13 +611,33 @@ export class PaginatedFlow extends AbstractFlow {\n \t\tif (!touch) {\n \t\t\treturn;\n \t\t}\n-\t\tevent.preventDefault();\n+\t\t\n+\t\t// Calculate horizontal movement distance\n+\t\tconst touchDeltaX = touch.clientX - this._touchStartX;\n+\t\tconst absMovement = Math.abs(touchDeltaX);\n+\t\t\n+\t\t// Define the same threshold as in _handleTouchMove\n+\t\tconst SWIPE_THRESHOLD = 20;\n+\t\t\n+\t\t// Only prevent default if the movement was significant enough to be considered a page navigation\n+\t\tif (absMovement >= SWIPE_THRESHOLD) {\n+\t\t\t// Check if we're in a scrollable element that should handle this touch natively\n+\t\t\tconst target = event.target as Element;\n+\t\t\tconst scrollableParent = target.closest('table, .table-like, [data-scrollable]');\n+\t\t\t\n+\t\t\t// Only prevent default if we're not in a scrollable element that needs horizontal scrolling\n+\t\t\tif (!scrollableParent || \n+\t\t\t\t!(scrollableParent.scrollWidth > scrollableParent.clientWidth)) {\n+\t\t\t\tevent.preventDefault();\n+\t\t\t}\n+\t\t}\n+\t\t\n \t\tthis._iframeDocument.body.classList.remove('swiping');\n \t\tthis._iframeDocument.documentElement.style.setProperty('--swipe-amount', '0');\n \t\tthis._touchStartID = null;\n \n \t\t// Switch pages after swiping 100px\n-\t\tlet swipeAmount = (touch.clientX - this._touchStartX) / 100;\n+\t\tlet swipeAmount = touchDeltaX / 100;\n \t\tif (swipeAmount <= -1) {\n \t\t\tthis.navigateToNextPage();\n \t\t}"},{"message":"Fix the issue in PaginatedFlow's constructor (line 357) where it assumes that the .sections element exists in the DOM without proper error handling. Implement proper error handling to check if the element exists before assigning it, and provide a fallback mechanism to create the element if it doesn't exist.","diff":"diff --git a/src/dom/epub/flow.ts b/src/dom/epub/flow.ts\nindex 19d8959..04857bc 100644\n--- a/src/dom/epub/flow.ts\n+++ b/src/dom/epub/flow.ts\n@@ -365,7 +365,20 @@ export class PaginatedFlow extends AbstractFlow {\n \n \tconstructor(options: Options) {\n \t\tsuper(options);\n-\t\tthis._sectionsContainer = this._iframeDocument.body.querySelector(':scope > .sections')! as HTMLElement;\n+\t\t\n+\t\t// Check if the sections container exists\n+\t\tlet sectionsContainer = this._iframeDocument.body.querySelector(':scope > .sections') as HTMLElement | null;\n+\t\t\n+\t\t// If it doesn't exist, create it\n+\t\tif (!sectionsContainer) {\n+\t\t\tsectionsContainer = this._iframeDocument.createElement('div');\n+\t\t\tsectionsContainer.className = 'sections';\n+\t\t\tthis._iframeDocument.body.appendChild(sectionsContainer);\n+\t\t\tconsole.warn('PaginatedFlow: .sections element not found, created fallback element');\n+\t\t}\n+\t\t\n+\t\tthis._sectionsContainer = sectionsContainer;\n+\t\t\n \t\tthis._iframeDocument.addEventListener('keydown', this._handleKeyDown, { capture: true });\n \t\tthis._iframeDocument.body.addEventListener('touchstart', this._handleTouchStart);\n \t\tthis._iframeDocument.body.addEventListener('touchmove', this._handleTouchMove);"},{"message":"Fix the issue in EPUBFindProcessor's _processViews method (lines 112-119) where it checks if this._totalResults > maxResults but doesn't check if adding the current batch would exceed maxResults. Implement a better approach that checks the number of results after processing each view and breaks the loop if the limit has been reached or exceeded, and consider modifying the _getOrCreateProcessor method to accept a remainingResults parameter to limit the number of results it adds.","diff":"diff --git a/src/dom/epub/find.ts b/src/dom/epub/find.ts\nindex 9cdea53..9f72d97 100644\n--- a/src/dom/epub/find.ts\n+++ b/src/dom/epub/find.ts\n@@ -47,7 +47,7 @@ export class EPUBFindProcessor implements FindProcessor {\n \t\tif (nextIndex < 0) {\n \t\t\tnextIndex += this.view.views.length;\n \t\t}\n-\t\tthis._selectedProcessor = this._getOrCreateProcessor(this.view.views[nextIndex]);\n+\t\tthis._selectedProcessor = this._getOrCreateProcessor(this.view.views[nextIndex], undefined, undefined);\n \t\tlet stop = this._selectedProcessor;\n \t\tdo {\n \t\t\tif (this._selectedProcessor.getResults().length) {\n@@ -58,7 +58,7 @@ export class EPUBFindProcessor implements FindProcessor {\n \t\t\tif (nextIndex < 0) {\n \t\t\t\tnextIndex += this.view.views.length;\n \t\t\t}\n-\t\t\tthis._selectedProcessor = this._getOrCreateProcessor(this.view.views[nextIndex]);\n+\t\t\tthis._selectedProcessor = this._getOrCreateProcessor(this.view.views[nextIndex], undefined, undefined);\n \t\t}\n \t\twhile (this._selectedProcessor !== stop);\n \n@@ -76,7 +76,7 @@ export class EPUBFindProcessor implements FindProcessor {\n \t\tlet nextIndex = this._selectedProcessor ? this._processors.indexOf(this._selectedProcessor) + 1 : 0;\n \t\tnextIndex %= this.view.views.length;\n \t\tif (this._selectedProcessor) this._selectedProcessor.position = null;\n-\t\tthis._selectedProcessor = this._getOrCreateProcessor(this.view.views[nextIndex]);\n+\t\tthis._selectedProcessor = this._getOrCreateProcessor(this.view.views[nextIndex], undefined, undefined);\n \t\tlet stop = this._selectedProcessor;\n \t\tdo {\n \t\t\tif (this._selectedProcessor.getResults().length) {\n@@ -87,7 +87,7 @@ export class EPUBFindProcessor implements FindProcessor {\n \n \t\t\tnextIndex++;\n \t\t\tnextIndex %= this.view.views.length;\n-\t\t\tthis._selectedProcessor = this._getOrCreateProcessor(this.view.views[nextIndex]);\n+\t\t\tthis._selectedProcessor = this._getOrCreateProcessor(this.view.views[nextIndex], undefined, undefined);\n \t\t}\n \t\twhile (this._selectedProcessor !== stop);\n \n@@ -112,28 +112,42 @@ export class EPUBFindProcessor implements FindProcessor {\n \n \tprivate _processViews(views: SectionView[], startRange?: Range, maxResults?: number) {\n \t\tfor (let view of views) {\n-\t\t\tif (maxResults !== undefined && this._totalResults > maxResults) {\n+\t\t\tif (maxResults !== undefined && this._totalResults >= maxResults) {\n \t\t\t\tbreak;\n \t\t\t}\n-\t\t\tthis._getOrCreateProcessor(view, startRange);\n+\t\t\tconst remainingResults = maxResults !== undefined ? maxResults - this._totalResults : undefined;\n+\t\t\tthis._getOrCreateProcessor(view, startRange, remainingResults);\n \t\t}\n \t}\n \n-\tprivate _getOrCreateProcessor(view: SectionView, startRange?: Range): DefaultFindProcessor {\n+\tprivate _getOrCreateProcessor(view: SectionView, startRange?: Range, remainingResults?: number): DefaultFindProcessor {\n \t\tif (this._processors[view.section.index]) {\n \t\t\treturn this._processors[view.section.index];\n \t\t}\n+\t\t\n+\t\t// Create a custom find processor that respects the remaining results limit\n \t\tlet processor = new DefaultFindProcessor({\n \t\t\tsearchContext: view.searchContext,\n \t\t\tstartRange,\n \t\t\tfindState: { ...this.findState },\n \t\t\tannotationKeyPrefix: 'section' + view.section.index,\n \t\t});\n+\t\t\n \t\tthis._processors[view.section.index] = processor;\n \t\tif (!this._selectedProcessor && processor.initialPosition !== null) {\n \t\t\tthis._selectedProcessor = processor;\n \t\t}\n-\t\tthis._totalResults += processor.getResults().length;\n+\t\t\n+\t\t// Get the results and limit them if necessary\n+\t\tconst results = processor.getResults();\n+\t\tlet resultsToAdd = results.length;\n+\t\t\n+\t\t// If we have a remaining results limit, only count up to that limit\n+\t\tif (remainingResults !== undefined && resultsToAdd > remainingResults) {\n+\t\t\tresultsToAdd = remainingResults;\n+\t\t}\n+\t\t\n+\t\tthis._totalResults += resultsToAdd;\n \t\tthis._setFindState();\n \t\treturn processor;\n \t}"},{"message":"Fix the inefficiency issue in EPUBFindProcessor's prev and next methods (lines 37-94) where they loop through all processors and return null if there are no search results, which could be inefficient for large documents with many sections. Implement a more efficient approach by adding a property to track if we've already determined there are no results, and modify the methods to return early in that case.","diff":"diff --git a/src/dom/epub/find.ts b/src/dom/epub/find.ts\nindex 9f72d97..23f0fe3 100644\n--- a/src/dom/epub/find.ts\n+++ b/src/dom/epub/find.ts\n@@ -17,6 +17,8 @@ export class EPUBFindProcessor implements FindProcessor {\n \tprivate _selectedProcessor: DefaultFindProcessor | null = null;\n \n \tprivate _totalResults = 0;\n+\t\n+\tprivate _noResultsFound = false;\n \n \tprivate readonly _onSetFindState?: (state?: FindState) => void;\n \n@@ -33,9 +35,17 @@ export class EPUBFindProcessor implements FindProcessor {\n \t\t// Process visible views first, and then the rest of the views if we haven't exceeded 999 results yet\n \t\tthis._processViews(this.view.flow.visibleViews, options.startRange);\n \t\tthis._processViews(this.view.views, undefined, 999);\n+\t\t\n+\t\t// If no results were found after processing all views, set the flag\n+\t\tthis._noResultsFound = this._totalResults === 0;\n \t}\n \n \tprev(): FindResult | null {\n+\t\t// Early return if we already know there are no results\n+\t\tif (this._noResultsFound) {\n+\t\t\treturn null;\n+\t\t}\n+\n \t\tif (this._selectedProcessor) {\n \t\t\tthis._selectedProcessor.prev(false);\n \t\t\tthis._setFindState();\n@@ -62,10 +72,17 @@ export class EPUBFindProcessor implements FindProcessor {\n \t\t}\n \t\twhile (this._selectedProcessor !== stop);\n \n+\t\t// If we've gone through all processors and found no results, set the flag for future calls\n+\t\tthis._noResultsFound = true;\n \t\treturn null;\n \t}\n \n \tnext(): FindResult | null {\n+\t\t// Early return if we already know there are no results\n+\t\tif (this._noResultsFound) {\n+\t\t\treturn null;\n+\t\t}\n+\n \t\tif (this._selectedProcessor) {\n \t\t\tthis._selectedProcessor.next(false);\n \t\t\tthis._setFindState();\n@@ -91,6 +108,8 @@ export class EPUBFindProcessor implements FindProcessor {\n \t\t}\n \t\twhile (this._selectedProcessor !== stop);\n \n+\t\t// If we've gone through all processors and found no results, set the flag for future calls\n+\t\tthis._noResultsFound = true;\n \t\treturn null;\n \t}\n "}]}]}